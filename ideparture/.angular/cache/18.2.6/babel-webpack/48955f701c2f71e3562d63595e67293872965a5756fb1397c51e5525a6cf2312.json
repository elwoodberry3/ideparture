{"ast":null,"code":"import _asyncToGenerator from \"/Users/adbyrd/Documents/clients/elwood.berry/github/ideparture/ideparture/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, makeEnvironmentProviders, input, numberAttribute, booleanAttribute, computed, Component, ChangeDetectionStrategy, Injector, Renderer2, PLATFORM_ID, ElementRef, effect, runInInjectionContext, NgModule, Inject } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { isObservable } from 'rxjs';\nconst NgGlyphConfigToken = new InjectionToken('Ng Glyph Config');\nconst defaultConfig$1 = {\n  size: '1em',\n  opticalSize: 20,\n  weight: 400,\n  grade: 0,\n  fill: false\n};\n/**\n * Provide the configuration for the glyph\n * @param config The configuration to use\n */\nfunction provideNgGlyphsConfig(config) {\n  return {\n    provide: NgGlyphConfigToken,\n    useValue: {\n      ...defaultConfig$1,\n      ...config\n    }\n  };\n}\n/**\n * Inject the configuration for the glyphs\n * @returns The configuration to use\n * @internal\n */\nfunction injectNgGlyphsConfig() {\n  return inject(NgGlyphConfigToken, {\n    optional: true\n  }) ?? defaultConfig$1;\n}\nconst NgGlyphsToken = new InjectionToken('NgGlyphsToken');\nfunction provideNgGlyphs(...glyphsets) {\n  // if there are no glyphsets, throw an error\n  if (!glyphsets.length) {\n    throw new Error('Please provide at least one glyphset.');\n  }\n  // the default glyphset is the first one\n  const defaultGlyphset = glyphsets[0].name;\n  return makeEnvironmentProviders([{\n    provide: NgGlyphsToken,\n    useValue: {\n      defaultGlyphset,\n      glyphsets\n    }\n  }]);\n}\nfunction injectNgGlyphs() {\n  const glyphs = inject(NgGlyphsToken, {\n    optional: true\n  });\n  if (!glyphs) {\n    throw new Error('Please provide the glyphs using the provideNgGlyphs() function.');\n  }\n  return glyphs;\n}\nfunction coerceCssPixelValue(value) {\n  return value == null ? '' : /^\\d+$/.test(value) ? `${value}px` : value;\n}\nclass NgGlyph {\n  constructor() {\n    /**\n     * Access the available glyphsets\n     */\n    this.glyphsets = injectNgGlyphs();\n    /**\n     * Access the default configuration\n     */\n    this.config = injectNgGlyphsConfig();\n    /**\n     * Define the name of the glyph to display\n     */\n    this.name = input.required();\n    /**\n     * Define the glyphset to use\n     */\n    this.glyphset = input(this.glyphsets.defaultGlyphset);\n    /**\n     * Define the optical size of the glyph\n     */\n    this.opticalSize = input(this.config.opticalSize, {\n      transform: numberAttribute\n    });\n    /**\n     * Define the weight of the glyph\n     */\n    this.weight = input(this.config.weight, {\n      transform: numberAttribute\n    });\n    /**\n     * Define the grade of the glyph\n     */\n    this.grade = input(this.config.grade, {\n      transform: numberAttribute\n    });\n    /**\n     * Define the fill of the glyph\n     */\n    this.fill = input(this.config.fill, {\n      transform: booleanAttribute\n    });\n    /**\n     * Define the size of the glyph\n     */\n    this.size = input(this.config.size, {\n      transform: coerceCssPixelValue\n    });\n    /**\n     * Define the color of the glyph\n     */\n    this.color = input(this.config.color);\n    /**\n     * Derive the glyphset class from the glyphset name\n     */\n    this.glyphsetClass = computed(() => {\n      const glyphset = this.glyphsets.glyphsets.find(glyphset => glyphset.name === this.glyphset());\n      if (!glyphset) {\n        throw new Error(`The glyphset \"${this.glyphset()}\" does not exist. Please provide a valid glyphset.`);\n      }\n      return glyphset.baseClass;\n    });\n    /**\n     * Define the font variation settings of the glyph\n     */\n    this.fontVariationSettings = computed(() => {\n      return `'FILL' ${this.fill() ? 1 : 0}, 'wght' ${this.weight()}, 'GRAD' ${this.grade()}, 'opsz' ${this.opticalSize()}`;\n    });\n  }\n  static {\n    this.ɵfac = function NgGlyph_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgGlyph)();\n    };\n  }\n  static {\n    this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgGlyph,\n      selectors: [[\"ng-glyph\"]],\n      hostVars: 9,\n      hostBindings: function NgGlyph_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"textContent\", ctx.name());\n          i0.ɵɵclassMap(ctx.glyphsetClass());\n          i0.ɵɵstyleProp(\"--ng-glyph__size\", ctx.size())(\"color\", ctx.color())(\"font-variation-settings\", ctx.fontVariationSettings());\n        }\n      },\n      inputs: {\n        name: [1, \"name\"],\n        glyphset: [1, \"glyphset\"],\n        opticalSize: [1, \"opticalSize\"],\n        weight: [1, \"weight\"],\n        grade: [1, \"grade\"],\n        fill: [1, \"fill\"],\n        size: [1, \"size\"],\n        color: [1, \"color\"]\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 0,\n      vars: 0,\n      template: function NgGlyph_Template(rf, ctx) {},\n      styles: [\"[_nghost-%COMP%]{display:inline-block;width:var(--ng-glyph__size);height:var(--ng-glyph__size);font-size:var(--ng-glyph__size);overflow:hidden}\"],\n      changeDetection: 0\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgGlyph, [{\n    type: Component,\n    args: [{\n      selector: 'ng-glyph',\n      standalone: true,\n      template: ``,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '[class]': 'glyphsetClass()',\n        '[textContent]': 'name()',\n        '[style.--ng-glyph__size]': 'size()',\n        '[style.color]': 'color()',\n        '[style.font-variation-settings]': 'fontVariationSettings()'\n      },\n      styles: [\":host{display:inline-block;width:var(--ng-glyph__size);height:var(--ng-glyph__size);font-size:var(--ng-glyph__size);overflow:hidden}\\n\"]\n    }]\n  }], null, null);\n})();\n\n/**\n * Helper function to create an object that represents a feature.\n */\nfunction createFeature(kind, providers) {\n  return {\n    ɵkind: kind,\n    ɵproviders: providers\n  };\n}\nconst NgIconPreProcessorToken = new InjectionToken('Ng Icon Pre Processor');\nconst NgIconPostProcessorToken = new InjectionToken('Ng Icon Post Processor');\nfunction injectNgIconPreProcessor() {\n  return inject(NgIconPreProcessorToken, {\n    optional: true\n  }) ?? (icon => icon);\n}\nfunction injectNgIconPostProcessor() {\n  return inject(NgIconPostProcessorToken, {\n    optional: true\n  }) ?? (() => {});\n}\nfunction preprocessIcon(icon) {\n  // rename all style attributes to data-style to avoid being blocked by the CSP\n  return icon.replace(/style\\s*=/g, 'data-style=');\n}\nfunction postprocessIcon(element) {\n  // find all elements with a data-style attribute and get the styles from it\n  // and apply them to the element using the style property and remove the data-style attribute\n  const elements = element.querySelectorAll('[data-style]');\n  for (const element of Array.from(elements)) {\n    const styles = element.getAttribute('data-style');\n    styles?.split(';').forEach(style => {\n      const [property, value] = style.split(':');\n      element.style[property.trim()] = value.trim();\n    });\n    element.removeAttribute('data-style');\n  }\n}\n/**\n * Process icons in a way that is compliant with the content security policy\n */\nfunction withContentSecurityPolicy() {\n  return createFeature(0 /* NgIconFeatureKind.ContentSecurityPolicyFeature */, [{\n    provide: NgIconPreProcessorToken,\n    useValue: preprocessIcon\n  }, {\n    provide: NgIconPostProcessorToken,\n    useValue: postprocessIcon\n  }]);\n}\nconst LoggerToken = new InjectionToken('Ng Icon Logger');\n/**\n * The default logger implementation that logs to the console\n */\nclass DefaultLogger {\n  log(message) {\n    console.log(message);\n  }\n  warn(message) {\n    console.warn(message);\n  }\n  error(message) {\n    console.error(message);\n  }\n}\n/**\n * A logger implementation that throws an error on warnings and errors\n */\nclass ExceptionLogger {\n  log(message) {\n    console.log(message);\n  }\n  warn(message) {\n    throw new Error(message);\n  }\n  error(message) {\n    throw new Error(message);\n  }\n}\nfunction injectLogger() {\n  return inject(LoggerToken, {\n    optional: true\n  }) ?? new DefaultLogger();\n}\n/**\n * Throw exceptions on warnings and errors\n */\nfunction withExceptionLogger() {\n  return createFeature(1 /* NgIconFeatureKind.ExceptionLoggerFeature */, [{\n    provide: LoggerToken,\n    useClass: ExceptionLogger\n  }]);\n}\nconst NgIconConfigToken = new InjectionToken('Ng Icon Config');\nconst defaultConfig = {\n  size: '1em'\n};\n/**\n * Provide the configuration for the icons\n * @param config The configuration to use\n */\nfunction provideNgIconsConfig(config, ...features) {\n  return [{\n    provide: NgIconConfigToken,\n    useValue: {\n      ...defaultConfig,\n      ...config\n    }\n  }, features.map(feature => feature.ɵproviders)];\n}\n/**\n * Inject the configuration for the icons\n * @returns The configuration to use\n * @internal\n */\nfunction injectNgIconConfig() {\n  return inject(NgIconConfigToken, {\n    optional: true\n  }) ?? defaultConfig;\n}\nconst NgIconLoaderToken = new InjectionToken('Ng Icon Loader Token');\n/**\n * Helper function to create an object that represents a Loader feature.\n */\nfunction loaderFeature(kind, providers) {\n  return {\n    kind: kind,\n    providers: providers\n  };\n}\nconst NgIconCacheToken = new InjectionToken('Ng Icon Cache Token');\n/**\n * Add caching to the loader. This will prevent the loader from being called multiple times for the same icon name.\n */\nfunction withCaching() {\n  return loaderFeature(0 /* NgIconLoaderFeatureKind.CachingFeature */, [{\n    provide: NgIconCacheToken,\n    useValue: new Map()\n  }]);\n}\n/**\n * Provide a function that will return the SVG content for a given icon name.\n * @param loader The function that will return the SVG content for a given icon name.\n * @param features The list of features to apply to the loader.\n * @returns The SVG content for a given icon name.\n */\nfunction provideNgIconLoader(loader, ...features) {\n  return [{\n    provide: NgIconLoaderToken,\n    useValue: loader\n  }, features.map(feature => feature.providers)];\n}\n/**\n * Inject the function that will return the SVG content for a given icon name.\n */\nfunction injectNgIconLoader() {\n  return inject(NgIconLoaderToken, {\n    optional: true\n  });\n}\n/**\n * Inject the cache that will store the SVG content for a given icon name.\n */\nfunction injectNgIconLoaderCache() {\n  return inject(NgIconCacheToken, {\n    optional: true\n  });\n}\n\n/**\n * Define the icons to use\n * @param icons The icons to provide\n */\nfunction provideIcons(icons) {\n  return [{\n    provide: NgIconsToken,\n    useFactory: (parentIcons = inject(NgIconsToken, {\n      optional: true,\n      skipSelf: true\n    })) => ({\n      ...parentIcons?.reduce((acc, icons) => ({\n        ...acc,\n        ...icons\n      }), {}),\n      ...icons\n    }),\n    multi: true\n  }];\n}\nconst NgIconsToken = new InjectionToken('Icons Token');\n/**\n * Inject the icons to use\n * @returns The icons to use\n * @internal\n */\nfunction injectNgIcons() {\n  return inject(NgIconsToken, {\n    optional: true\n  }) ?? [];\n}\n\n/**\n * A loader may return a promise, an observable or a string. This function will coerce the result into a promise.\n * @returns\n */\nfunction coerceLoaderResult(result) {\n  if (typeof result === 'string') {\n    return Promise.resolve(result);\n  }\n  if (isObservable(result)) {\n    // toPromise is deprecated, but we can't use lastValueFrom because it's not available in RxJS 6\n    // so for now we'll just use toPromise\n    return result.toPromise();\n  }\n  return result;\n}\n\n/**\n * Hyphenated to lowerCamelCase\n */\nfunction toPropertyName(str) {\n  return str.replace(/([^a-zA-Z0-9])+(.)?/g, (_, __, chr) => chr ? chr.toUpperCase() : '').replace(/[^a-zA-Z\\d]/g, '').replace(/^([A-Z])/, m => m.toLowerCase());\n}\nclass NgIcon {\n  constructor() {\n    /** Access the global icon config */\n    this.config = injectNgIconConfig();\n    /** Access the icons */\n    this.icons = injectNgIcons();\n    /** Access the icon loader if defined */\n    this.loader = injectNgIconLoader();\n    /** Access the icon cache if defined */\n    this.cache = injectNgIconLoaderCache();\n    /** Access the pre-processor */\n    this.preProcessor = injectNgIconPreProcessor();\n    /** Access the post-processor */\n    this.postProcessor = injectNgIconPostProcessor();\n    /** Access the injector */\n    this.injector = inject(Injector);\n    /** Access the renderer */\n    this.renderer = inject(Renderer2);\n    /** Determine the platform we are rendering on */\n    this.platform = inject(PLATFORM_ID);\n    /** Access the element ref */\n    this.elementRef = inject(ElementRef);\n    /** Access the logger */\n    this.logger = injectLogger();\n    /** Define the name of the icon to display */\n    this.name = input();\n    /** Define the svg of the icon to display */\n    this.svg = input();\n    /** Define the size of the icon */\n    this.size = input(this.config.size, {\n      transform: coerceCssPixelValue\n    });\n    /** Define the stroke-width of the icon */\n    this.strokeWidth = input(this.config.strokeWidth);\n    /** Define the color of the icon */\n    this.color = input(this.config.color);\n    // update the icon anytime the name or svg changes\n    effect(() => this.updateIcon());\n  }\n  ngOnDestroy() {\n    this.svgElement = undefined;\n  }\n  updateIcon() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const name = _this.name();\n      const svg = _this.svg();\n      // if the svg is defined, insert it into the template\n      if (svg !== undefined) {\n        _this.setSvg(svg);\n        return;\n      }\n      if (name === undefined) {\n        return;\n      }\n      const propertyName = toPropertyName(name);\n      for (const icons of [..._this.icons].reverse()) {\n        if (icons[propertyName]) {\n          // insert the SVG into the template\n          _this.setSvg(icons[propertyName]);\n          return;\n        }\n      }\n      // if there is a loader defined, use it to load the icon\n      if (_this.loader) {\n        const result = yield _this.requestIconFromLoader(name);\n        // if the result is a string, insert the SVG into the template\n        if (result !== null) {\n          _this.setSvg(result);\n          return;\n        }\n      }\n      // if there is no icon with this name warn the user as they probably forgot to import it\n      _this.logger.warn(`No icon named ${name} was found. You may need to import it using the withIcons function.`);\n    })();\n  }\n  setSvg(svg) {\n    // if we are on the server, simply innerHTML the svg as we don't have the\n    // level of control over the DOM that we do on the client, in otherwords\n    // the approach we take to insert the svg on the client will not work on the server\n    if (isPlatformServer(this.platform)) {\n      this.elementRef.nativeElement.innerHTML = svg;\n      // mark this component as server side rendered\n      this.elementRef.nativeElement.setAttribute('data-ng-icon-ssr', '');\n      return;\n    }\n    // if this was previously server side rendered, we should check if the svg is the same\n    // if it is, we don't need to do anything\n    if (this.elementRef.nativeElement.hasAttribute('data-ng-icon-ssr')) {\n      // if it is different, we need to remove the server side rendered flag\n      this.elementRef.nativeElement.removeAttribute('data-ng-icon-ssr');\n      // retrieve the svg element\n      this.svgElement = this.elementRef.nativeElement.querySelector('svg') ?? undefined;\n      if (this.elementRef.nativeElement.innerHTML === svg) {\n        return;\n      }\n    }\n    // remove the old element\n    if (this.svgElement) {\n      this.renderer.removeChild(this.elementRef.nativeElement, this.svgElement);\n    }\n    // if the svg is empty, don't insert anything\n    if (svg === '') {\n      return;\n    }\n    const template = this.renderer.createElement('template');\n    this.renderer.setProperty(template, 'innerHTML', this.preProcessor(svg));\n    this.svgElement = template.content.firstElementChild;\n    this.postProcessor(this.svgElement);\n    // insert the element into the dom\n    this.renderer.appendChild(this.elementRef.nativeElement, this.svgElement);\n  }\n  /**\n   * Request the icon from the loader.\n   * @param name The name of the icon to load.\n   * @returns The SVG content for a given icon name.\n   */\n  requestIconFromLoader(name) {\n    var _this2 = this;\n    return new Promise(resolve => {\n      runInInjectionContext(this.injector, /*#__PURE__*/_asyncToGenerator(function* () {\n        // if we have a cache, check if the icon is already loaded (i.e, it is a string)\n        if (_this2.cache) {\n          const cachedResult = _this2.cache.get(name);\n          if (typeof cachedResult === 'string') {\n            resolve(cachedResult);\n            return;\n          }\n          // it may be a promise, so we need to await it\n          if (cachedResult instanceof Promise) {\n            const result = yield cachedResult;\n            resolve(result);\n            return;\n          }\n        }\n        const promise = coerceLoaderResult(_this2.loader(name));\n        // store the promise in the cache so if we get repeated calls (e.g. in a loop) before the loader has resolved\n        // then don't call the loader function multiple times\n        _this2.cache?.set(name, promise);\n        // await the result of the promise\n        const result = yield promise;\n        // if we have a cache, store the result\n        _this2.cache?.set(name, result);\n        resolve(result);\n      }));\n    });\n  }\n  static {\n    this.ɵfac = function NgIcon_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgIcon)();\n    };\n  }\n  static {\n    this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgIcon,\n      selectors: [[\"ng-icon\"]],\n      hostVars: 6,\n      hostBindings: function NgIcon_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"--ng-icon__stroke-width\", ctx.strokeWidth())(\"--ng-icon__size\", ctx.size())(\"color\", ctx.color());\n        }\n      },\n      inputs: {\n        name: [1, \"name\"],\n        svg: [1, \"svg\"],\n        size: [1, \"size\"],\n        strokeWidth: [1, \"strokeWidth\"],\n        color: [1, \"color\"]\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 0,\n      vars: 0,\n      template: function NgIcon_Template(rf, ctx) {},\n      styles: [\"[_nghost-%COMP%]{display:inline-block;width:var(--ng-icon__size, 1em);height:var(--ng-icon__size, 1em);line-height:initial;vertical-align:initial;overflow:hidden}[_nghost-%COMP%]     svg{width:inherit;height:inherit;vertical-align:inherit}\"],\n      changeDetection: 0\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgIcon, [{\n    type: Component,\n    args: [{\n      selector: 'ng-icon',\n      template: '',\n      standalone: true,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '[style.--ng-icon__stroke-width]': 'strokeWidth()',\n        '[style.--ng-icon__size]': 'size()',\n        '[style.color]': 'color()'\n      },\n      styles: [\":host{display:inline-block;width:var(--ng-icon__size, 1em);height:var(--ng-icon__size, 1em);line-height:initial;vertical-align:initial;overflow:hidden}:host ::ng-deep svg{width:inherit;height:inherit;vertical-align:inherit}\\n\"]\n    }]\n  }], () => [], null);\n})();\nclass NgIconsModule {\n  constructor(icons) {\n    if (Object.keys(icons).length === 0) {\n      throw new Error('No icons have been provided. Ensure to include some icons by importing them using NgIconsModule.withIcons({ ... }).');\n    }\n  }\n  /**\n   * Define the icons that will be included in the application. This allows unused icons to\n   * be tree-shaken away to reduce bundle size\n   * @param icons The object containing the required icons\n   */\n  static withIcons(icons) {\n    return {\n      ngModule: NgIconsModule,\n      providers: provideIcons(icons)\n    };\n  }\n  static {\n    this.ɵfac = function NgIconsModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgIconsModule)(i0.ɵɵinject(NgIconsToken));\n    };\n  }\n  static {\n    this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgIconsModule,\n      imports: [NgIcon],\n      exports: [NgIcon]\n    });\n  }\n  static {\n    this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgIconsModule, [{\n    type: NgModule,\n    args: [{\n      imports: [NgIcon],\n      exports: [NgIcon]\n    }]\n  }], () => [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [NgIconsToken]\n    }]\n  }], null);\n})();\nconst NG_ICON_DIRECTIVES = [NgIcon];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NG_ICON_DIRECTIVES, NgGlyph, NgGlyphConfigToken, NgIcon, NgIconCacheToken, NgIcon as NgIconComponent, NgIconConfigToken, NgIconLoaderToken, NgIconsModule, NgIconsToken, injectNgGlyphsConfig, injectNgIconConfig, injectNgIconLoader, injectNgIconLoaderCache, injectNgIcons, provideIcons, provideNgGlyphs, provideNgGlyphsConfig, provideNgIconLoader, provideNgIconsConfig, withCaching, withContentSecurityPolicy, withExceptionLogger };\n//# sourceMappingURL=ng-icons-core.mjs.map","map":{"version":3,"names":["i0","InjectionToken","inject","makeEnvironmentProviders","input","numberAttribute","booleanAttribute","computed","Component","ChangeDetectionStrategy","Injector","Renderer2","PLATFORM_ID","ElementRef","effect","runInInjectionContext","NgModule","Inject","isPlatformServer","isObservable","NgGlyphConfigToken","defaultConfig$1","size","opticalSize","weight","grade","fill","provideNgGlyphsConfig","config","provide","useValue","injectNgGlyphsConfig","optional","NgGlyphsToken","provideNgGlyphs","glyphsets","length","Error","defaultGlyphset","name","injectNgGlyphs","glyphs","coerceCssPixelValue","value","test","NgGlyph","constructor","required","glyphset","transform","color","glyphsetClass","find","baseClass","fontVariationSettings","ɵfac","NgGlyph_Factory","__ngFactoryType__","ɵcmp","ɵɵdefineComponent","type","selectors","hostVars","hostBindings","NgGlyph_HostBindings","rf","ctx","ɵɵhostProperty","ɵɵclassMap","ɵɵstyleProp","inputs","standalone","features","ɵɵStandaloneFeature","decls","vars","template","NgGlyph_Template","styles","changeDetection","ngDevMode","ɵsetClassMetadata","args","selector","OnPush","host","createFeature","kind","providers","ɵkind","ɵproviders","NgIconPreProcessorToken","NgIconPostProcessorToken","injectNgIconPreProcessor","icon","injectNgIconPostProcessor","preprocessIcon","replace","postprocessIcon","element","elements","querySelectorAll","Array","from","getAttribute","split","forEach","style","property","trim","removeAttribute","withContentSecurityPolicy","LoggerToken","DefaultLogger","log","message","console","warn","error","ExceptionLogger","injectLogger","withExceptionLogger","useClass","NgIconConfigToken","defaultConfig","provideNgIconsConfig","map","feature","injectNgIconConfig","NgIconLoaderToken","loaderFeature","NgIconCacheToken","withCaching","Map","provideNgIconLoader","loader","injectNgIconLoader","injectNgIconLoaderCache","provideIcons","icons","NgIconsToken","useFactory","parentIcons","skipSelf","reduce","acc","multi","injectNgIcons","coerceLoaderResult","result","Promise","resolve","toPromise","toPropertyName","str","_","__","chr","toUpperCase","m","toLowerCase","NgIcon","cache","preProcessor","postProcessor","injector","renderer","platform","elementRef","logger","svg","strokeWidth","updateIcon","ngOnDestroy","svgElement","undefined","_this","_asyncToGenerator","setSvg","propertyName","reverse","requestIconFromLoader","nativeElement","innerHTML","setAttribute","hasAttribute","querySelector","removeChild","createElement","setProperty","content","firstElementChild","appendChild","_this2","cachedResult","get","promise","set","NgIcon_Factory","NgIcon_HostBindings","NgIcon_Template","NgIconsModule","Object","keys","withIcons","ngModule","NgIconsModule_Factory","ɵɵinject","ɵmod","ɵɵdefineNgModule","imports","exports","ɵinj","ɵɵdefineInjector","decorators","NG_ICON_DIRECTIVES","NgIconComponent"],"sources":["/Users/adbyrd/Documents/clients/elwood.berry/github/ideparture/ideparture/node_modules/@ng-icons/core/fesm2022/ng-icons-core.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, makeEnvironmentProviders, input, numberAttribute, booleanAttribute, computed, Component, ChangeDetectionStrategy, Injector, Renderer2, PLATFORM_ID, ElementRef, effect, runInInjectionContext, NgModule, Inject } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { isObservable } from 'rxjs';\n\nconst NgGlyphConfigToken = new InjectionToken('Ng Glyph Config');\nconst defaultConfig$1 = {\n    size: '1em',\n    opticalSize: 20,\n    weight: 400,\n    grade: 0,\n    fill: false,\n};\n/**\n * Provide the configuration for the glyph\n * @param config The configuration to use\n */\nfunction provideNgGlyphsConfig(config) {\n    return {\n        provide: NgGlyphConfigToken,\n        useValue: { ...defaultConfig$1, ...config },\n    };\n}\n/**\n * Inject the configuration for the glyphs\n * @returns The configuration to use\n * @internal\n */\nfunction injectNgGlyphsConfig() {\n    return (inject(NgGlyphConfigToken, { optional: true }) ??\n        defaultConfig$1);\n}\n\nconst NgGlyphsToken = new InjectionToken('NgGlyphsToken');\nfunction provideNgGlyphs(...glyphsets) {\n    // if there are no glyphsets, throw an error\n    if (!glyphsets.length) {\n        throw new Error('Please provide at least one glyphset.');\n    }\n    // the default glyphset is the first one\n    const defaultGlyphset = glyphsets[0].name;\n    return makeEnvironmentProviders([\n        { provide: NgGlyphsToken, useValue: { defaultGlyphset, glyphsets } },\n    ]);\n}\nfunction injectNgGlyphs() {\n    const glyphs = inject(NgGlyphsToken, { optional: true });\n    if (!glyphs) {\n        throw new Error('Please provide the glyphs using the provideNgGlyphs() function.');\n    }\n    return glyphs;\n}\n\nfunction coerceCssPixelValue(value) {\n    return value == null ? '' : /^\\d+$/.test(value) ? `${value}px` : value;\n}\n\nclass NgGlyph {\n    constructor() {\n        /**\n         * Access the available glyphsets\n         */\n        this.glyphsets = injectNgGlyphs();\n        /**\n         * Access the default configuration\n         */\n        this.config = injectNgGlyphsConfig();\n        /**\n         * Define the name of the glyph to display\n         */\n        this.name = input.required();\n        /**\n         * Define the glyphset to use\n         */\n        this.glyphset = input(this.glyphsets.defaultGlyphset);\n        /**\n         * Define the optical size of the glyph\n         */\n        this.opticalSize = input(this.config.opticalSize, {\n            transform: numberAttribute,\n        });\n        /**\n         * Define the weight of the glyph\n         */\n        this.weight = input(this.config.weight, { transform: numberAttribute });\n        /**\n         * Define the grade of the glyph\n         */\n        this.grade = input(this.config.grade, { transform: numberAttribute });\n        /**\n         * Define the fill of the glyph\n         */\n        this.fill = input(this.config.fill, { transform: booleanAttribute });\n        /**\n         * Define the size of the glyph\n         */\n        this.size = input(this.config.size, { transform: coerceCssPixelValue });\n        /**\n         * Define the color of the glyph\n         */\n        this.color = input(this.config.color);\n        /**\n         * Derive the glyphset class from the glyphset name\n         */\n        this.glyphsetClass = computed(() => {\n            const glyphset = this.glyphsets.glyphsets.find(glyphset => glyphset.name === this.glyphset());\n            if (!glyphset) {\n                throw new Error(`The glyphset \"${this.glyphset()}\" does not exist. Please provide a valid glyphset.`);\n            }\n            return glyphset.baseClass;\n        });\n        /**\n         * Define the font variation settings of the glyph\n         */\n        this.fontVariationSettings = computed(() => {\n            return `'FILL' ${this.fill() ? 1 : 0}, 'wght' ${this.weight()}, 'GRAD' ${this.grade()}, 'opsz' ${this.opticalSize()}`;\n        });\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0\", ngImport: i0, type: NgGlyph, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.1.0\", version: \"18.2.0\", type: NgGlyph, isStandalone: true, selector: \"ng-glyph\", inputs: { name: { classPropertyName: \"name\", publicName: \"name\", isSignal: true, isRequired: true, transformFunction: null }, glyphset: { classPropertyName: \"glyphset\", publicName: \"glyphset\", isSignal: true, isRequired: false, transformFunction: null }, opticalSize: { classPropertyName: \"opticalSize\", publicName: \"opticalSize\", isSignal: true, isRequired: false, transformFunction: null }, weight: { classPropertyName: \"weight\", publicName: \"weight\", isSignal: true, isRequired: false, transformFunction: null }, grade: { classPropertyName: \"grade\", publicName: \"grade\", isSignal: true, isRequired: false, transformFunction: null }, fill: { classPropertyName: \"fill\", publicName: \"fill\", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: \"size\", publicName: \"size\", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: \"color\", publicName: \"color\", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { \"class\": \"glyphsetClass()\", \"textContent\": \"name()\", \"style.--ng-glyph__size\": \"size()\", \"style.color\": \"color()\", \"style.font-variation-settings\": \"fontVariationSettings()\" } }, ngImport: i0, template: ``, isInline: true, styles: [\":host{display:inline-block;width:var(--ng-glyph__size);height:var(--ng-glyph__size);font-size:var(--ng-glyph__size);overflow:hidden}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0\", ngImport: i0, type: NgGlyph, decorators: [{\n            type: Component,\n            args: [{ selector: 'ng-glyph', standalone: true, template: ``, changeDetection: ChangeDetectionStrategy.OnPush, host: {\n                        '[class]': 'glyphsetClass()',\n                        '[textContent]': 'name()',\n                        '[style.--ng-glyph__size]': 'size()',\n                        '[style.color]': 'color()',\n                        '[style.font-variation-settings]': 'fontVariationSettings()',\n                    }, styles: [\":host{display:inline-block;width:var(--ng-glyph__size);height:var(--ng-glyph__size);font-size:var(--ng-glyph__size);overflow:hidden}\\n\"] }]\n        }] });\n\n/**\n * Helper function to create an object that represents a feature.\n */\nfunction createFeature(kind, providers) {\n    return { ɵkind: kind, ɵproviders: providers };\n}\n\nconst NgIconPreProcessorToken = new InjectionToken('Ng Icon Pre Processor');\nconst NgIconPostProcessorToken = new InjectionToken('Ng Icon Post Processor');\nfunction injectNgIconPreProcessor() {\n    return inject(NgIconPreProcessorToken, { optional: true }) ?? (icon => icon);\n}\nfunction injectNgIconPostProcessor() {\n    return inject(NgIconPostProcessorToken, { optional: true }) ?? (() => { });\n}\nfunction preprocessIcon(icon) {\n    // rename all style attributes to data-style to avoid being blocked by the CSP\n    return icon.replace(/style\\s*=/g, 'data-style=');\n}\nfunction postprocessIcon(element) {\n    // find all elements with a data-style attribute and get the styles from it\n    // and apply them to the element using the style property and remove the data-style attribute\n    const elements = element.querySelectorAll('[data-style]');\n    for (const element of Array.from(elements)) {\n        const styles = element.getAttribute('data-style');\n        styles?.split(';').forEach(style => {\n            const [property, value] = style.split(':');\n            element.style[property.trim()] = value.trim();\n        });\n        element.removeAttribute('data-style');\n    }\n}\n/**\n * Process icons in a way that is compliant with the content security policy\n */\nfunction withContentSecurityPolicy() {\n    return createFeature(0 /* NgIconFeatureKind.ContentSecurityPolicyFeature */, [\n        { provide: NgIconPreProcessorToken, useValue: preprocessIcon },\n        { provide: NgIconPostProcessorToken, useValue: postprocessIcon },\n    ]);\n}\n\nconst LoggerToken = new InjectionToken('Ng Icon Logger');\n/**\n * The default logger implementation that logs to the console\n */\nclass DefaultLogger {\n    log(message) {\n        console.log(message);\n    }\n    warn(message) {\n        console.warn(message);\n    }\n    error(message) {\n        console.error(message);\n    }\n}\n/**\n * A logger implementation that throws an error on warnings and errors\n */\nclass ExceptionLogger {\n    log(message) {\n        console.log(message);\n    }\n    warn(message) {\n        throw new Error(message);\n    }\n    error(message) {\n        throw new Error(message);\n    }\n}\nfunction injectLogger() {\n    return inject(LoggerToken, { optional: true }) ?? new DefaultLogger();\n}\n/**\n * Throw exceptions on warnings and errors\n */\nfunction withExceptionLogger() {\n    return createFeature(1 /* NgIconFeatureKind.ExceptionLoggerFeature */, [\n        { provide: LoggerToken, useClass: ExceptionLogger },\n    ]);\n}\n\nconst NgIconConfigToken = new InjectionToken('Ng Icon Config');\nconst defaultConfig = {\n    size: '1em',\n};\n/**\n * Provide the configuration for the icons\n * @param config The configuration to use\n */\nfunction provideNgIconsConfig(config, ...features) {\n    return [\n        {\n            provide: NgIconConfigToken,\n            useValue: { ...defaultConfig, ...config },\n        },\n        features.map(feature => feature.ɵproviders),\n    ];\n}\n/**\n * Inject the configuration for the icons\n * @returns The configuration to use\n * @internal\n */\nfunction injectNgIconConfig() {\n    return inject(NgIconConfigToken, { optional: true }) ?? defaultConfig;\n}\n\nconst NgIconLoaderToken = new InjectionToken('Ng Icon Loader Token');\n/**\n * Helper function to create an object that represents a Loader feature.\n */\nfunction loaderFeature(kind, providers) {\n    return { kind: kind, providers: providers };\n}\nconst NgIconCacheToken = new InjectionToken('Ng Icon Cache Token');\n/**\n * Add caching to the loader. This will prevent the loader from being called multiple times for the same icon name.\n */\nfunction withCaching() {\n    return loaderFeature(0 /* NgIconLoaderFeatureKind.CachingFeature */, [\n        { provide: NgIconCacheToken, useValue: new Map() },\n    ]);\n}\n/**\n * Provide a function that will return the SVG content for a given icon name.\n * @param loader The function that will return the SVG content for a given icon name.\n * @param features The list of features to apply to the loader.\n * @returns The SVG content for a given icon name.\n */\nfunction provideNgIconLoader(loader, ...features) {\n    return [\n        { provide: NgIconLoaderToken, useValue: loader },\n        features.map(feature => feature.providers),\n    ];\n}\n/**\n * Inject the function that will return the SVG content for a given icon name.\n */\nfunction injectNgIconLoader() {\n    return inject(NgIconLoaderToken, { optional: true });\n}\n/**\n * Inject the cache that will store the SVG content for a given icon name.\n */\nfunction injectNgIconLoaderCache() {\n    return inject(NgIconCacheToken, { optional: true });\n}\n\n/**\n * Define the icons to use\n * @param icons The icons to provide\n */\nfunction provideIcons(icons) {\n    return [\n        {\n            provide: NgIconsToken,\n            useFactory: (parentIcons = inject(NgIconsToken, {\n                optional: true,\n                skipSelf: true,\n            })) => ({\n                ...parentIcons?.reduce((acc, icons) => ({ ...acc, ...icons }), {}),\n                ...icons,\n            }),\n            multi: true,\n        },\n    ];\n}\nconst NgIconsToken = new InjectionToken('Icons Token');\n/**\n * Inject the icons to use\n * @returns The icons to use\n * @internal\n */\nfunction injectNgIcons() {\n    return inject(NgIconsToken, { optional: true }) ?? [];\n}\n\n/**\n * A loader may return a promise, an observable or a string. This function will coerce the result into a promise.\n * @returns\n */\nfunction coerceLoaderResult(result) {\n    if (typeof result === 'string') {\n        return Promise.resolve(result);\n    }\n    if (isObservable(result)) {\n        // toPromise is deprecated, but we can't use lastValueFrom because it's not available in RxJS 6\n        // so for now we'll just use toPromise\n        return result.toPromise();\n    }\n    return result;\n}\n\n/**\n * Hyphenated to lowerCamelCase\n */\nfunction toPropertyName(str) {\n    return str\n        .replace(/([^a-zA-Z0-9])+(.)?/g, (_, __, chr) => chr ? chr.toUpperCase() : '')\n        .replace(/[^a-zA-Z\\d]/g, '')\n        .replace(/^([A-Z])/, m => m.toLowerCase());\n}\n\nclass NgIcon {\n    constructor() {\n        /** Access the global icon config */\n        this.config = injectNgIconConfig();\n        /** Access the icons */\n        this.icons = injectNgIcons();\n        /** Access the icon loader if defined */\n        this.loader = injectNgIconLoader();\n        /** Access the icon cache if defined */\n        this.cache = injectNgIconLoaderCache();\n        /** Access the pre-processor */\n        this.preProcessor = injectNgIconPreProcessor();\n        /** Access the post-processor */\n        this.postProcessor = injectNgIconPostProcessor();\n        /** Access the injector */\n        this.injector = inject(Injector);\n        /** Access the renderer */\n        this.renderer = inject(Renderer2);\n        /** Determine the platform we are rendering on */\n        this.platform = inject(PLATFORM_ID);\n        /** Access the element ref */\n        this.elementRef = inject(ElementRef);\n        /** Access the logger */\n        this.logger = injectLogger();\n        /** Define the name of the icon to display */\n        this.name = input();\n        /** Define the svg of the icon to display */\n        this.svg = input();\n        /** Define the size of the icon */\n        this.size = input(this.config.size, { transform: coerceCssPixelValue });\n        /** Define the stroke-width of the icon */\n        this.strokeWidth = input(this.config.strokeWidth);\n        /** Define the color of the icon */\n        this.color = input(this.config.color);\n        // update the icon anytime the name or svg changes\n        effect(() => this.updateIcon());\n    }\n    ngOnDestroy() {\n        this.svgElement = undefined;\n    }\n    async updateIcon() {\n        const name = this.name();\n        const svg = this.svg();\n        // if the svg is defined, insert it into the template\n        if (svg !== undefined) {\n            this.setSvg(svg);\n            return;\n        }\n        if (name === undefined) {\n            return;\n        }\n        const propertyName = toPropertyName(name);\n        for (const icons of [...this.icons].reverse()) {\n            if (icons[propertyName]) {\n                // insert the SVG into the template\n                this.setSvg(icons[propertyName]);\n                return;\n            }\n        }\n        // if there is a loader defined, use it to load the icon\n        if (this.loader) {\n            const result = await this.requestIconFromLoader(name);\n            // if the result is a string, insert the SVG into the template\n            if (result !== null) {\n                this.setSvg(result);\n                return;\n            }\n        }\n        // if there is no icon with this name warn the user as they probably forgot to import it\n        this.logger.warn(`No icon named ${name} was found. You may need to import it using the withIcons function.`);\n    }\n    setSvg(svg) {\n        // if we are on the server, simply innerHTML the svg as we don't have the\n        // level of control over the DOM that we do on the client, in otherwords\n        // the approach we take to insert the svg on the client will not work on the server\n        if (isPlatformServer(this.platform)) {\n            this.elementRef.nativeElement.innerHTML = svg;\n            // mark this component as server side rendered\n            this.elementRef.nativeElement.setAttribute('data-ng-icon-ssr', '');\n            return;\n        }\n        // if this was previously server side rendered, we should check if the svg is the same\n        // if it is, we don't need to do anything\n        if (this.elementRef.nativeElement.hasAttribute('data-ng-icon-ssr')) {\n            // if it is different, we need to remove the server side rendered flag\n            this.elementRef.nativeElement.removeAttribute('data-ng-icon-ssr');\n            // retrieve the svg element\n            this.svgElement =\n                this.elementRef.nativeElement.querySelector('svg') ??\n                    undefined;\n            if (this.elementRef.nativeElement.innerHTML === svg) {\n                return;\n            }\n        }\n        // remove the old element\n        if (this.svgElement) {\n            this.renderer.removeChild(this.elementRef.nativeElement, this.svgElement);\n        }\n        // if the svg is empty, don't insert anything\n        if (svg === '') {\n            return;\n        }\n        const template = this.renderer.createElement('template');\n        this.renderer.setProperty(template, 'innerHTML', this.preProcessor(svg));\n        this.svgElement = template.content.firstElementChild;\n        this.postProcessor(this.svgElement);\n        // insert the element into the dom\n        this.renderer.appendChild(this.elementRef.nativeElement, this.svgElement);\n    }\n    /**\n     * Request the icon from the loader.\n     * @param name The name of the icon to load.\n     * @returns The SVG content for a given icon name.\n     */\n    requestIconFromLoader(name) {\n        return new Promise(resolve => {\n            runInInjectionContext(this.injector, async () => {\n                // if we have a cache, check if the icon is already loaded (i.e, it is a string)\n                if (this.cache) {\n                    const cachedResult = this.cache.get(name);\n                    if (typeof cachedResult === 'string') {\n                        resolve(cachedResult);\n                        return;\n                    }\n                    // it may be a promise, so we need to await it\n                    if (cachedResult instanceof Promise) {\n                        const result = await cachedResult;\n                        resolve(result);\n                        return;\n                    }\n                }\n                const promise = coerceLoaderResult(this.loader(name));\n                // store the promise in the cache so if we get repeated calls (e.g. in a loop) before the loader has resolved\n                // then don't call the loader function multiple times\n                this.cache?.set(name, promise);\n                // await the result of the promise\n                const result = await promise;\n                // if we have a cache, store the result\n                this.cache?.set(name, result);\n                resolve(result);\n            });\n        });\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0\", ngImport: i0, type: NgIcon, deps: [], target: i0.ɵɵFactoryTarget.Component }); }\n    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"17.1.0\", version: \"18.2.0\", type: NgIcon, isStandalone: true, selector: \"ng-icon\", inputs: { name: { classPropertyName: \"name\", publicName: \"name\", isSignal: true, isRequired: false, transformFunction: null }, svg: { classPropertyName: \"svg\", publicName: \"svg\", isSignal: true, isRequired: false, transformFunction: null }, size: { classPropertyName: \"size\", publicName: \"size\", isSignal: true, isRequired: false, transformFunction: null }, strokeWidth: { classPropertyName: \"strokeWidth\", publicName: \"strokeWidth\", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: \"color\", publicName: \"color\", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { \"style.--ng-icon__stroke-width\": \"strokeWidth()\", \"style.--ng-icon__size\": \"size()\", \"style.color\": \"color()\" } }, ngImport: i0, template: '', isInline: true, styles: [\":host{display:inline-block;width:var(--ng-icon__size, 1em);height:var(--ng-icon__size, 1em);line-height:initial;vertical-align:initial;overflow:hidden}:host ::ng-deep svg{width:inherit;height:inherit;vertical-align:inherit}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0\", ngImport: i0, type: NgIcon, decorators: [{\n            type: Component,\n            args: [{ selector: 'ng-icon', template: '', standalone: true, changeDetection: ChangeDetectionStrategy.OnPush, host: {\n                        '[style.--ng-icon__stroke-width]': 'strokeWidth()',\n                        '[style.--ng-icon__size]': 'size()',\n                        '[style.color]': 'color()',\n                    }, styles: [\":host{display:inline-block;width:var(--ng-icon__size, 1em);height:var(--ng-icon__size, 1em);line-height:initial;vertical-align:initial;overflow:hidden}:host ::ng-deep svg{width:inherit;height:inherit;vertical-align:inherit}\\n\"] }]\n        }], ctorParameters: () => [] });\n\nclass NgIconsModule {\n    constructor(icons) {\n        if (Object.keys(icons).length === 0) {\n            throw new Error('No icons have been provided. Ensure to include some icons by importing them using NgIconsModule.withIcons({ ... }).');\n        }\n    }\n    /**\n     * Define the icons that will be included in the application. This allows unused icons to\n     * be tree-shaken away to reduce bundle size\n     * @param icons The object containing the required icons\n     */\n    static withIcons(icons) {\n        return { ngModule: NgIconsModule, providers: provideIcons(icons) };\n    }\n    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"18.2.0\", ngImport: i0, type: NgIconsModule, deps: [{ token: NgIconsToken }], target: i0.ɵɵFactoryTarget.NgModule }); }\n    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"18.2.0\", ngImport: i0, type: NgIconsModule, imports: [NgIcon], exports: [NgIcon] }); }\n    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"18.2.0\", ngImport: i0, type: NgIconsModule }); }\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"18.2.0\", ngImport: i0, type: NgIconsModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [NgIcon],\n                    exports: [NgIcon],\n                }]\n        }], ctorParameters: () => [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NgIconsToken]\n                }] }] });\nconst NG_ICON_DIRECTIVES = [NgIcon];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NG_ICON_DIRECTIVES, NgGlyph, NgGlyphConfigToken, NgIcon, NgIconCacheToken, NgIcon as NgIconComponent, NgIconConfigToken, NgIconLoaderToken, NgIconsModule, NgIconsToken, injectNgGlyphsConfig, injectNgIconConfig, injectNgIconLoader, injectNgIconLoaderCache, injectNgIcons, provideIcons, provideNgGlyphs, provideNgGlyphsConfig, provideNgIconLoader, provideNgIconsConfig, withCaching, withContentSecurityPolicy, withExceptionLogger };\n//# sourceMappingURL=ng-icons-core.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}