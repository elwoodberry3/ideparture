{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function tokenToString(token) {\n    if (token.text !== undefined && token.text !== '') {\n      return `'${token.type}' with value '${token.text}'`;\n    } else {\n      return `'${token.type}'`;\n    }\n  }\n  class NoParsletFoundError extends Error {\n    constructor(token) {\n      super(`No parslet found for token: ${tokenToString(token)}`);\n      this.token = token;\n      Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n    }\n    getToken() {\n      return this.token;\n    }\n  }\n  class EarlyEndOfParseError extends Error {\n    constructor(token) {\n      super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n      this.token = token;\n      Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n    }\n    getToken() {\n      return this.token;\n    }\n  }\n  class UnexpectedTypeError extends Error {\n    constructor(result, message) {\n      let error = `Unexpected type: '${result.type}'.`;\n      if (message !== undefined) {\n        error += ` Message: ${message}`;\n      }\n      super(error);\n      Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n    }\n  }\n  // export class UnexpectedTokenError extends Error {\n  //   private expected: Token\n  //   private found: Token\n  //\n  //   constructor (expected: Token, found: Token) {\n  //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n  //\n  //     this.token = token\n  //\n  //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n  //   }\n  //\n  //   getToken() {\n  //     return this.token\n  //   }\n  // }\n\n  function makePunctuationRule(type) {\n    return text => {\n      if (text.startsWith(type)) {\n        return {\n          type,\n          text: type\n        };\n      } else {\n        return null;\n      }\n    };\n  }\n  function getQuoted(text) {\n    let position = 0;\n    let char;\n    const mark = text[0];\n    let escaped = false;\n    if (mark !== '\\'' && mark !== '\"') {\n      return null;\n    }\n    while (position < text.length) {\n      position++;\n      char = text[position];\n      if (!escaped && char === mark) {\n        position++;\n        break;\n      }\n      escaped = !escaped && char === '\\\\';\n    }\n    if (char !== mark) {\n      throw new Error('Unterminated String');\n    }\n    return text.slice(0, position);\n  }\n  const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n  // A hyphen is not technically allowed, but to keep it liberal for now,\n  //  adding it here\n  const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n  function getIdentifier(text) {\n    let char = text[0];\n    if (!identifierStartRegex.test(char)) {\n      return null;\n    }\n    let position = 1;\n    do {\n      char = text[position];\n      if (!identifierContinueRegex.test(char)) {\n        break;\n      }\n      position++;\n    } while (position < text.length);\n    return text.slice(0, position);\n  }\n  // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n  const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n  function getNumber(text) {\n    var _a, _b;\n    return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n  }\n  const identifierRule = text => {\n    const value = getIdentifier(text);\n    if (value == null) {\n      return null;\n    }\n    return {\n      type: 'Identifier',\n      text: value\n    };\n  };\n  function makeKeyWordRule(type) {\n    return text => {\n      if (!text.startsWith(type)) {\n        return null;\n      }\n      const prepends = text[type.length];\n      if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n        return null;\n      }\n      return {\n        type,\n        text: type\n      };\n    };\n  }\n  const stringValueRule = text => {\n    const value = getQuoted(text);\n    if (value == null) {\n      return null;\n    }\n    return {\n      type: 'StringValue',\n      text: value\n    };\n  };\n  const eofRule = text => {\n    if (text.length > 0) {\n      return null;\n    }\n    return {\n      type: 'EOF',\n      text: ''\n    };\n  };\n  const numberRule = text => {\n    const value = getNumber(text);\n    if (value === null) {\n      return null;\n    }\n    return {\n      type: 'Number',\n      text: value\n    };\n  };\n  const rules = [eofRule, makePunctuationRule('=>'), makePunctuationRule('('), makePunctuationRule(')'), makePunctuationRule('{'), makePunctuationRule('}'), makePunctuationRule('['), makePunctuationRule(']'), makePunctuationRule('|'), makePunctuationRule('&'), makePunctuationRule('<'), makePunctuationRule('>'), makePunctuationRule(','), makePunctuationRule(';'), makePunctuationRule('*'), makePunctuationRule('?'), makePunctuationRule('!'), makePunctuationRule('='), makePunctuationRule(':'), makePunctuationRule('...'), makePunctuationRule('.'), makePunctuationRule('#'), makePunctuationRule('~'), makePunctuationRule('/'), makePunctuationRule('@'), makeKeyWordRule('undefined'), makeKeyWordRule('null'), makeKeyWordRule('function'), makeKeyWordRule('this'), makeKeyWordRule('new'), makeKeyWordRule('module'), makeKeyWordRule('event'), makeKeyWordRule('external'), makeKeyWordRule('typeof'), makeKeyWordRule('keyof'), makeKeyWordRule('readonly'), makeKeyWordRule('import'), makeKeyWordRule('is'), makeKeyWordRule('in'), makeKeyWordRule('asserts'), numberRule, identifierRule, stringValueRule];\n  const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n  class Lexer {\n    static create(text) {\n      const current = this.read(text);\n      text = current.text;\n      const next = this.read(text);\n      text = next.text;\n      return new Lexer(text, undefined, current.token, next.token);\n    }\n    constructor(text, previous, current, next) {\n      this.text = '';\n      this.text = text;\n      this.previous = previous;\n      this.current = current;\n      this.next = next;\n    }\n    static read(text, startOfLine = false) {\n      startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n      text = text.trim();\n      for (const rule of rules) {\n        const partial = rule(text);\n        if (partial !== null) {\n          const token = Object.assign(Object.assign({}, partial), {\n            startOfLine\n          });\n          text = text.slice(token.text.length);\n          return {\n            text,\n            token\n          };\n        }\n      }\n      throw new Error('Unexpected Token ' + text);\n    }\n    advance() {\n      const next = Lexer.read(this.text);\n      return new Lexer(next.text, this.current, this.next, next.token);\n    }\n  }\n\n  /**\n   * Throws an error if the provided result is not a {@link RootResult}\n   */\n  function assertRootResult(result) {\n    if (result === undefined) {\n      throw new Error('Unexpected undefined');\n    }\n    if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' || result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' || result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' || result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function assertPlainKeyValueOrRootResult(result) {\n    if (result.type === 'JsdocTypeKeyValue') {\n      return assertPlainKeyValueResult(result);\n    }\n    return assertRootResult(result);\n  }\n  function assertPlainKeyValueOrNameResult(result) {\n    if (result.type === 'JsdocTypeName') {\n      return result;\n    }\n    return assertPlainKeyValueResult(result);\n  }\n  function assertPlainKeyValueResult(result) {\n    if (result.type !== 'JsdocTypeKeyValue') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function assertNumberOrVariadicNameResult(result) {\n    var _a;\n    if (result.type === 'JsdocTypeVariadic') {\n      if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n        return result;\n      }\n      throw new UnexpectedTypeError(result);\n    }\n    if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n      throw new UnexpectedTypeError(result);\n    }\n    return result;\n  }\n  function isSquaredProperty(result) {\n    return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n  }\n\n  // higher precedence = higher importance\n  var Precedence;\n  (function (Precedence) {\n    Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n    Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n    Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n    Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n    Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n    Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n    Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n    Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n    Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n    Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n    Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n    Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n    Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n    Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n    Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n    Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n    Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n    Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n    Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n    Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n    Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n  })(Precedence || (Precedence = {}));\n  class Parser {\n    constructor(grammar, textOrLexer, baseParser) {\n      this.grammar = grammar;\n      if (typeof textOrLexer === 'string') {\n        this._lexer = Lexer.create(textOrLexer);\n      } else {\n        this._lexer = textOrLexer;\n      }\n      this.baseParser = baseParser;\n    }\n    get lexer() {\n      return this._lexer;\n    }\n    /**\n     * Parses a given string and throws an error if the parse ended before the end of the string.\n     */\n    parse() {\n      const result = this.parseType(Precedence.ALL);\n      if (this.lexer.current.type !== 'EOF') {\n        throw new EarlyEndOfParseError(this.lexer.current);\n      }\n      return result;\n    }\n    /**\n     * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n     */\n    parseType(precedence) {\n      return assertRootResult(this.parseIntermediateType(precedence));\n    }\n    /**\n     * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n     * to parse the state in the infix step.\n     */\n    parseIntermediateType(precedence) {\n      const result = this.tryParslets(null, precedence);\n      if (result === null) {\n        throw new NoParsletFoundError(this.lexer.current);\n      }\n      return this.parseInfixIntermediateType(result, precedence);\n    }\n    /**\n     * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n     * a result.\n     */\n    parseInfixIntermediateType(left, precedence) {\n      let result = this.tryParslets(left, precedence);\n      while (result !== null) {\n        left = result;\n        result = this.tryParslets(left, precedence);\n      }\n      return left;\n    }\n    /**\n     * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n     */\n    tryParslets(left, precedence) {\n      for (const parslet of this.grammar) {\n        const result = parslet(this, precedence, left);\n        if (result !== null) {\n          return result;\n        }\n      }\n      return null;\n    }\n    /**\n     * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n     * advanced.\n     */\n    consume(types) {\n      if (!Array.isArray(types)) {\n        types = [types];\n      }\n      if (types.includes(this.lexer.current.type)) {\n        this._lexer = this.lexer.advance();\n        return true;\n      } else {\n        return false;\n      }\n    }\n    acceptLexerState(parser) {\n      this._lexer = parser.lexer;\n    }\n  }\n  function isQuestionMarkUnknownType(next) {\n    return next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n  }\n  const nullableParslet = (parser, precedence, left) => {\n    const type = parser.lexer.current.type;\n    const next = parser.lexer.next.type;\n    const accept = left == null && type === '?' && !isQuestionMarkUnknownType(next) || left != null && type === '?';\n    if (!accept) {\n      return null;\n    }\n    parser.consume('?');\n    if (left == null) {\n      return {\n        type: 'JsdocTypeNullable',\n        element: parser.parseType(Precedence.NULLABLE),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    } else {\n      return {\n        type: 'JsdocTypeNullable',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  };\n  function composeParslet(options) {\n    const parslet = (parser, curPrecedence, left) => {\n      const type = parser.lexer.current.type;\n      const next = parser.lexer.next.type;\n      if (left === null) {\n        if ('parsePrefix' in options) {\n          if (options.accept(type, next)) {\n            return options.parsePrefix(parser);\n          }\n        }\n      } else {\n        if ('parseInfix' in options) {\n          if (options.precedence > curPrecedence && options.accept(type, next)) {\n            return options.parseInfix(parser, left);\n          }\n        }\n      }\n      return null;\n    };\n    // for debugging\n    Object.defineProperty(parslet, 'name', {\n      value: options.name\n    });\n    return parslet;\n  }\n  const optionalParslet = composeParslet({\n    name: 'optionalParslet',\n    accept: type => type === '=',\n    precedence: Precedence.OPTIONAL,\n    parsePrefix: parser => {\n      parser.consume('=');\n      return {\n        type: 'JsdocTypeOptional',\n        element: parser.parseType(Precedence.OPTIONAL),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    },\n    parseInfix: (parser, left) => {\n      parser.consume('=');\n      return {\n        type: 'JsdocTypeOptional',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  });\n  const numberParslet = composeParslet({\n    name: 'numberParslet',\n    accept: type => type === 'Number',\n    parsePrefix: parser => {\n      const value = parseFloat(parser.lexer.current.text);\n      parser.consume('Number');\n      return {\n        type: 'JsdocTypeNumber',\n        value\n      };\n    }\n  });\n  const parenthesisParslet = composeParslet({\n    name: 'parenthesisParslet',\n    accept: type => type === '(',\n    parsePrefix: parser => {\n      parser.consume('(');\n      if (parser.consume(')')) {\n        return {\n          type: 'JsdocTypeParameterList',\n          elements: []\n        };\n      }\n      const result = parser.parseIntermediateType(Precedence.ALL);\n      if (!parser.consume(')')) {\n        throw new Error('Unterminated parenthesis');\n      }\n      if (result.type === 'JsdocTypeParameterList') {\n        return result;\n      } else if (result.type === 'JsdocTypeKeyValue') {\n        return {\n          type: 'JsdocTypeParameterList',\n          elements: [result]\n        };\n      }\n      return {\n        type: 'JsdocTypeParenthesis',\n        element: assertRootResult(result)\n      };\n    }\n  });\n  const specialTypesParslet = composeParslet({\n    name: 'specialTypesParslet',\n    accept: (type, next) => type === '?' && isQuestionMarkUnknownType(next) || type === 'null' || type === 'undefined' || type === '*',\n    parsePrefix: parser => {\n      if (parser.consume('null')) {\n        return {\n          type: 'JsdocTypeNull'\n        };\n      }\n      if (parser.consume('undefined')) {\n        return {\n          type: 'JsdocTypeUndefined'\n        };\n      }\n      if (parser.consume('*')) {\n        return {\n          type: 'JsdocTypeAny'\n        };\n      }\n      if (parser.consume('?')) {\n        return {\n          type: 'JsdocTypeUnknown'\n        };\n      }\n      throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n    }\n  });\n  const notNullableParslet = composeParslet({\n    name: 'notNullableParslet',\n    accept: type => type === '!',\n    precedence: Precedence.NULLABLE,\n    parsePrefix: parser => {\n      parser.consume('!');\n      return {\n        type: 'JsdocTypeNotNullable',\n        element: parser.parseType(Precedence.NULLABLE),\n        meta: {\n          position: 'prefix'\n        }\n      };\n    },\n    parseInfix: (parser, left) => {\n      parser.consume('!');\n      return {\n        type: 'JsdocTypeNotNullable',\n        element: assertRootResult(left),\n        meta: {\n          position: 'suffix'\n        }\n      };\n    }\n  });\n  function createParameterListParslet({\n    allowTrailingComma\n  }) {\n    return composeParslet({\n      name: 'parameterListParslet',\n      accept: type => type === ',',\n      precedence: Precedence.PARAMETER_LIST,\n      parseInfix: (parser, left) => {\n        const elements = [assertPlainKeyValueOrRootResult(left)];\n        parser.consume(',');\n        do {\n          try {\n            const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n            elements.push(assertPlainKeyValueOrRootResult(next));\n          } catch (e) {\n            if (allowTrailingComma && e instanceof NoParsletFoundError) {\n              break;\n            } else {\n              throw e;\n            }\n          }\n        } while (parser.consume(','));\n        if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n          throw new Error('Only the last parameter may be a rest parameter');\n        }\n        return {\n          type: 'JsdocTypeParameterList',\n          elements\n        };\n      }\n    });\n  }\n  const genericParslet = composeParslet({\n    name: 'genericParslet',\n    accept: (type, next) => type === '<' || type === '.' && next === '<',\n    precedence: Precedence.GENERIC,\n    parseInfix: (parser, left) => {\n      const dot = parser.consume('.');\n      parser.consume('<');\n      const objects = [];\n      do {\n        objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n      } while (parser.consume(','));\n      if (!parser.consume('>')) {\n        throw new Error('Unterminated generic parameter list');\n      }\n      return {\n        type: 'JsdocTypeGeneric',\n        left: assertRootResult(left),\n        elements: objects,\n        meta: {\n          brackets: 'angle',\n          dot\n        }\n      };\n    }\n  });\n  const unionParslet = composeParslet({\n    name: 'unionParslet',\n    accept: type => type === '|',\n    precedence: Precedence.UNION,\n    parseInfix: (parser, left) => {\n      parser.consume('|');\n      const elements = [];\n      do {\n        elements.push(parser.parseType(Precedence.UNION));\n      } while (parser.consume('|'));\n      return {\n        type: 'JsdocTypeUnion',\n        elements: [assertRootResult(left), ...elements]\n      };\n    }\n  });\n  const baseGrammar = [nullableParslet, optionalParslet, numberParslet, parenthesisParslet, specialTypesParslet, notNullableParslet, createParameterListParslet({\n    allowTrailingComma: true\n  }), genericParslet, unionParslet, optionalParslet];\n  function createNamePathParslet({\n    allowSquareBracketsOnAnyType,\n    allowJsdocNamePaths,\n    pathGrammar\n  }) {\n    return function namePathParslet(parser, precedence, left) {\n      if (left == null || precedence >= Precedence.NAME_PATH) {\n        return null;\n      }\n      const type = parser.lexer.current.type;\n      const next = parser.lexer.next.type;\n      const accept = type === '.' && next !== '<' || type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName') || allowJsdocNamePaths && (type === '~' || type === '#');\n      if (!accept) {\n        return null;\n      }\n      let pathType;\n      let brackets = false;\n      if (parser.consume('.')) {\n        pathType = 'property';\n      } else if (parser.consume('[')) {\n        pathType = 'property-brackets';\n        brackets = true;\n      } else if (parser.consume('~')) {\n        pathType = 'inner';\n      } else {\n        parser.consume('#');\n        pathType = 'instance';\n      }\n      const pathParser = pathGrammar !== null ? new Parser(pathGrammar, parser.lexer, parser) : parser;\n      const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n      parser.acceptLexerState(pathParser);\n      let right;\n      switch (parsed.type) {\n        case 'JsdocTypeName':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value,\n            meta: {\n              quote: undefined\n            }\n          };\n          break;\n        case 'JsdocTypeNumber':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value.toString(10),\n            meta: {\n              quote: undefined\n            }\n          };\n          break;\n        case 'JsdocTypeStringValue':\n          right = {\n            type: 'JsdocTypeProperty',\n            value: parsed.value,\n            meta: {\n              quote: parsed.meta.quote\n            }\n          };\n          break;\n        case 'JsdocTypeSpecialNamePath':\n          if (parsed.specialType === 'event') {\n            right = parsed;\n          } else {\n            throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n          }\n          break;\n        default:\n          throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n      }\n      if (brackets && !parser.consume(']')) {\n        const token = parser.lexer.current;\n        throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` + `with text '${token.text}'`);\n      }\n      return {\n        type: 'JsdocTypeNamePath',\n        left: assertRootResult(left),\n        right,\n        pathType\n      };\n    };\n  }\n  function createNameParslet({\n    allowedAdditionalTokens\n  }) {\n    return composeParslet({\n      name: 'nameParslet',\n      accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n      parsePrefix: parser => {\n        const {\n          type,\n          text\n        } = parser.lexer.current;\n        parser.consume(type);\n        return {\n          type: 'JsdocTypeName',\n          value: text\n        };\n      }\n    });\n  }\n  const stringValueParslet = composeParslet({\n    name: 'stringValueParslet',\n    accept: type => type === 'StringValue',\n    parsePrefix: parser => {\n      const text = parser.lexer.current.text;\n      parser.consume('StringValue');\n      return {\n        type: 'JsdocTypeStringValue',\n        value: text.slice(1, -1),\n        meta: {\n          quote: text[0] === '\\'' ? 'single' : 'double'\n        }\n      };\n    }\n  });\n  function createSpecialNamePathParslet({\n    pathGrammar,\n    allowedTypes\n  }) {\n    return composeParslet({\n      name: 'specialNamePathParslet',\n      accept: type => allowedTypes.includes(type),\n      parsePrefix: parser => {\n        const type = parser.lexer.current.type;\n        parser.consume(type);\n        if (!parser.consume(':')) {\n          return {\n            type: 'JsdocTypeName',\n            value: type\n          };\n        }\n        let result;\n        let token = parser.lexer.current;\n        if (parser.consume('StringValue')) {\n          result = {\n            type: 'JsdocTypeSpecialNamePath',\n            value: token.text.slice(1, -1),\n            specialType: type,\n            meta: {\n              quote: token.text[0] === '\\'' ? 'single' : 'double'\n            }\n          };\n        } else {\n          let value = '';\n          const allowed = ['Identifier', '@', '/'];\n          while (allowed.some(type => parser.consume(type))) {\n            value += token.text;\n            token = parser.lexer.current;\n          }\n          result = {\n            type: 'JsdocTypeSpecialNamePath',\n            value,\n            specialType: type,\n            meta: {\n              quote: undefined\n            }\n          };\n        }\n        const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n        const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n        parser.acceptLexerState(moduleParser);\n        return assertRootResult(moduleResult);\n      }\n    });\n  }\n  const basePathGrammar = [createNameParslet({\n    allowedAdditionalTokens: ['external', 'module']\n  }), stringValueParslet, numberParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar: null\n  })];\n  const pathGrammar = [...basePathGrammar, createSpecialNamePathParslet({\n    allowedTypes: ['event'],\n    pathGrammar: basePathGrammar\n  })];\n  function getParameters(value) {\n    let parameters;\n    if (value.type === 'JsdocTypeParameterList') {\n      parameters = value.elements;\n    } else if (value.type === 'JsdocTypeParenthesis') {\n      parameters = [value.element];\n    } else {\n      throw new UnexpectedTypeError(value);\n    }\n    return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n  }\n  function getUnnamedParameters(value) {\n    const parameters = getParameters(value);\n    if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n      throw new Error('No parameter should be named');\n    }\n    return parameters;\n  }\n  function createFunctionParslet({\n    allowNamedParameters,\n    allowNoReturnType,\n    allowWithoutParenthesis,\n    allowNewAsFunctionKeyword\n  }) {\n    return composeParslet({\n      name: 'functionParslet',\n      accept: (type, next) => type === 'function' || allowNewAsFunctionKeyword && type === 'new' && next === '(',\n      parsePrefix: parser => {\n        const newKeyword = parser.consume('new');\n        parser.consume('function');\n        const hasParenthesis = parser.lexer.current.type === '(';\n        if (!hasParenthesis) {\n          if (!allowWithoutParenthesis) {\n            throw new Error('function is missing parameter list');\n          }\n          return {\n            type: 'JsdocTypeName',\n            value: 'function'\n          };\n        }\n        let result = {\n          type: 'JsdocTypeFunction',\n          parameters: [],\n          arrow: false,\n          constructor: newKeyword,\n          parenthesis: hasParenthesis\n        };\n        const value = parser.parseIntermediateType(Precedence.FUNCTION);\n        if (allowNamedParameters === undefined) {\n          result.parameters = getUnnamedParameters(value);\n        } else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n          result = value;\n          result.constructor = true;\n          return result;\n        } else {\n          result.parameters = getParameters(value);\n          for (const p of result.parameters) {\n            if (p.type === 'JsdocTypeKeyValue' && !allowNamedParameters.includes(p.key)) {\n              throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n            }\n          }\n        }\n        if (parser.consume(':')) {\n          result.returnType = parser.parseType(Precedence.PREFIX);\n        } else {\n          if (!allowNoReturnType) {\n            throw new Error('function is missing return type');\n          }\n        }\n        return result;\n      }\n    });\n  }\n  function createVariadicParslet({\n    allowPostfix,\n    allowEnclosingBrackets\n  }) {\n    return composeParslet({\n      name: 'variadicParslet',\n      accept: type => type === '...',\n      precedence: Precedence.PREFIX,\n      parsePrefix: parser => {\n        parser.consume('...');\n        const brackets = allowEnclosingBrackets && parser.consume('[');\n        try {\n          const element = parser.parseType(Precedence.PREFIX);\n          if (brackets && !parser.consume(']')) {\n            throw new Error('Unterminated variadic type. Missing \\']\\'');\n          }\n          return {\n            type: 'JsdocTypeVariadic',\n            element: assertRootResult(element),\n            meta: {\n              position: 'prefix',\n              squareBrackets: brackets\n            }\n          };\n        } catch (e) {\n          if (e instanceof NoParsletFoundError) {\n            if (brackets) {\n              throw new Error('Empty square brackets for variadic are not allowed.');\n            }\n            return {\n              type: 'JsdocTypeVariadic',\n              meta: {\n                position: undefined,\n                squareBrackets: false\n              }\n            };\n          } else {\n            throw e;\n          }\n        }\n      },\n      parseInfix: allowPostfix ? (parser, left) => {\n        parser.consume('...');\n        return {\n          type: 'JsdocTypeVariadic',\n          element: assertRootResult(left),\n          meta: {\n            position: 'suffix',\n            squareBrackets: false\n          }\n        };\n      } : undefined\n    });\n  }\n  const symbolParslet = composeParslet({\n    name: 'symbolParslet',\n    accept: type => type === '(',\n    precedence: Precedence.SYMBOL,\n    parseInfix: (parser, left) => {\n      if (left.type !== 'JsdocTypeName') {\n        throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n      }\n      parser.consume('(');\n      const result = {\n        type: 'JsdocTypeSymbol',\n        value: left.value\n      };\n      if (!parser.consume(')')) {\n        const next = parser.parseIntermediateType(Precedence.SYMBOL);\n        result.element = assertNumberOrVariadicNameResult(next);\n        if (!parser.consume(')')) {\n          throw new Error('Symbol does not end after value');\n        }\n      }\n      return result;\n    }\n  });\n  const arrayBracketsParslet = composeParslet({\n    name: 'arrayBracketsParslet',\n    precedence: Precedence.ARRAY_BRACKETS,\n    accept: (type, next) => type === '[' && next === ']',\n    parseInfix: (parser, left) => {\n      parser.consume('[');\n      parser.consume(']');\n      return {\n        type: 'JsdocTypeGeneric',\n        left: {\n          type: 'JsdocTypeName',\n          value: 'Array'\n        },\n        elements: [assertRootResult(left)],\n        meta: {\n          brackets: 'square',\n          dot: false\n        }\n      };\n    }\n  });\n  function createObjectParslet({\n    objectFieldGrammar,\n    allowKeyTypes\n  }) {\n    return composeParslet({\n      name: 'objectParslet',\n      accept: type => type === '{',\n      parsePrefix: parser => {\n        parser.consume('{');\n        const result = {\n          type: 'JsdocTypeObject',\n          meta: {\n            separator: 'comma'\n          },\n          elements: []\n        };\n        if (!parser.consume('}')) {\n          let separator;\n          const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n          while (true) {\n            fieldParser.acceptLexerState(parser);\n            let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n            parser.acceptLexerState(fieldParser);\n            if (field === undefined && allowKeyTypes) {\n              field = parser.parseIntermediateType(Precedence.OBJECT);\n            }\n            let optional = false;\n            if (field.type === 'JsdocTypeNullable') {\n              optional = true;\n              field = field.element;\n            }\n            if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n              let quote;\n              if (field.type === 'JsdocTypeStringValue') {\n                quote = field.meta.quote;\n              }\n              result.elements.push({\n                type: 'JsdocTypeObjectField',\n                key: field.value.toString(),\n                right: undefined,\n                optional,\n                readonly: false,\n                meta: {\n                  quote\n                }\n              });\n            } else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n              result.elements.push(field);\n            } else {\n              throw new UnexpectedTypeError(field);\n            }\n            if (parser.lexer.current.startOfLine) {\n              separator = 'linebreak';\n            } else if (parser.consume(',')) {\n              separator = 'comma';\n            } else if (parser.consume(';')) {\n              separator = 'semicolon';\n            } else {\n              break;\n            }\n            const type = parser.lexer.current.type;\n            if (type === '}') {\n              break;\n            }\n          }\n          result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n          if (!parser.consume('}')) {\n            throw new Error('Unterminated record type. Missing \\'}\\'');\n          }\n        }\n        return result;\n      }\n    });\n  }\n  function createObjectFieldParslet({\n    allowSquaredProperties,\n    allowKeyTypes,\n    allowReadonly,\n    allowOptional\n  }) {\n    return composeParslet({\n      name: 'objectFieldParslet',\n      precedence: Precedence.KEY_VALUE,\n      accept: type => type === ':',\n      parseInfix: (parser, left) => {\n        var _a;\n        let optional = false;\n        let readonlyProperty = false;\n        if (allowOptional && left.type === 'JsdocTypeNullable') {\n          optional = true;\n          left = left.element;\n        }\n        if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n          readonlyProperty = true;\n          left = left.element;\n        }\n        // object parslet uses a special grammar and for the value we want to switch back to the parent\n        const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n        parentParser.acceptLexerState(parser);\n        if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' || isSquaredProperty(left)) {\n          if (isSquaredProperty(left) && !allowSquaredProperties) {\n            throw new UnexpectedTypeError(left);\n          }\n          parentParser.consume(':');\n          let quote;\n          if (left.type === 'JsdocTypeStringValue') {\n            quote = left.meta.quote;\n          }\n          const right = parentParser.parseType(Precedence.KEY_VALUE);\n          parser.acceptLexerState(parentParser);\n          return {\n            type: 'JsdocTypeObjectField',\n            key: isSquaredProperty(left) ? left : left.value.toString(),\n            right,\n            optional,\n            readonly: readonlyProperty,\n            meta: {\n              quote\n            }\n          };\n        } else {\n          if (!allowKeyTypes) {\n            throw new UnexpectedTypeError(left);\n          }\n          parentParser.consume(':');\n          const right = parentParser.parseType(Precedence.KEY_VALUE);\n          parser.acceptLexerState(parentParser);\n          return {\n            type: 'JsdocTypeJsdocObjectField',\n            left: assertRootResult(left),\n            right\n          };\n        }\n      }\n    });\n  }\n  function createKeyValueParslet({\n    allowOptional,\n    allowVariadic\n  }) {\n    return composeParslet({\n      name: 'keyValueParslet',\n      precedence: Precedence.KEY_VALUE,\n      accept: type => type === ':',\n      parseInfix: (parser, left) => {\n        let optional = false;\n        let variadic = false;\n        if (allowOptional && left.type === 'JsdocTypeNullable') {\n          optional = true;\n          left = left.element;\n        }\n        if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n          variadic = true;\n          left = left.element;\n        }\n        if (left.type !== 'JsdocTypeName') {\n          throw new UnexpectedTypeError(left);\n        }\n        parser.consume(':');\n        const right = parser.parseType(Precedence.KEY_VALUE);\n        return {\n          type: 'JsdocTypeKeyValue',\n          key: left.value,\n          right,\n          optional,\n          variadic\n        };\n      }\n    });\n  }\n  const jsdocBaseGrammar = [...baseGrammar, createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }), stringValueParslet, createSpecialNamePathParslet({\n    allowedTypes: ['module', 'external', 'event'],\n    pathGrammar\n  }), createVariadicParslet({\n    allowEnclosingBrackets: true,\n    allowPostfix: true\n  }), createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }), symbolParslet, arrayBracketsParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  })];\n  const jsdocGrammar = [...jsdocBaseGrammar, createObjectParslet({\n    // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n    // we leave out the object type deliberately\n    objectFieldGrammar: [createNameParslet({\n      allowedAdditionalTokens: ['module', 'in']\n    }), createObjectFieldParslet({\n      allowSquaredProperties: false,\n      allowKeyTypes: true,\n      allowOptional: false,\n      allowReadonly: false\n    }), ...jsdocBaseGrammar],\n    allowKeyTypes: true\n  }), createKeyValueParslet({\n    allowOptional: true,\n    allowVariadic: true\n  })];\n  const typeOfParslet = composeParslet({\n    name: 'typeOfParslet',\n    accept: type => type === 'typeof',\n    parsePrefix: parser => {\n      parser.consume('typeof');\n      return {\n        type: 'JsdocTypeTypeof',\n        element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n      };\n    }\n  });\n  const objectFieldGrammar$1 = [createNameParslet({\n    allowedAdditionalTokens: ['module', 'keyof', 'event', 'external', 'in']\n  }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n    allowSquaredProperties: false,\n    allowKeyTypes: false,\n    allowOptional: false,\n    allowReadonly: false\n  })];\n  const closureGrammar = [...baseGrammar, createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar: objectFieldGrammar$1\n  }), createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }), typeOfParslet, createFunctionParslet({\n    allowWithoutParenthesis: false,\n    allowNamedParameters: ['this', 'new'],\n    allowNoReturnType: true,\n    allowNewAsFunctionKeyword: false\n  }), createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }),\n  // additional name parslet is needed for some special cases\n  createNameParslet({\n    allowedAdditionalTokens: ['keyof']\n  }), createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }), createNamePathParslet({\n    allowSquareBracketsOnAnyType: false,\n    allowJsdocNamePaths: true,\n    pathGrammar\n  }), createKeyValueParslet({\n    allowOptional: false,\n    allowVariadic: false\n  }), symbolParslet];\n  const assertsParslet = composeParslet({\n    name: 'assertsParslet',\n    accept: type => type === 'asserts',\n    parsePrefix: parser => {\n      parser.consume('asserts');\n      const left = parser.parseIntermediateType(Precedence.SYMBOL);\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n      }\n      parser.consume('is');\n      return {\n        type: 'JsdocTypeAsserts',\n        left,\n        right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n      };\n    }\n  });\n  function createTupleParslet({\n    allowQuestionMark\n  }) {\n    return composeParslet({\n      name: 'tupleParslet',\n      accept: type => type === '[',\n      parsePrefix: parser => {\n        parser.consume('[');\n        const result = {\n          type: 'JsdocTypeTuple',\n          elements: []\n        };\n        if (parser.consume(']')) {\n          return result;\n        }\n        const typeList = parser.parseIntermediateType(Precedence.ALL);\n        if (typeList.type === 'JsdocTypeParameterList') {\n          if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n            result.elements = typeList.elements.map(assertPlainKeyValueResult);\n          } else {\n            result.elements = typeList.elements.map(assertRootResult);\n          }\n        } else {\n          if (typeList.type === 'JsdocTypeKeyValue') {\n            result.elements = [assertPlainKeyValueResult(typeList)];\n          } else {\n            result.elements = [assertRootResult(typeList)];\n          }\n        }\n        if (!parser.consume(']')) {\n          throw new Error('Unterminated \\'[\\'');\n        }\n        if (!allowQuestionMark && result.elements.some(e => e.type === 'JsdocTypeUnknown')) {\n          throw new Error('Question mark in tuple not allowed');\n        }\n        return result;\n      }\n    });\n  }\n  const keyOfParslet = composeParslet({\n    name: 'keyOfParslet',\n    accept: type => type === 'keyof',\n    parsePrefix: parser => {\n      parser.consume('keyof');\n      return {\n        type: 'JsdocTypeKeyof',\n        element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n      };\n    }\n  });\n  const importParslet = composeParslet({\n    name: 'importParslet',\n    accept: type => type === 'import',\n    parsePrefix: parser => {\n      parser.consume('import');\n      if (!parser.consume('(')) {\n        throw new Error('Missing parenthesis after import keyword');\n      }\n      const path = parser.parseType(Precedence.PREFIX);\n      if (path.type !== 'JsdocTypeStringValue') {\n        throw new Error('Only string values are allowed as paths for imports');\n      }\n      if (!parser.consume(')')) {\n        throw new Error('Missing closing parenthesis after import keyword');\n      }\n      return {\n        type: 'JsdocTypeImport',\n        element: path\n      };\n    }\n  });\n  const readonlyPropertyParslet = composeParslet({\n    name: 'readonlyPropertyParslet',\n    accept: type => type === 'readonly',\n    parsePrefix: parser => {\n      parser.consume('readonly');\n      return {\n        type: 'JsdocTypeReadonlyProperty',\n        element: parser.parseType(Precedence.KEY_VALUE)\n      };\n    }\n  });\n  const arrowFunctionParslet = composeParslet({\n    name: 'arrowFunctionParslet',\n    precedence: Precedence.ARROW,\n    accept: type => type === '=>',\n    parseInfix: (parser, left) => {\n      parser.consume('=>');\n      return {\n        type: 'JsdocTypeFunction',\n        parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n        arrow: true,\n        constructor: false,\n        parenthesis: true,\n        returnType: parser.parseType(Precedence.OBJECT)\n      };\n    }\n  });\n  const intersectionParslet = composeParslet({\n    name: 'intersectionParslet',\n    accept: type => type === '&',\n    precedence: Precedence.INTERSECTION,\n    parseInfix: (parser, left) => {\n      parser.consume('&');\n      const elements = [];\n      do {\n        elements.push(parser.parseType(Precedence.INTERSECTION));\n      } while (parser.consume('&'));\n      return {\n        type: 'JsdocTypeIntersection',\n        elements: [assertRootResult(left), ...elements]\n      };\n    }\n  });\n  const predicateParslet = composeParslet({\n    name: 'predicateParslet',\n    precedence: Precedence.INFIX,\n    accept: type => type === 'is',\n    parseInfix: (parser, left) => {\n      if (left.type !== 'JsdocTypeName') {\n        throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n      }\n      parser.consume('is');\n      return {\n        type: 'JsdocTypePredicate',\n        left,\n        right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n      };\n    }\n  });\n  const objectSquaredPropertyParslet = composeParslet({\n    name: 'objectSquareBracketPropertyParslet',\n    accept: type => type === '[',\n    parsePrefix: parser => {\n      if (parser.baseParser === undefined) {\n        throw new Error('Only allowed inside object grammar');\n      }\n      parser.consume('[');\n      const key = parser.lexer.current.text;\n      parser.consume('Identifier');\n      let result;\n      if (parser.consume(':')) {\n        const parentParser = parser.baseParser;\n        parentParser.acceptLexerState(parser);\n        result = {\n          type: 'JsdocTypeIndexSignature',\n          key,\n          right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n        };\n        parser.acceptLexerState(parentParser);\n      } else if (parser.consume('in')) {\n        const parentParser = parser.baseParser;\n        parentParser.acceptLexerState(parser);\n        result = {\n          type: 'JsdocTypeMappedType',\n          key,\n          right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n        };\n        parser.acceptLexerState(parentParser);\n      } else {\n        throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n      }\n      if (!parser.consume(']')) {\n        throw new Error('Unterminated square brackets');\n      }\n      return result;\n    }\n  });\n  const objectFieldGrammar = [readonlyPropertyParslet, createNameParslet({\n    allowedAdditionalTokens: ['module', 'event', 'keyof', 'event', 'external', 'in']\n  }), nullableParslet, optionalParslet, stringValueParslet, numberParslet, createObjectFieldParslet({\n    allowSquaredProperties: true,\n    allowKeyTypes: false,\n    allowOptional: true,\n    allowReadonly: true\n  }), objectSquaredPropertyParslet];\n  const typescriptGrammar = [...baseGrammar, createObjectParslet({\n    allowKeyTypes: false,\n    objectFieldGrammar\n  }), typeOfParslet, keyOfParslet, importParslet, stringValueParslet, createFunctionParslet({\n    allowWithoutParenthesis: true,\n    allowNoReturnType: false,\n    allowNamedParameters: ['this', 'new', 'args'],\n    allowNewAsFunctionKeyword: true\n  }), createTupleParslet({\n    allowQuestionMark: false\n  }), createVariadicParslet({\n    allowEnclosingBrackets: false,\n    allowPostfix: false\n  }), assertsParslet, createNameParslet({\n    allowedAdditionalTokens: ['event', 'external', 'in']\n  }), createSpecialNamePathParslet({\n    allowedTypes: ['module'],\n    pathGrammar\n  }), arrayBracketsParslet, arrowFunctionParslet, createNamePathParslet({\n    allowSquareBracketsOnAnyType: true,\n    allowJsdocNamePaths: false,\n    pathGrammar\n  }), intersectionParslet, predicateParslet, createKeyValueParslet({\n    allowVariadic: true,\n    allowOptional: true\n  })];\n\n  /**\n   * This function parses the given expression in the given mode and produces a {@link RootResult}.\n   * @param expression\n   * @param mode\n   */\n  function parse(expression, mode) {\n    switch (mode) {\n      case 'closure':\n        return new Parser(closureGrammar, expression).parse();\n      case 'jsdoc':\n        return new Parser(jsdocGrammar, expression).parse();\n      case 'typescript':\n        return new Parser(typescriptGrammar, expression).parse();\n    }\n  }\n  /**\n   * This function tries to parse the given expression in multiple modes and returns the first successful\n   * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n   * no mode was successful it throws the error that was produced by the last parsing attempt.\n   * @param expression\n   * @param modes\n   */\n  function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\n    let error;\n    for (const mode of modes) {\n      try {\n        return parse(expression, mode);\n      } catch (e) {\n        error = e;\n      }\n    }\n    throw error;\n  }\n  function transform(rules, parseResult) {\n    const rule = rules[parseResult.type];\n    if (rule === undefined) {\n      throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n    }\n    return rule(parseResult, aParseResult => transform(rules, aParseResult));\n  }\n  function notAvailableTransform(parseResult) {\n    throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n  }\n  function extractSpecialParams(source) {\n    const result = {\n      params: []\n    };\n    for (const param of source.parameters) {\n      if (param.type === 'JsdocTypeKeyValue') {\n        if (param.key === 'this') {\n          result.this = param.right;\n        } else if (param.key === 'new') {\n          result.new = param.right;\n        } else {\n          result.params.push(param);\n        }\n      } else {\n        result.params.push(param);\n      }\n    }\n    return result;\n  }\n  function applyPosition(position, target, value) {\n    return position === 'prefix' ? value + target : target + value;\n  }\n  function quote(value, quote) {\n    switch (quote) {\n      case 'double':\n        return `\"${value}\"`;\n      case 'single':\n        return `'${value}'`;\n      case undefined:\n        return value;\n    }\n  }\n  function stringifyRules() {\n    return {\n      JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n      JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n      JsdocTypeFunction: (result, transform) => {\n        if (!result.arrow) {\n          let stringified = result.constructor ? 'new' : 'function';\n          if (!result.parenthesis) {\n            return stringified;\n          }\n          stringified += `(${result.parameters.map(transform).join(', ')})`;\n          if (result.returnType !== undefined) {\n            stringified += `: ${transform(result.returnType)}`;\n          }\n          return stringified;\n        } else {\n          if (result.returnType === undefined) {\n            throw new Error('Arrow function needs a return type.');\n          }\n          let stringified = `(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n          if (result.constructor) {\n            stringified = 'new ' + stringified;\n          }\n          return stringified;\n        }\n      },\n      JsdocTypeName: result => result.value,\n      JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n      JsdocTypeVariadic: (result, transform) => result.meta.position === undefined ? '...' : applyPosition(result.meta.position, transform(result.element), '...'),\n      JsdocTypeNamePath: (result, transform) => {\n        const left = transform(result.left);\n        const right = transform(result.right);\n        switch (result.pathType) {\n          case 'inner':\n            return `${left}~${right}`;\n          case 'instance':\n            return `${left}#${right}`;\n          case 'property':\n            return `${left}.${right}`;\n          case 'property-brackets':\n            return `${left}[${right}]`;\n        }\n      },\n      JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n      JsdocTypeAny: () => '*',\n      JsdocTypeGeneric: (result, transform) => {\n        if (result.meta.brackets === 'square') {\n          const element = result.elements[0];\n          const transformed = transform(element);\n          if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n            return `(${transformed})[]`;\n          } else {\n            return `${transformed}[]`;\n          }\n        } else {\n          return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.elements.map(transform).join(', ')}>`;\n        }\n      },\n      JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n      JsdocTypeObjectField: (result, transform) => {\n        let text = '';\n        if (result.readonly) {\n          text += 'readonly ';\n        }\n        if (typeof result.key === 'string') {\n          text += quote(result.key, result.meta.quote);\n        } else {\n          text += transform(result.key);\n        }\n        if (result.optional) {\n          text += '?';\n        }\n        if (result.right === undefined) {\n          return text;\n        } else {\n          return text + `: ${transform(result.right)}`;\n        }\n      },\n      JsdocTypeJsdocObjectField: (result, transform) => {\n        return `${transform(result.left)}: ${transform(result.right)}`;\n      },\n      JsdocTypeKeyValue: (result, transform) => {\n        let text = result.key;\n        if (result.optional) {\n          text += '?';\n        }\n        if (result.variadic) {\n          text = '...' + text;\n        }\n        if (result.right === undefined) {\n          return text;\n        } else {\n          return text + `: ${transform(result.right)}`;\n        }\n      },\n      JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n      JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n      JsdocTypeNull: () => 'null',\n      JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n      JsdocTypeNumber: result => result.value.toString(),\n      JsdocTypeObject: (result, transform) => `{${result.elements.map(transform).join((result.meta.separator === 'comma' ? ',' : ';') + ' ')}}`,\n      JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n      JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n      JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n      JsdocTypeUndefined: () => 'undefined',\n      JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n      JsdocTypeUnknown: () => '?',\n      JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n      JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n      JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n      JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n      JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n      JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`\n    };\n  }\n  const storedStringifyRules = stringifyRules();\n  function stringify(result) {\n    return transform(storedStringifyRules, result);\n  }\n  const reservedWords = ['null', 'true', 'false', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield'];\n  function makeName(value) {\n    const result = {\n      type: 'NameExpression',\n      name: value\n    };\n    if (reservedWords.includes(value)) {\n      result.reservedWord = true;\n    }\n    return result;\n  }\n  const catharsisTransformRules = {\n    JsdocTypeOptional: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.optional = true;\n      return transformed;\n    },\n    JsdocTypeNullable: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.nullable = true;\n      return transformed;\n    },\n    JsdocTypeNotNullable: (result, transform) => {\n      const transformed = transform(result.element);\n      transformed.nullable = false;\n      return transformed;\n    },\n    JsdocTypeVariadic: (result, transform) => {\n      if (result.element === undefined) {\n        throw new Error('dots without value are not allowed in catharsis mode');\n      }\n      const transformed = transform(result.element);\n      transformed.repeatable = true;\n      return transformed;\n    },\n    JsdocTypeAny: () => ({\n      type: 'AllLiteral'\n    }),\n    JsdocTypeNull: () => ({\n      type: 'NullLiteral'\n    }),\n    JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n    JsdocTypeUndefined: () => ({\n      type: 'UndefinedLiteral'\n    }),\n    JsdocTypeUnknown: () => ({\n      type: 'UnknownLiteral'\n    }),\n    JsdocTypeFunction: (result, transform) => {\n      const params = extractSpecialParams(result);\n      const transformed = {\n        type: 'FunctionType',\n        params: params.params.map(transform)\n      };\n      if (params.this !== undefined) {\n        transformed.this = transform(params.this);\n      }\n      if (params.new !== undefined) {\n        transformed.new = transform(params.new);\n      }\n      if (result.returnType !== undefined) {\n        transformed.result = transform(result.returnType);\n      }\n      return transformed;\n    },\n    JsdocTypeGeneric: (result, transform) => ({\n      type: 'TypeApplication',\n      applications: result.elements.map(o => transform(o)),\n      expression: transform(result.left)\n    }),\n    JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n    JsdocTypeName: result => {\n      if (result.value !== 'function') {\n        return makeName(result.value);\n      } else {\n        return {\n          type: 'FunctionType',\n          params: []\n        };\n      }\n    },\n    JsdocTypeNumber: result => makeName(result.value.toString()),\n    JsdocTypeObject: (result, transform) => {\n      const transformed = {\n        type: 'RecordType',\n        fields: []\n      };\n      for (const field of result.elements) {\n        if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n          transformed.fields.push({\n            type: 'FieldType',\n            key: transform(field),\n            value: undefined\n          });\n        } else {\n          transformed.fields.push(transform(field));\n        }\n      }\n      return transformed;\n    },\n    JsdocTypeObjectField: (result, transform) => {\n      if (typeof result.key !== 'string') {\n        throw new Error('Index signatures and mapped types are not supported');\n      }\n      return {\n        type: 'FieldType',\n        key: makeName(quote(result.key, result.meta.quote)),\n        value: result.right === undefined ? undefined : transform(result.right)\n      };\n    },\n    JsdocTypeJsdocObjectField: (result, transform) => ({\n      type: 'FieldType',\n      key: transform(result.left),\n      value: transform(result.right)\n    }),\n    JsdocTypeUnion: (result, transform) => ({\n      type: 'TypeUnion',\n      elements: result.elements.map(e => transform(e))\n    }),\n    JsdocTypeKeyValue: (result, transform) => {\n      return {\n        type: 'FieldType',\n        key: makeName(result.key),\n        value: result.right === undefined ? undefined : transform(result.right)\n      };\n    },\n    JsdocTypeNamePath: (result, transform) => {\n      const leftResult = transform(result.left);\n      let rightValue;\n      if (result.right.type === 'JsdocTypeSpecialNamePath') {\n        rightValue = transform(result.right).name;\n      } else {\n        rightValue = quote(result.right.value, result.right.meta.quote);\n      }\n      const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n      return makeName(`${leftResult.name}${joiner}${rightValue}`);\n    },\n    JsdocTypeSymbol: result => {\n      let value = '';\n      let element = result.element;\n      let trailingDots = false;\n      if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n        if (element.meta.position === 'prefix') {\n          value = '...';\n        } else {\n          trailingDots = true;\n        }\n        element = element.element;\n      }\n      if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n        value += element.value;\n      } else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n        value += element.value.toString();\n      }\n      if (trailingDots) {\n        value += '...';\n      }\n      return makeName(`${result.value}(${value})`);\n    },\n    JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n    JsdocTypeMappedType: notAvailableTransform,\n    JsdocTypeIndexSignature: notAvailableTransform,\n    JsdocTypeImport: notAvailableTransform,\n    JsdocTypeKeyof: notAvailableTransform,\n    JsdocTypeTuple: notAvailableTransform,\n    JsdocTypeTypeof: notAvailableTransform,\n    JsdocTypeIntersection: notAvailableTransform,\n    JsdocTypeProperty: notAvailableTransform,\n    JsdocTypePredicate: notAvailableTransform,\n    JsdocTypeAsserts: notAvailableTransform\n  };\n  function catharsisTransform(result) {\n    return transform(catharsisTransformRules, result);\n  }\n  function getQuoteStyle(quote) {\n    switch (quote) {\n      case undefined:\n        return 'none';\n      case 'single':\n        return 'single';\n      case 'double':\n        return 'double';\n    }\n  }\n  function getMemberType(type) {\n    switch (type) {\n      case 'inner':\n        return 'INNER_MEMBER';\n      case 'instance':\n        return 'INSTANCE_MEMBER';\n      case 'property':\n        return 'MEMBER';\n      case 'property-brackets':\n        return 'MEMBER';\n    }\n  }\n  function nestResults(type, results) {\n    if (results.length === 2) {\n      return {\n        type,\n        left: results[0],\n        right: results[1]\n      };\n    } else {\n      return {\n        type,\n        left: results[0],\n        right: nestResults(type, results.slice(1))\n      };\n    }\n  }\n  const jtpRules = {\n    JsdocTypeOptional: (result, transform) => ({\n      type: 'OPTIONAL',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n      }\n    }),\n    JsdocTypeNullable: (result, transform) => ({\n      type: 'NULLABLE',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n      }\n    }),\n    JsdocTypeNotNullable: (result, transform) => ({\n      type: 'NOT_NULLABLE',\n      value: transform(result.element),\n      meta: {\n        syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n      }\n    }),\n    JsdocTypeVariadic: (result, transform) => {\n      const transformed = {\n        type: 'VARIADIC',\n        meta: {\n          syntax: result.meta.position === 'prefix' ? 'PREFIX_DOTS' : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n        }\n      };\n      if (result.element !== undefined) {\n        transformed.value = transform(result.element);\n      }\n      return transformed;\n    },\n    JsdocTypeName: result => ({\n      type: 'NAME',\n      name: result.value\n    }),\n    JsdocTypeTypeof: (result, transform) => ({\n      type: 'TYPE_QUERY',\n      name: transform(result.element)\n    }),\n    JsdocTypeTuple: (result, transform) => ({\n      type: 'TUPLE',\n      entries: result.elements.map(transform)\n    }),\n    JsdocTypeKeyof: (result, transform) => ({\n      type: 'KEY_QUERY',\n      value: transform(result.element)\n    }),\n    JsdocTypeImport: result => ({\n      type: 'IMPORT',\n      path: {\n        type: 'STRING_VALUE',\n        quoteStyle: getQuoteStyle(result.element.meta.quote),\n        string: result.element.value\n      }\n    }),\n    JsdocTypeUndefined: () => ({\n      type: 'NAME',\n      name: 'undefined'\n    }),\n    JsdocTypeAny: () => ({\n      type: 'ANY'\n    }),\n    JsdocTypeFunction: (result, transform) => {\n      const specialParams = extractSpecialParams(result);\n      const transformed = {\n        type: result.arrow ? 'ARROW' : 'FUNCTION',\n        params: specialParams.params.map(param => {\n          if (param.type === 'JsdocTypeKeyValue') {\n            if (param.right === undefined) {\n              throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n            }\n            return {\n              type: 'NAMED_PARAMETER',\n              name: param.key,\n              typeName: transform(param.right)\n            };\n          } else {\n            return transform(param);\n          }\n        }),\n        new: null,\n        returns: null\n      };\n      if (specialParams.this !== undefined) {\n        transformed.this = transform(specialParams.this);\n      } else if (!result.arrow) {\n        transformed.this = null;\n      }\n      if (specialParams.new !== undefined) {\n        transformed.new = transform(specialParams.new);\n      }\n      if (result.returnType !== undefined) {\n        transformed.returns = transform(result.returnType);\n      }\n      return transformed;\n    },\n    JsdocTypeGeneric: (result, transform) => {\n      const transformed = {\n        type: 'GENERIC',\n        subject: transform(result.left),\n        objects: result.elements.map(transform),\n        meta: {\n          syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n        }\n      };\n      if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n        transformed.objects[0] = {\n          type: 'NAME',\n          name: 'function'\n        };\n      }\n      return transformed;\n    },\n    JsdocTypeObjectField: (result, transform) => {\n      if (typeof result.key !== 'string') {\n        throw new Error('Index signatures and mapped types are not supported');\n      }\n      if (result.right === undefined) {\n        return {\n          type: 'RECORD_ENTRY',\n          key: result.key,\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          value: null,\n          readonly: false\n        };\n      }\n      let right = transform(result.right);\n      if (result.optional) {\n        right = {\n          type: 'OPTIONAL',\n          value: right,\n          meta: {\n            syntax: 'SUFFIX_KEY_QUESTION_MARK'\n          }\n        };\n      }\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key.toString(),\n        quoteStyle: getQuoteStyle(result.meta.quote),\n        value: right,\n        readonly: false\n      };\n    },\n    JsdocTypeJsdocObjectField: () => {\n      throw new Error('Keys may not be typed in jsdoctypeparser.');\n    },\n    JsdocTypeKeyValue: (result, transform) => {\n      if (result.right === undefined) {\n        return {\n          type: 'RECORD_ENTRY',\n          key: result.key,\n          quoteStyle: 'none',\n          value: null,\n          readonly: false\n        };\n      }\n      let right = transform(result.right);\n      if (result.optional) {\n        right = {\n          type: 'OPTIONAL',\n          value: right,\n          meta: {\n            syntax: 'SUFFIX_KEY_QUESTION_MARK'\n          }\n        };\n      }\n      return {\n        type: 'RECORD_ENTRY',\n        key: result.key,\n        quoteStyle: 'none',\n        value: right,\n        readonly: false\n      };\n    },\n    JsdocTypeObject: (result, transform) => {\n      const entries = [];\n      for (const field of result.elements) {\n        if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n          entries.push(transform(field));\n        }\n      }\n      return {\n        type: 'RECORD',\n        entries\n      };\n    },\n    JsdocTypeSpecialNamePath: result => {\n      if (result.specialType !== 'module') {\n        throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n      }\n      return {\n        type: 'MODULE',\n        value: {\n          type: 'FILE_PATH',\n          quoteStyle: getQuoteStyle(result.meta.quote),\n          path: result.value\n        }\n      };\n    },\n    JsdocTypeNamePath: (result, transform) => {\n      let hasEventPrefix = false;\n      let name;\n      let quoteStyle;\n      if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n        hasEventPrefix = true;\n        name = result.right.value;\n        quoteStyle = getQuoteStyle(result.right.meta.quote);\n      } else {\n        name = result.right.value;\n        quoteStyle = getQuoteStyle(result.right.meta.quote);\n      }\n      const transformed = {\n        type: getMemberType(result.pathType),\n        owner: transform(result.left),\n        name,\n        quoteStyle,\n        hasEventPrefix\n      };\n      if (transformed.owner.type === 'MODULE') {\n        const tModule = transformed.owner;\n        transformed.owner = transformed.owner.value;\n        tModule.value = transformed;\n        return tModule;\n      } else {\n        return transformed;\n      }\n    },\n    JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n    JsdocTypeParenthesis: (result, transform) => ({\n      type: 'PARENTHESIS',\n      value: transform(assertRootResult(result.element))\n    }),\n    JsdocTypeNull: () => ({\n      type: 'NAME',\n      name: 'null'\n    }),\n    JsdocTypeUnknown: () => ({\n      type: 'UNKNOWN'\n    }),\n    JsdocTypeStringValue: result => ({\n      type: 'STRING_VALUE',\n      quoteStyle: getQuoteStyle(result.meta.quote),\n      string: result.value\n    }),\n    JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n    JsdocTypeNumber: result => ({\n      type: 'NUMBER_VALUE',\n      number: result.value.toString()\n    }),\n    JsdocTypeSymbol: notAvailableTransform,\n    JsdocTypeProperty: notAvailableTransform,\n    JsdocTypePredicate: notAvailableTransform,\n    JsdocTypeMappedType: notAvailableTransform,\n    JsdocTypeIndexSignature: notAvailableTransform,\n    JsdocTypeAsserts: notAvailableTransform\n  };\n  function jtpTransform(result) {\n    return transform(jtpRules, result);\n  }\n  function identityTransformRules() {\n    return {\n      JsdocTypeIntersection: (result, transform) => ({\n        type: 'JsdocTypeIntersection',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeGeneric: (result, transform) => ({\n        type: 'JsdocTypeGeneric',\n        left: transform(result.left),\n        elements: result.elements.map(transform),\n        meta: {\n          dot: result.meta.dot,\n          brackets: result.meta.brackets\n        }\n      }),\n      JsdocTypeNullable: result => result,\n      JsdocTypeUnion: (result, transform) => ({\n        type: 'JsdocTypeUnion',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeUnknown: result => result,\n      JsdocTypeUndefined: result => result,\n      JsdocTypeTypeof: (result, transform) => ({\n        type: 'JsdocTypeTypeof',\n        element: transform(result.element)\n      }),\n      JsdocTypeSymbol: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeSymbol',\n          value: result.value\n        };\n        if (result.element !== undefined) {\n          transformed.element = transform(result.element);\n        }\n        return transformed;\n      },\n      JsdocTypeOptional: (result, transform) => ({\n        type: 'JsdocTypeOptional',\n        element: transform(result.element),\n        meta: {\n          position: result.meta.position\n        }\n      }),\n      JsdocTypeObject: (result, transform) => ({\n        type: 'JsdocTypeObject',\n        meta: {\n          separator: 'comma'\n        },\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeNumber: result => result,\n      JsdocTypeNull: result => result,\n      JsdocTypeNotNullable: (result, transform) => ({\n        type: 'JsdocTypeNotNullable',\n        element: transform(result.element),\n        meta: {\n          position: result.meta.position\n        }\n      }),\n      JsdocTypeSpecialNamePath: result => result,\n      JsdocTypeObjectField: (result, transform) => ({\n        type: 'JsdocTypeObjectField',\n        key: result.key,\n        right: result.right === undefined ? undefined : transform(result.right),\n        optional: result.optional,\n        readonly: result.readonly,\n        meta: result.meta\n      }),\n      JsdocTypeJsdocObjectField: (result, transform) => ({\n        type: 'JsdocTypeJsdocObjectField',\n        left: transform(result.left),\n        right: transform(result.right)\n      }),\n      JsdocTypeKeyValue: (result, transform) => {\n        return {\n          type: 'JsdocTypeKeyValue',\n          key: result.key,\n          right: result.right === undefined ? undefined : transform(result.right),\n          optional: result.optional,\n          variadic: result.variadic\n        };\n      },\n      JsdocTypeImport: (result, transform) => ({\n        type: 'JsdocTypeImport',\n        element: transform(result.element)\n      }),\n      JsdocTypeAny: result => result,\n      JsdocTypeStringValue: result => result,\n      JsdocTypeNamePath: result => result,\n      JsdocTypeVariadic: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeVariadic',\n          meta: {\n            position: result.meta.position,\n            squareBrackets: result.meta.squareBrackets\n          }\n        };\n        if (result.element !== undefined) {\n          transformed.element = transform(result.element);\n        }\n        return transformed;\n      },\n      JsdocTypeTuple: (result, transform) => ({\n        type: 'JsdocTypeTuple',\n        elements: result.elements.map(transform)\n      }),\n      JsdocTypeName: result => result,\n      JsdocTypeFunction: (result, transform) => {\n        const transformed = {\n          type: 'JsdocTypeFunction',\n          arrow: result.arrow,\n          parameters: result.parameters.map(transform),\n          constructor: result.constructor,\n          parenthesis: result.parenthesis\n        };\n        if (result.returnType !== undefined) {\n          transformed.returnType = transform(result.returnType);\n        }\n        return transformed;\n      },\n      JsdocTypeKeyof: (result, transform) => ({\n        type: 'JsdocTypeKeyof',\n        element: transform(result.element)\n      }),\n      JsdocTypeParenthesis: (result, transform) => ({\n        type: 'JsdocTypeParenthesis',\n        element: transform(result.element)\n      }),\n      JsdocTypeProperty: result => result,\n      JsdocTypePredicate: (result, transform) => ({\n        type: 'JsdocTypePredicate',\n        left: transform(result.left),\n        right: transform(result.right)\n      }),\n      JsdocTypeIndexSignature: (result, transform) => ({\n        type: 'JsdocTypeIndexSignature',\n        key: result.key,\n        right: transform(result.right)\n      }),\n      JsdocTypeMappedType: (result, transform) => ({\n        type: 'JsdocTypeMappedType',\n        key: result.key,\n        right: transform(result.right)\n      }),\n      JsdocTypeAsserts: (result, transform) => ({\n        type: 'JsdocTypeAsserts',\n        left: transform(result.left),\n        right: transform(result.right)\n      })\n    };\n  }\n  const visitorKeys = {\n    JsdocTypeAny: [],\n    JsdocTypeFunction: ['parameters', 'returnType'],\n    JsdocTypeGeneric: ['left', 'elements'],\n    JsdocTypeImport: [],\n    JsdocTypeIndexSignature: ['right'],\n    JsdocTypeIntersection: ['elements'],\n    JsdocTypeKeyof: ['element'],\n    JsdocTypeKeyValue: ['right'],\n    JsdocTypeMappedType: ['right'],\n    JsdocTypeName: [],\n    JsdocTypeNamePath: ['left', 'right'],\n    JsdocTypeNotNullable: ['element'],\n    JsdocTypeNull: [],\n    JsdocTypeNullable: ['element'],\n    JsdocTypeNumber: [],\n    JsdocTypeObject: ['elements'],\n    JsdocTypeObjectField: ['right'],\n    JsdocTypeJsdocObjectField: ['left', 'right'],\n    JsdocTypeOptional: ['element'],\n    JsdocTypeParenthesis: ['element'],\n    JsdocTypeSpecialNamePath: [],\n    JsdocTypeStringValue: [],\n    JsdocTypeSymbol: ['element'],\n    JsdocTypeTuple: ['elements'],\n    JsdocTypeTypeof: ['element'],\n    JsdocTypeUndefined: [],\n    JsdocTypeUnion: ['elements'],\n    JsdocTypeUnknown: [],\n    JsdocTypeVariadic: ['element'],\n    JsdocTypeProperty: [],\n    JsdocTypePredicate: ['left', 'right'],\n    JsdocTypeAsserts: ['left', 'right']\n  };\n  function _traverse(node, parentNode, property, onEnter, onLeave) {\n    onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n    const keysToVisit = visitorKeys[node.type];\n    for (const key of keysToVisit) {\n      const value = node[key];\n      if (value !== undefined) {\n        if (Array.isArray(value)) {\n          for (const element of value) {\n            _traverse(element, node, key, onEnter, onLeave);\n          }\n        } else {\n          _traverse(value, node, key, onEnter, onLeave);\n        }\n      }\n    }\n    onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n  }\n  /**\n   * A function to traverse an AST. It traverses it depth first.\n   * @param node the node to start traversing at.\n   * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n   * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n   */\n  function traverse(node, onEnter, onLeave) {\n    _traverse(node, undefined, undefined, onEnter, onLeave);\n  }\n  exports.catharsisTransform = catharsisTransform;\n  exports.identityTransformRules = identityTransformRules;\n  exports.jtpTransform = jtpTransform;\n  exports.parse = parse;\n  exports.stringify = stringify;\n  exports.stringifyRules = stringifyRules;\n  exports.transform = transform;\n  exports.traverse = traverse;\n  exports.tryParse = tryParse;\n  exports.visitorKeys = visitorKeys;\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","jtpp","tokenToString","token","text","undefined","type","NoParsletFoundError","Error","constructor","Object","setPrototypeOf","prototype","getToken","EarlyEndOfParseError","UnexpectedTypeError","result","message","error","makePunctuationRule","startsWith","getQuoted","position","char","mark","escaped","length","slice","identifierStartRegex","identifierContinueRegex","getIdentifier","test","numberRegex","getNumber","_a","_b","exec","identifierRule","value","makeKeyWordRule","prepends","stringValueRule","eofRule","numberRule","rules","breakingWhitespaceRegex","Lexer","create","current","read","next","previous","startOfLine","trim","rule","partial","assign","advance","assertRootResult","assertPlainKeyValueOrRootResult","assertPlainKeyValueResult","assertPlainKeyValueOrNameResult","assertNumberOrVariadicNameResult","element","isSquaredProperty","Precedence","Parser","grammar","textOrLexer","baseParser","_lexer","lexer","parse","parseType","ALL","precedence","parseIntermediateType","tryParslets","parseInfixIntermediateType","left","parslet","consume","types","Array","isArray","includes","acceptLexerState","parser","isQuestionMarkUnknownType","nullableParslet","accept","NULLABLE","meta","composeParslet","options","curPrecedence","parsePrefix","parseInfix","defineProperty","name","optionalParslet","OPTIONAL","numberParslet","parseFloat","parenthesisParslet","elements","specialTypesParslet","notNullableParslet","createParameterListParslet","allowTrailingComma","PARAMETER_LIST","push","e","some","genericParslet","GENERIC","dot","objects","brackets","unionParslet","UNION","baseGrammar","createNamePathParslet","allowSquareBracketsOnAnyType","allowJsdocNamePaths","pathGrammar","namePathParslet","NAME_PATH","pathType","pathParser","parsed","right","quote","toString","specialType","createNameParslet","allowedAdditionalTokens","stringValueParslet","createSpecialNamePathParslet","allowedTypes","allowed","moduleParser","moduleResult","basePathGrammar","getParameters","parameters","map","p","getUnnamedParameters","createFunctionParslet","allowNamedParameters","allowNoReturnType","allowWithoutParenthesis","allowNewAsFunctionKeyword","newKeyword","hasParenthesis","arrow","parenthesis","FUNCTION","key","join","returnType","PREFIX","createVariadicParslet","allowPostfix","allowEnclosingBrackets","squareBrackets","symbolParslet","SYMBOL","arrayBracketsParslet","ARRAY_BRACKETS","createObjectParslet","objectFieldGrammar","allowKeyTypes","separator","fieldParser","field","OBJECT","optional","readonly","createObjectFieldParslet","allowSquaredProperties","allowReadonly","allowOptional","KEY_VALUE","readonlyProperty","parentParser","createKeyValueParslet","allowVariadic","variadic","jsdocBaseGrammar","jsdocGrammar","typeOfParslet","KEY_OF_TYPE_OF","objectFieldGrammar$1","closureGrammar","assertsParslet","INFIX","createTupleParslet","allowQuestionMark","typeList","keyOfParslet","importParslet","path","readonlyPropertyParslet","arrowFunctionParslet","ARROW","intersectionParslet","INTERSECTION","predicateParslet","objectSquaredPropertyParslet","INDEX_BRACKETS","typescriptGrammar","expression","mode","tryParse","modes","transform","parseResult","aParseResult","notAvailableTransform","extractSpecialParams","source","params","param","this","new","applyPosition","target","stringifyRules","JsdocTypeParenthesis","JsdocTypeKeyof","JsdocTypeFunction","stringified","JsdocTypeName","JsdocTypeTuple","JsdocTypeVariadic","JsdocTypeNamePath","JsdocTypeStringValue","JsdocTypeAny","JsdocTypeGeneric","transformed","JsdocTypeImport","JsdocTypeObjectField","JsdocTypeJsdocObjectField","JsdocTypeKeyValue","JsdocTypeSpecialNamePath","JsdocTypeNotNullable","JsdocTypeNull","JsdocTypeNullable","JsdocTypeNumber","JsdocTypeObject","JsdocTypeOptional","JsdocTypeSymbol","JsdocTypeTypeof","JsdocTypeUndefined","JsdocTypeUnion","JsdocTypeUnknown","JsdocTypeIntersection","JsdocTypeProperty","JsdocTypePredicate","JsdocTypeIndexSignature","JsdocTypeMappedType","JsdocTypeAsserts","storedStringifyRules","stringify","reservedWords","makeName","reservedWord","catharsisTransformRules","nullable","repeatable","applications","o","fields","leftResult","rightValue","joiner","trailingDots","catharsisTransform","getQuoteStyle","getMemberType","nestResults","results","jtpRules","syntax","entries","quoteStyle","string","specialParams","typeName","returns","subject","hasEventPrefix","owner","tModule","number","jtpTransform","identityTransformRules","visitorKeys","_traverse","node","parentNode","property","onEnter","onLeave","keysToVisit","traverse"],"sources":["/Users/adbyrd/Documents/clients/elwood.berry/github/ideparture/ideparture/node_modules/jsdoc-type-pratt-parser/dist/index.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\n})(this, (function (exports) { 'use strict';\n\n    function tokenToString(token) {\n        if (token.text !== undefined && token.text !== '') {\n            return `'${token.type}' with value '${token.text}'`;\n        }\n        else {\n            return `'${token.type}'`;\n        }\n    }\n    class NoParsletFoundError extends Error {\n        constructor(token) {\n            super(`No parslet found for token: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class EarlyEndOfParseError extends Error {\n        constructor(token) {\n            super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n            let error = `Unexpected type: '${result.type}'.`;\n            if (message !== undefined) {\n                error += ` Message: ${message}`;\n            }\n            super(error);\n            Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n    }\n    // export class UnexpectedTokenError extends Error {\n    //   private expected: Token\n    //   private found: Token\n    //\n    //   constructor (expected: Token, found: Token) {\n    //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n    //\n    //     this.token = token\n    //\n    //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n    //   }\n    //\n    //   getToken() {\n    //     return this.token\n    //   }\n    // }\n\n    function makePunctuationRule(type) {\n        return text => {\n            if (text.startsWith(type)) {\n                return { type, text: type };\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== '\\'' && mark !== '\"') {\n            return null;\n        }\n        while (position < text.length) {\n            position++;\n            char = text[position];\n            if (!escaped && char === mark) {\n                position++;\n                break;\n            }\n            escaped = !escaped && char === '\\\\';\n        }\n        if (char !== mark) {\n            throw new Error('Unterminated String');\n        }\n        return text.slice(0, position);\n    }\n    const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    // A hyphen is not technically allowed, but to keep it liberal for now,\n    //  adding it here\n    const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n            return null;\n        }\n        let position = 1;\n        do {\n            char = text[position];\n            if (!identifierContinueRegex.test(char)) {\n                break;\n            }\n            position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n    }\n    // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n    const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    const identifierRule = text => {\n        const value = getIdentifier(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'Identifier',\n            text: value\n        };\n    };\n    function makeKeyWordRule(type) {\n        return text => {\n            if (!text.startsWith(type)) {\n                return null;\n            }\n            const prepends = text[type.length];\n            if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n                return null;\n            }\n            return {\n                type,\n                text: type\n            };\n        };\n    }\n    const stringValueRule = text => {\n        const value = getQuoted(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'StringValue',\n            text: value\n        };\n    };\n    const eofRule = text => {\n        if (text.length > 0) {\n            return null;\n        }\n        return {\n            type: 'EOF',\n            text: ''\n        };\n    };\n    const numberRule = text => {\n        const value = getNumber(text);\n        if (value === null) {\n            return null;\n        }\n        return {\n            type: 'Number',\n            text: value\n        };\n    };\n    const rules = [\n        eofRule,\n        makePunctuationRule('=>'),\n        makePunctuationRule('('),\n        makePunctuationRule(')'),\n        makePunctuationRule('{'),\n        makePunctuationRule('}'),\n        makePunctuationRule('['),\n        makePunctuationRule(']'),\n        makePunctuationRule('|'),\n        makePunctuationRule('&'),\n        makePunctuationRule('<'),\n        makePunctuationRule('>'),\n        makePunctuationRule(','),\n        makePunctuationRule(';'),\n        makePunctuationRule('*'),\n        makePunctuationRule('?'),\n        makePunctuationRule('!'),\n        makePunctuationRule('='),\n        makePunctuationRule(':'),\n        makePunctuationRule('...'),\n        makePunctuationRule('.'),\n        makePunctuationRule('#'),\n        makePunctuationRule('~'),\n        makePunctuationRule('/'),\n        makePunctuationRule('@'),\n        makeKeyWordRule('undefined'),\n        makeKeyWordRule('null'),\n        makeKeyWordRule('function'),\n        makeKeyWordRule('this'),\n        makeKeyWordRule('new'),\n        makeKeyWordRule('module'),\n        makeKeyWordRule('event'),\n        makeKeyWordRule('external'),\n        makeKeyWordRule('typeof'),\n        makeKeyWordRule('keyof'),\n        makeKeyWordRule('readonly'),\n        makeKeyWordRule('import'),\n        makeKeyWordRule('is'),\n        makeKeyWordRule('in'),\n        makeKeyWordRule('asserts'),\n        numberRule,\n        identifierRule,\n        stringValueRule\n    ];\n    const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n    class Lexer {\n        static create(text) {\n            const current = this.read(text);\n            text = current.text;\n            const next = this.read(text);\n            text = next.text;\n            return new Lexer(text, undefined, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n            this.text = '';\n            this.text = text;\n            this.previous = previous;\n            this.current = current;\n            this.next = next;\n        }\n        static read(text, startOfLine = false) {\n            startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n            text = text.trim();\n            for (const rule of rules) {\n                const partial = rule(text);\n                if (partial !== null) {\n                    const token = Object.assign(Object.assign({}, partial), { startOfLine });\n                    text = text.slice(token.text.length);\n                    return { text, token };\n                }\n            }\n            throw new Error('Unexpected Token ' + text);\n        }\n        advance() {\n            const next = Lexer.read(this.text);\n            return new Lexer(next.text, this.current, this.next, next.token);\n        }\n    }\n\n    /**\n     * Throws an error if the provided result is not a {@link RootResult}\n     */\n    function assertRootResult(result) {\n        if (result === undefined) {\n            throw new Error('Unexpected undefined');\n        }\n        if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\n            result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\n            result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\n            result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === 'JsdocTypeKeyValue') {\n            return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n    }\n    function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === 'JsdocTypeName') {\n            return result;\n        }\n        return assertPlainKeyValueResult(result);\n    }\n    function assertPlainKeyValueResult(result) {\n        if (result.type !== 'JsdocTypeKeyValue') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === 'JsdocTypeVariadic') {\n            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n                return result;\n            }\n            throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function isSquaredProperty(result) {\n        return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n    }\n\n    // higher precedence = higher importance\n    var Precedence;\n    (function (Precedence) {\n        Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n        Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n        Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n    })(Precedence || (Precedence = {}));\n\n    class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n            this.grammar = grammar;\n            if (typeof textOrLexer === 'string') {\n                this._lexer = Lexer.create(textOrLexer);\n            }\n            else {\n                this._lexer = textOrLexer;\n            }\n            this.baseParser = baseParser;\n        }\n        get lexer() {\n            return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n            const result = this.parseType(Precedence.ALL);\n            if (this.lexer.current.type !== 'EOF') {\n                throw new EarlyEndOfParseError(this.lexer.current);\n            }\n            return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n            return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n            const result = this.tryParslets(null, precedence);\n            if (result === null) {\n                throw new NoParsletFoundError(this.lexer.current);\n            }\n            return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n            let result = this.tryParslets(left, precedence);\n            while (result !== null) {\n                left = result;\n                result = this.tryParslets(left, precedence);\n            }\n            return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n            for (const parslet of this.grammar) {\n                const result = parslet(this, precedence, left);\n                if (result !== null) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n            if (!Array.isArray(types)) {\n                types = [types];\n            }\n            if (types.includes(this.lexer.current.type)) {\n                this._lexer = this.lexer.advance();\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        acceptLexerState(parser) {\n            this._lexer = parser.lexer;\n        }\n    }\n\n    function isQuestionMarkUnknownType(next) {\n        return next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n    }\n\n    const nullableParslet = (parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\n            ((left != null) && type === '?');\n        if (!accept) {\n            return null;\n        }\n        parser.consume('?');\n        if (left == null) {\n            return {\n                type: 'JsdocTypeNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        }\n        else {\n            return {\n                type: 'JsdocTypeNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    };\n\n    function composeParslet(options) {\n        const parslet = (parser, curPrecedence, left) => {\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            if (left === null) {\n                if ('parsePrefix' in options) {\n                    if (options.accept(type, next)) {\n                        return options.parsePrefix(parser);\n                    }\n                }\n            }\n            else {\n                if ('parseInfix' in options) {\n                    if (options.precedence > curPrecedence && options.accept(type, next)) {\n                        return options.parseInfix(parser, left);\n                    }\n                }\n            }\n            return null;\n        };\n        // for debugging\n        Object.defineProperty(parslet, 'name', {\n            value: options.name\n        });\n        return parslet;\n    }\n\n    const optionalParslet = composeParslet({\n        name: 'optionalParslet',\n        accept: type => type === '=',\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: parser => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: parser.parseType(Precedence.OPTIONAL),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    const numberParslet = composeParslet({\n        name: 'numberParslet',\n        accept: type => type === 'Number',\n        parsePrefix: parser => {\n            const value = parseFloat(parser.lexer.current.text);\n            parser.consume('Number');\n            return {\n                type: 'JsdocTypeNumber',\n                value\n            };\n        }\n    });\n\n    const parenthesisParslet = composeParslet({\n        name: 'parenthesisParslet',\n        accept: type => type === '(',\n        parsePrefix: parser => {\n            parser.consume('(');\n            if (parser.consume(')')) {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: []\n                };\n            }\n            const result = parser.parseIntermediateType(Precedence.ALL);\n            if (!parser.consume(')')) {\n                throw new Error('Unterminated parenthesis');\n            }\n            if (result.type === 'JsdocTypeParameterList') {\n                return result;\n            }\n            else if (result.type === 'JsdocTypeKeyValue') {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: [result]\n                };\n            }\n            return {\n                type: 'JsdocTypeParenthesis',\n                element: assertRootResult(result)\n            };\n        }\n    });\n\n    const specialTypesParslet = composeParslet({\n        name: 'specialTypesParslet',\n        accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\n            type === 'null' || type === 'undefined' || type === '*',\n        parsePrefix: parser => {\n            if (parser.consume('null')) {\n                return {\n                    type: 'JsdocTypeNull'\n                };\n            }\n            if (parser.consume('undefined')) {\n                return {\n                    type: 'JsdocTypeUndefined'\n                };\n            }\n            if (parser.consume('*')) {\n                return {\n                    type: 'JsdocTypeAny'\n                };\n            }\n            if (parser.consume('?')) {\n                return {\n                    type: 'JsdocTypeUnknown'\n                };\n            }\n            throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n        }\n    });\n\n    const notNullableParslet = composeParslet({\n        name: 'notNullableParslet',\n        accept: type => type === '!',\n        precedence: Precedence.NULLABLE,\n        parsePrefix: parser => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n            name: 'parameterListParslet',\n            accept: type => type === ',',\n            precedence: Precedence.PARAMETER_LIST,\n            parseInfix: (parser, left) => {\n                const elements = [\n                    assertPlainKeyValueOrRootResult(left)\n                ];\n                parser.consume(',');\n                do {\n                    try {\n                        const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                        elements.push(assertPlainKeyValueOrRootResult(next));\n                    }\n                    catch (e) {\n                        if (allowTrailingComma && e instanceof NoParsletFoundError) {\n                            break;\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                } while (parser.consume(','));\n                if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n                    throw new Error('Only the last parameter may be a rest parameter');\n                }\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements\n                };\n            }\n        });\n    }\n\n    const genericParslet = composeParslet({\n        name: 'genericParslet',\n        accept: (type, next) => type === '<' || (type === '.' && next === '<'),\n        precedence: Precedence.GENERIC,\n        parseInfix: (parser, left) => {\n            const dot = parser.consume('.');\n            parser.consume('<');\n            const objects = [];\n            do {\n                objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            } while (parser.consume(','));\n            if (!parser.consume('>')) {\n                throw new Error('Unterminated generic parameter list');\n            }\n            return {\n                type: 'JsdocTypeGeneric',\n                left: assertRootResult(left),\n                elements: objects,\n                meta: {\n                    brackets: 'angle',\n                    dot\n                }\n            };\n        }\n    });\n\n    const unionParslet = composeParslet({\n        name: 'unionParslet',\n        accept: type => type === '|',\n        precedence: Precedence.UNION,\n        parseInfix: (parser, left) => {\n            parser.consume('|');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.UNION));\n            } while (parser.consume('|'));\n            return {\n                type: 'JsdocTypeUnion',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n            allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n    ];\n\n    function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }) {\n        return function namePathParslet(parser, precedence, left) {\n            if ((left == null) || precedence >= Precedence.NAME_PATH) {\n                return null;\n            }\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            const accept = (type === '.' && next !== '<') ||\n                (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\n                (allowJsdocNamePaths && (type === '~' || type === '#'));\n            if (!accept) {\n                return null;\n            }\n            let pathType;\n            let brackets = false;\n            if (parser.consume('.')) {\n                pathType = 'property';\n            }\n            else if (parser.consume('[')) {\n                pathType = 'property-brackets';\n                brackets = true;\n            }\n            else if (parser.consume('~')) {\n                pathType = 'inner';\n            }\n            else {\n                parser.consume('#');\n                pathType = 'instance';\n            }\n            const pathParser = pathGrammar !== null\n                ? new Parser(pathGrammar, parser.lexer, parser)\n                : parser;\n            const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n            parser.acceptLexerState(pathParser);\n            let right;\n            switch (parsed.type) {\n                case 'JsdocTypeName':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeNumber':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value.toString(10),\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeStringValue':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: parsed.meta.quote\n                        }\n                    };\n                    break;\n                case 'JsdocTypeSpecialNamePath':\n                    if (parsed.specialType === 'event') {\n                        right = parsed;\n                    }\n                    else {\n                        throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n                    }\n                    break;\n                default:\n                    throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n            }\n            if (brackets && !parser.consume(']')) {\n                const token = parser.lexer.current;\n                throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\n                    `with text '${token.text}'`);\n            }\n            return {\n                type: 'JsdocTypeNamePath',\n                left: assertRootResult(left),\n                right,\n                pathType\n            };\n        };\n    }\n\n    function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n            name: 'nameParslet',\n            accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n            parsePrefix: parser => {\n                const { type, text } = parser.lexer.current;\n                parser.consume(type);\n                return {\n                    type: 'JsdocTypeName',\n                    value: text\n                };\n            }\n        });\n    }\n\n    const stringValueParslet = composeParslet({\n        name: 'stringValueParslet',\n        accept: type => type === 'StringValue',\n        parsePrefix: parser => {\n            const text = parser.lexer.current.text;\n            parser.consume('StringValue');\n            return {\n                type: 'JsdocTypeStringValue',\n                value: text.slice(1, -1),\n                meta: {\n                    quote: text[0] === '\\'' ? 'single' : 'double'\n                }\n            };\n        }\n    });\n\n    function createSpecialNamePathParslet({ pathGrammar, allowedTypes }) {\n        return composeParslet({\n            name: 'specialNamePathParslet',\n            accept: type => allowedTypes.includes(type),\n            parsePrefix: parser => {\n                const type = parser.lexer.current.type;\n                parser.consume(type);\n                if (!parser.consume(':')) {\n                    return {\n                        type: 'JsdocTypeName',\n                        value: type\n                    };\n                }\n                let result;\n                let token = parser.lexer.current;\n                if (parser.consume('StringValue')) {\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value: token.text.slice(1, -1),\n                        specialType: type,\n                        meta: {\n                            quote: token.text[0] === '\\'' ? 'single' : 'double'\n                        }\n                    };\n                }\n                else {\n                    let value = '';\n                    const allowed = ['Identifier', '@', '/'];\n                    while (allowed.some(type => parser.consume(type))) {\n                        value += token.text;\n                        token = parser.lexer.current;\n                    }\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value,\n                        specialType: type,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                }\n                const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n                const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n                parser.acceptLexerState(moduleParser);\n                return assertRootResult(moduleResult);\n            }\n        });\n    }\n\n    const basePathGrammar = [\n        createNameParslet({\n            allowedAdditionalTokens: ['external', 'module']\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar: null\n        })\n    ];\n    const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n            allowedTypes: ['event'],\n            pathGrammar: basePathGrammar\n        })\n    ];\n\n    function getParameters(value) {\n        let parameters;\n        if (value.type === 'JsdocTypeParameterList') {\n            parameters = value.elements;\n        }\n        else if (value.type === 'JsdocTypeParenthesis') {\n            parameters = [value.element];\n        }\n        else {\n            throw new UnexpectedTypeError(value);\n        }\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n    }\n    function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n            throw new Error('No parameter should be named');\n        }\n        return parameters;\n    }\n    function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n            name: 'functionParslet',\n            accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\n            parsePrefix: parser => {\n                const newKeyword = parser.consume('new');\n                parser.consume('function');\n                const hasParenthesis = parser.lexer.current.type === '(';\n                if (!hasParenthesis) {\n                    if (!allowWithoutParenthesis) {\n                        throw new Error('function is missing parameter list');\n                    }\n                    return {\n                        type: 'JsdocTypeName',\n                        value: 'function'\n                    };\n                }\n                let result = {\n                    type: 'JsdocTypeFunction',\n                    parameters: [],\n                    arrow: false,\n                    constructor: newKeyword,\n                    parenthesis: hasParenthesis\n                };\n                const value = parser.parseIntermediateType(Precedence.FUNCTION);\n                if (allowNamedParameters === undefined) {\n                    result.parameters = getUnnamedParameters(value);\n                }\n                else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n                    result = value;\n                    result.constructor = true;\n                    return result;\n                }\n                else {\n                    result.parameters = getParameters(value);\n                    for (const p of result.parameters) {\n                        if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\n                            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n                        }\n                    }\n                }\n                if (parser.consume(':')) {\n                    result.returnType = parser.parseType(Precedence.PREFIX);\n                }\n                else {\n                    if (!allowNoReturnType) {\n                        throw new Error('function is missing return type');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n            name: 'variadicParslet',\n            accept: type => type === '...',\n            precedence: Precedence.PREFIX,\n            parsePrefix: parser => {\n                parser.consume('...');\n                const brackets = allowEnclosingBrackets && parser.consume('[');\n                try {\n                    const element = parser.parseType(Precedence.PREFIX);\n                    if (brackets && !parser.consume(']')) {\n                        throw new Error('Unterminated variadic type. Missing \\']\\'');\n                    }\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(element),\n                        meta: {\n                            position: 'prefix',\n                            squareBrackets: brackets\n                        }\n                    };\n                }\n                catch (e) {\n                    if (e instanceof NoParsletFoundError) {\n                        if (brackets) {\n                            throw new Error('Empty square brackets for variadic are not allowed.');\n                        }\n                        return {\n                            type: 'JsdocTypeVariadic',\n                            meta: {\n                                position: undefined,\n                                squareBrackets: false\n                            }\n                        };\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            },\n            parseInfix: allowPostfix\n                ? (parser, left) => {\n                    parser.consume('...');\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(left),\n                        meta: {\n                            position: 'suffix',\n                            squareBrackets: false\n                        }\n                    };\n                }\n                : undefined\n        });\n    }\n\n    const symbolParslet = composeParslet({\n        name: 'symbolParslet',\n        accept: type => type === '(',\n        precedence: Precedence.SYMBOL,\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n            }\n            parser.consume('(');\n            const result = {\n                type: 'JsdocTypeSymbol',\n                value: left.value\n            };\n            if (!parser.consume(')')) {\n                const next = parser.parseIntermediateType(Precedence.SYMBOL);\n                result.element = assertNumberOrVariadicNameResult(next);\n                if (!parser.consume(')')) {\n                    throw new Error('Symbol does not end after value');\n                }\n            }\n            return result;\n        }\n    });\n\n    const arrayBracketsParslet = composeParslet({\n        name: 'arrayBracketsParslet',\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: (type, next) => type === '[' && next === ']',\n        parseInfix: (parser, left) => {\n            parser.consume('[');\n            parser.consume(']');\n            return {\n                type: 'JsdocTypeGeneric',\n                left: {\n                    type: 'JsdocTypeName',\n                    value: 'Array'\n                },\n                elements: [\n                    assertRootResult(left)\n                ],\n                meta: {\n                    brackets: 'square',\n                    dot: false\n                }\n            };\n        }\n    });\n\n    function createObjectParslet({ objectFieldGrammar, allowKeyTypes }) {\n        return composeParslet({\n            name: 'objectParslet',\n            accept: type => type === '{',\n            parsePrefix: parser => {\n                parser.consume('{');\n                const result = {\n                    type: 'JsdocTypeObject',\n                    meta: {\n                        separator: 'comma'\n                    },\n                    elements: []\n                };\n                if (!parser.consume('}')) {\n                    let separator;\n                    const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n                    while (true) {\n                        fieldParser.acceptLexerState(parser);\n                        let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                        parser.acceptLexerState(fieldParser);\n                        if (field === undefined && allowKeyTypes) {\n                            field = parser.parseIntermediateType(Precedence.OBJECT);\n                        }\n                        let optional = false;\n                        if (field.type === 'JsdocTypeNullable') {\n                            optional = true;\n                            field = field.element;\n                        }\n                        if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n                            let quote;\n                            if (field.type === 'JsdocTypeStringValue') {\n                                quote = field.meta.quote;\n                            }\n                            result.elements.push({\n                                type: 'JsdocTypeObjectField',\n                                key: field.value.toString(),\n                                right: undefined,\n                                optional,\n                                readonly: false,\n                                meta: {\n                                    quote\n                                }\n                            });\n                        }\n                        else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                            result.elements.push(field);\n                        }\n                        else {\n                            throw new UnexpectedTypeError(field);\n                        }\n                        if (parser.lexer.current.startOfLine) {\n                            separator = 'linebreak';\n                        }\n                        else if (parser.consume(',')) {\n                            separator = 'comma';\n                        }\n                        else if (parser.consume(';')) {\n                            separator = 'semicolon';\n                        }\n                        else {\n                            break;\n                        }\n                        const type = parser.lexer.current.type;\n                        if (type === '}') {\n                            break;\n                        }\n                    }\n                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n                    if (!parser.consume('}')) {\n                        throw new Error('Unterminated record type. Missing \\'}\\'');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n            name: 'objectFieldParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                var _a;\n                let optional = false;\n                let readonlyProperty = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n                    readonlyProperty = true;\n                    left = left.element;\n                }\n                // object parslet uses a special grammar and for the value we want to switch back to the parent\n                const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n                parentParser.acceptLexerState(parser);\n                if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\n                    isSquaredProperty(left)) {\n                    if (isSquaredProperty(left) && !allowSquaredProperties) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    let quote;\n                    if (left.type === 'JsdocTypeStringValue') {\n                        quote = left.meta.quote;\n                    }\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeObjectField',\n                        key: isSquaredProperty(left) ? left : left.value.toString(),\n                        right,\n                        optional,\n                        readonly: readonlyProperty,\n                        meta: {\n                            quote\n                        }\n                    };\n                }\n                else {\n                    if (!allowKeyTypes) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeJsdocObjectField',\n                        left: assertRootResult(left),\n                        right\n                    };\n                }\n            }\n        });\n    }\n\n    function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n            name: 'keyValueParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                let optional = false;\n                let variadic = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n                    variadic = true;\n                    left = left.element;\n                }\n                if (left.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(left);\n                }\n                parser.consume(':');\n                const right = parser.parseType(Precedence.KEY_VALUE);\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: left.value,\n                    right,\n                    optional,\n                    variadic\n                };\n            }\n        });\n    }\n\n    const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n            allowedTypes: ['module', 'external', 'event'],\n            pathGrammar\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: true,\n            allowPostfix: true\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        })\n    ];\n    const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n            // we leave out the object type deliberately\n            objectFieldGrammar: [\n                createNameParslet({\n                    allowedAdditionalTokens: ['module', 'in']\n                }),\n                createObjectFieldParslet({\n                    allowSquaredProperties: false,\n                    allowKeyTypes: true,\n                    allowOptional: false,\n                    allowReadonly: false\n                }),\n                ...jsdocBaseGrammar\n            ],\n            allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n            allowOptional: true,\n            allowVariadic: true\n        })\n    ];\n\n    const typeOfParslet = composeParslet({\n        name: 'typeOfParslet',\n        accept: type => type === 'typeof',\n        parsePrefix: parser => {\n            parser.consume('typeof');\n            return {\n                type: 'JsdocTypeTypeof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const objectFieldGrammar$1 = [\n        createNameParslet({\n            allowedAdditionalTokens: ['module', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: false,\n            allowKeyTypes: false,\n            allowOptional: false,\n            allowReadonly: false\n        })\n    ];\n    const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: false,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        }),\n        createKeyValueParslet({\n            allowOptional: false,\n            allowVariadic: false\n        }),\n        symbolParslet\n    ];\n\n    const assertsParslet = composeParslet({\n        name: 'assertsParslet',\n        accept: type => type === 'asserts',\n        parsePrefix: (parser) => {\n            parser.consume('asserts');\n            const left = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypeAsserts',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n            name: 'tupleParslet',\n            accept: type => type === '[',\n            parsePrefix: parser => {\n                parser.consume('[');\n                const result = {\n                    type: 'JsdocTypeTuple',\n                    elements: []\n                };\n                if (parser.consume(']')) {\n                    return result;\n                }\n                const typeList = parser.parseIntermediateType(Precedence.ALL);\n                if (typeList.type === 'JsdocTypeParameterList') {\n                    if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n                        result.elements = typeList.elements.map(assertPlainKeyValueResult);\n                    }\n                    else {\n                        result.elements = typeList.elements.map(assertRootResult);\n                    }\n                }\n                else {\n                    if (typeList.type === 'JsdocTypeKeyValue') {\n                        result.elements = [assertPlainKeyValueResult(typeList)];\n                    }\n                    else {\n                        result.elements = [assertRootResult(typeList)];\n                    }\n                }\n                if (!parser.consume(']')) {\n                    throw new Error('Unterminated \\'[\\'');\n                }\n                if (!allowQuestionMark && result.elements.some((e) => e.type === 'JsdocTypeUnknown')) {\n                    throw new Error('Question mark in tuple not allowed');\n                }\n                return result;\n            }\n        });\n    }\n\n    const keyOfParslet = composeParslet({\n        name: 'keyOfParslet',\n        accept: type => type === 'keyof',\n        parsePrefix: parser => {\n            parser.consume('keyof');\n            return {\n                type: 'JsdocTypeKeyof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const importParslet = composeParslet({\n        name: 'importParslet',\n        accept: type => type === 'import',\n        parsePrefix: parser => {\n            parser.consume('import');\n            if (!parser.consume('(')) {\n                throw new Error('Missing parenthesis after import keyword');\n            }\n            const path = parser.parseType(Precedence.PREFIX);\n            if (path.type !== 'JsdocTypeStringValue') {\n                throw new Error('Only string values are allowed as paths for imports');\n            }\n            if (!parser.consume(')')) {\n                throw new Error('Missing closing parenthesis after import keyword');\n            }\n            return {\n                type: 'JsdocTypeImport',\n                element: path\n            };\n        }\n    });\n\n    const readonlyPropertyParslet = composeParslet({\n        name: 'readonlyPropertyParslet',\n        accept: type => type === 'readonly',\n        parsePrefix: parser => {\n            parser.consume('readonly');\n            return {\n                type: 'JsdocTypeReadonlyProperty',\n                element: parser.parseType(Precedence.KEY_VALUE)\n            };\n        }\n    });\n\n    const arrowFunctionParslet = composeParslet({\n        name: 'arrowFunctionParslet',\n        precedence: Precedence.ARROW,\n        accept: type => type === '=>',\n        parseInfix: (parser, left) => {\n            parser.consume('=>');\n            return {\n                type: 'JsdocTypeFunction',\n                parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n                arrow: true,\n                constructor: false,\n                parenthesis: true,\n                returnType: parser.parseType(Precedence.OBJECT)\n            };\n        }\n    });\n\n    const intersectionParslet = composeParslet({\n        name: 'intersectionParslet',\n        accept: type => type === '&',\n        precedence: Precedence.INTERSECTION,\n        parseInfix: (parser, left) => {\n            parser.consume('&');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.INTERSECTION));\n            } while (parser.consume('&'));\n            return {\n                type: 'JsdocTypeIntersection',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const predicateParslet = composeParslet({\n        name: 'predicateParslet',\n        precedence: Precedence.INFIX,\n        accept: type => type === 'is',\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypePredicate',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    const objectSquaredPropertyParslet = composeParslet({\n        name: 'objectSquareBracketPropertyParslet',\n        accept: type => type === '[',\n        parsePrefix: parser => {\n            if (parser.baseParser === undefined) {\n                throw new Error('Only allowed inside object grammar');\n            }\n            parser.consume('[');\n            const key = parser.lexer.current.text;\n            parser.consume('Identifier');\n            let result;\n            if (parser.consume(':')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeIndexSignature',\n                    key,\n                    right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else if (parser.consume('in')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeMappedType',\n                    key,\n                    right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else {\n                throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n            }\n            if (!parser.consume(']')) {\n                throw new Error('Unterminated square brackets');\n            }\n            return result;\n        }\n    });\n\n    const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['module', 'event', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: true,\n            allowKeyTypes: false,\n            allowOptional: true,\n            allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n    ];\n    const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar\n        }),\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNoReturnType: false,\n            allowNamedParameters: ['this', 'new', 'args'],\n            allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n            allowQuestionMark: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        assertsParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: true,\n            allowJsdocNamePaths: false,\n            pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n            allowVariadic: true,\n            allowOptional: true\n        })\n    ];\n\n    /**\n     * This function parses the given expression in the given mode and produces a {@link RootResult}.\n     * @param expression\n     * @param mode\n     */\n    function parse(expression, mode) {\n        switch (mode) {\n            case 'closure':\n                return (new Parser(closureGrammar, expression)).parse();\n            case 'jsdoc':\n                return (new Parser(jsdocGrammar, expression)).parse();\n            case 'typescript':\n                return (new Parser(typescriptGrammar, expression)).parse();\n        }\n    }\n    /**\n     * This function tries to parse the given expression in multiple modes and returns the first successful\n     * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n     * no mode was successful it throws the error that was produced by the last parsing attempt.\n     * @param expression\n     * @param modes\n     */\n    function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\n        let error;\n        for (const mode of modes) {\n            try {\n                return parse(expression, mode);\n            }\n            catch (e) {\n                error = e;\n            }\n        }\n        throw error;\n    }\n\n    function transform(rules, parseResult) {\n        const rule = rules[parseResult.type];\n        if (rule === undefined) {\n            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, aParseResult => transform(rules, aParseResult));\n    }\n    function notAvailableTransform(parseResult) {\n        throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n    }\n    function extractSpecialParams(source) {\n        const result = {\n            params: []\n        };\n        for (const param of source.parameters) {\n            if (param.type === 'JsdocTypeKeyValue') {\n                if (param.key === 'this') {\n                    result.this = param.right;\n                }\n                else if (param.key === 'new') {\n                    result.new = param.right;\n                }\n                else {\n                    result.params.push(param);\n                }\n            }\n            else {\n                result.params.push(param);\n            }\n        }\n        return result;\n    }\n\n    function applyPosition(position, target, value) {\n        return position === 'prefix' ? value + target : target + value;\n    }\n    function quote(value, quote) {\n        switch (quote) {\n            case 'double':\n                return `\"${value}\"`;\n            case 'single':\n                return `'${value}'`;\n            case undefined:\n                return value;\n        }\n    }\n    function stringifyRules() {\n        return {\n            JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n            JsdocTypeFunction: (result, transform) => {\n                if (!result.arrow) {\n                    let stringified = result.constructor ? 'new' : 'function';\n                    if (!result.parenthesis) {\n                        return stringified;\n                    }\n                    stringified += `(${result.parameters.map(transform).join(', ')})`;\n                    if (result.returnType !== undefined) {\n                        stringified += `: ${transform(result.returnType)}`;\n                    }\n                    return stringified;\n                }\n                else {\n                    if (result.returnType === undefined) {\n                        throw new Error('Arrow function needs a return type.');\n                    }\n                    let stringified = `(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n                    if (result.constructor) {\n                        stringified = 'new ' + stringified;\n                    }\n                    return stringified;\n                }\n            },\n            JsdocTypeName: result => result.value,\n            JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n            JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\n                ? '...'\n                : applyPosition(result.meta.position, transform(result.element), '...'),\n            JsdocTypeNamePath: (result, transform) => {\n                const left = transform(result.left);\n                const right = transform(result.right);\n                switch (result.pathType) {\n                    case 'inner':\n                        return `${left}~${right}`;\n                    case 'instance':\n                        return `${left}#${right}`;\n                    case 'property':\n                        return `${left}.${right}`;\n                    case 'property-brackets':\n                        return `${left}[${right}]`;\n                }\n            },\n            JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n            JsdocTypeAny: () => '*',\n            JsdocTypeGeneric: (result, transform) => {\n                if (result.meta.brackets === 'square') {\n                    const element = result.elements[0];\n                    const transformed = transform(element);\n                    if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n                        return `(${transformed})[]`;\n                    }\n                    else {\n                        return `${transformed}[]`;\n                    }\n                }\n                else {\n                    return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.elements.map(transform).join(', ')}>`;\n                }\n            },\n            JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n            JsdocTypeObjectField: (result, transform) => {\n                let text = '';\n                if (result.readonly) {\n                    text += 'readonly ';\n                }\n                if (typeof result.key === 'string') {\n                    text += quote(result.key, result.meta.quote);\n                }\n                else {\n                    text += transform(result.key);\n                }\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeJsdocObjectField: (result, transform) => {\n                return `${transform(result.left)}: ${transform(result.right)}`;\n            },\n            JsdocTypeKeyValue: (result, transform) => {\n                let text = result.key;\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.variadic) {\n                    text = '...' + text;\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n            JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n            JsdocTypeNull: () => 'null',\n            JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n            JsdocTypeNumber: result => result.value.toString(),\n            JsdocTypeObject: (result, transform) => `{${result.elements.map(transform).join((result.meta.separator === 'comma' ? ',' : ';') + ' ')}}`,\n            JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n            JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n            JsdocTypeUndefined: () => 'undefined',\n            JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n            JsdocTypeUnknown: () => '?',\n            JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n            JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n            JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n            JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n            JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n            JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`\n        };\n    }\n    const storedStringifyRules = stringifyRules();\n    function stringify(result) {\n        return transform(storedStringifyRules, result);\n    }\n\n    const reservedWords = [\n        'null',\n        'true',\n        'false',\n        'break',\n        'case',\n        'catch',\n        'class',\n        'const',\n        'continue',\n        'debugger',\n        'default',\n        'delete',\n        'do',\n        'else',\n        'export',\n        'extends',\n        'finally',\n        'for',\n        'function',\n        'if',\n        'import',\n        'in',\n        'instanceof',\n        'new',\n        'return',\n        'super',\n        'switch',\n        'this',\n        'throw',\n        'try',\n        'typeof',\n        'var',\n        'void',\n        'while',\n        'with',\n        'yield'\n    ];\n    function makeName(value) {\n        const result = {\n            type: 'NameExpression',\n            name: value\n        };\n        if (reservedWords.includes(value)) {\n            result.reservedWord = true;\n        }\n        return result;\n    }\n    const catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.optional = true;\n            return transformed;\n        },\n        JsdocTypeNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = true;\n            return transformed;\n        },\n        JsdocTypeNotNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = false;\n            return transformed;\n        },\n        JsdocTypeVariadic: (result, transform) => {\n            if (result.element === undefined) {\n                throw new Error('dots without value are not allowed in catharsis mode');\n            }\n            const transformed = transform(result.element);\n            transformed.repeatable = true;\n            return transformed;\n        },\n        JsdocTypeAny: () => ({\n            type: 'AllLiteral'\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NullLiteral'\n        }),\n        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n            type: 'UndefinedLiteral'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UnknownLiteral'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const params = extractSpecialParams(result);\n            const transformed = {\n                type: 'FunctionType',\n                params: params.params.map(transform)\n            };\n            if (params.this !== undefined) {\n                transformed.this = transform(params.this);\n            }\n            if (params.new !== undefined) {\n                transformed.new = transform(params.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.result = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => ({\n            type: 'TypeApplication',\n            applications: result.elements.map(o => transform(o)),\n            expression: transform(result.left)\n        }),\n        JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n        JsdocTypeName: result => {\n            if (result.value !== 'function') {\n                return makeName(result.value);\n            }\n            else {\n                return {\n                    type: 'FunctionType',\n                    params: []\n                };\n            }\n        },\n        JsdocTypeNumber: result => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform) => {\n            const transformed = {\n                type: 'RecordType',\n                fields: []\n            };\n            for (const field of result.elements) {\n                if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n                    transformed.fields.push({\n                        type: 'FieldType',\n                        key: transform(field),\n                        value: undefined\n                    });\n                }\n                else {\n                    transformed.fields.push(transform(field));\n                }\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            return {\n                type: 'FieldType',\n                key: makeName(quote(result.key, result.meta.quote)),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeJsdocObjectField: (result, transform) => ({\n            type: 'FieldType',\n            key: transform(result.left),\n            value: transform(result.right)\n        }),\n        JsdocTypeUnion: (result, transform) => ({\n            type: 'TypeUnion',\n            elements: result.elements.map(e => transform(e))\n        }),\n        JsdocTypeKeyValue: (result, transform) => {\n            return {\n                type: 'FieldType',\n                key: makeName(result.key),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            const leftResult = transform(result.left);\n            let rightValue;\n            if (result.right.type === 'JsdocTypeSpecialNamePath') {\n                rightValue = transform(result.right).name;\n            }\n            else {\n                rightValue = quote(result.right.value, result.right.meta.quote);\n            }\n            const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n            return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: result => {\n            let value = '';\n            let element = result.element;\n            let trailingDots = false;\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n                if (element.meta.position === 'prefix') {\n                    value = '...';\n                }\n                else {\n                    trailingDots = true;\n                }\n                element = element.element;\n            }\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n                value += element.value;\n            }\n            else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n                value += element.value.toString();\n            }\n            if (trailingDots) {\n                value += '...';\n            }\n            return makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform\n    };\n    function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n    }\n\n    function getQuoteStyle(quote) {\n        switch (quote) {\n            case undefined:\n                return 'none';\n            case 'single':\n                return 'single';\n            case 'double':\n                return 'double';\n        }\n    }\n    function getMemberType(type) {\n        switch (type) {\n            case 'inner':\n                return 'INNER_MEMBER';\n            case 'instance':\n                return 'INSTANCE_MEMBER';\n            case 'property':\n                return 'MEMBER';\n            case 'property-brackets':\n                return 'MEMBER';\n        }\n    }\n    function nestResults(type, results) {\n        if (results.length === 2) {\n            return {\n                type,\n                left: results[0],\n                right: results[1]\n            };\n        }\n        else {\n            return {\n                type,\n                left: results[0],\n                right: nestResults(type, results.slice(1))\n            };\n        }\n    }\n    const jtpRules = {\n        JsdocTypeOptional: (result, transform) => ({\n            type: 'OPTIONAL',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n            }\n        }),\n        JsdocTypeNullable: (result, transform) => ({\n            type: 'NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n            }\n        }),\n        JsdocTypeNotNullable: (result, transform) => ({\n            type: 'NOT_NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n            }\n        }),\n        JsdocTypeVariadic: (result, transform) => {\n            const transformed = {\n                type: 'VARIADIC',\n                meta: {\n                    syntax: result.meta.position === 'prefix'\n                        ? 'PREFIX_DOTS'\n                        : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n                }\n            };\n            if (result.element !== undefined) {\n                transformed.value = transform(result.element);\n            }\n            return transformed;\n        },\n        JsdocTypeName: result => ({\n            type: 'NAME',\n            name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform) => ({\n            type: 'TYPE_QUERY',\n            name: transform(result.element)\n        }),\n        JsdocTypeTuple: (result, transform) => ({\n            type: 'TUPLE',\n            entries: result.elements.map(transform)\n        }),\n        JsdocTypeKeyof: (result, transform) => ({\n            type: 'KEY_QUERY',\n            value: transform(result.element)\n        }),\n        JsdocTypeImport: result => ({\n            type: 'IMPORT',\n            path: {\n                type: 'STRING_VALUE',\n                quoteStyle: getQuoteStyle(result.element.meta.quote),\n                string: result.element.value\n            }\n        }),\n        JsdocTypeUndefined: () => ({\n            type: 'NAME',\n            name: 'undefined'\n        }),\n        JsdocTypeAny: () => ({\n            type: 'ANY'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const specialParams = extractSpecialParams(result);\n            const transformed = {\n                type: result.arrow ? 'ARROW' : 'FUNCTION',\n                params: specialParams.params.map(param => {\n                    if (param.type === 'JsdocTypeKeyValue') {\n                        if (param.right === undefined) {\n                            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n                        }\n                        return {\n                            type: 'NAMED_PARAMETER',\n                            name: param.key,\n                            typeName: transform(param.right)\n                        };\n                    }\n                    else {\n                        return transform(param);\n                    }\n                }),\n                new: null,\n                returns: null\n            };\n            if (specialParams.this !== undefined) {\n                transformed.this = transform(specialParams.this);\n            }\n            else if (!result.arrow) {\n                transformed.this = null;\n            }\n            if (specialParams.new !== undefined) {\n                transformed.new = transform(specialParams.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.returns = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => {\n            const transformed = {\n                type: 'GENERIC',\n                subject: transform(result.left),\n                objects: result.elements.map(transform),\n                meta: {\n                    syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n                }\n            };\n            if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n                transformed.objects[0] = {\n                    type: 'NAME',\n                    name: 'function'\n                };\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key.toString(),\n                quoteStyle: getQuoteStyle(result.meta.quote),\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeJsdocObjectField: () => {\n            throw new Error('Keys may not be typed in jsdoctypeparser.');\n        },\n        JsdocTypeKeyValue: (result, transform) => {\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: 'none',\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key,\n                quoteStyle: 'none',\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeObject: (result, transform) => {\n            const entries = [];\n            for (const field of result.elements) {\n                if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                    entries.push(transform(field));\n                }\n            }\n            return {\n                type: 'RECORD',\n                entries\n            };\n        },\n        JsdocTypeSpecialNamePath: result => {\n            if (result.specialType !== 'module') {\n                throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n            }\n            return {\n                type: 'MODULE',\n                value: {\n                    type: 'FILE_PATH',\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    path: result.value\n                }\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            let hasEventPrefix = false;\n            let name;\n            let quoteStyle;\n            if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n                hasEventPrefix = true;\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            else {\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            const transformed = {\n                type: getMemberType(result.pathType),\n                owner: transform(result.left),\n                name,\n                quoteStyle,\n                hasEventPrefix\n            };\n            if (transformed.owner.type === 'MODULE') {\n                const tModule = transformed.owner;\n                transformed.owner = transformed.owner.value;\n                tModule.value = transformed;\n                return tModule;\n            }\n            else {\n                return transformed;\n            }\n        },\n        JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n        JsdocTypeParenthesis: (result, transform) => ({\n            type: 'PARENTHESIS',\n            value: transform(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NAME',\n            name: 'null'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UNKNOWN'\n        }),\n        JsdocTypeStringValue: result => ({\n            type: 'STRING_VALUE',\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n        JsdocTypeNumber: result => ({\n            type: 'NUMBER_VALUE',\n            number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform\n    };\n    function jtpTransform(result) {\n        return transform(jtpRules, result);\n    }\n\n    function identityTransformRules() {\n        return {\n            JsdocTypeIntersection: (result, transform) => ({\n                type: 'JsdocTypeIntersection',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeGeneric: (result, transform) => ({\n                type: 'JsdocTypeGeneric',\n                left: transform(result.left),\n                elements: result.elements.map(transform),\n                meta: {\n                    dot: result.meta.dot,\n                    brackets: result.meta.brackets\n                }\n            }),\n            JsdocTypeNullable: result => result,\n            JsdocTypeUnion: (result, transform) => ({\n                type: 'JsdocTypeUnion',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeUnknown: result => result,\n            JsdocTypeUndefined: result => result,\n            JsdocTypeTypeof: (result, transform) => ({\n                type: 'JsdocTypeTypeof',\n                element: transform(result.element)\n            }),\n            JsdocTypeSymbol: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeSymbol',\n                    value: result.value\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeOptional: (result, transform) => ({\n                type: 'JsdocTypeOptional',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeObject: (result, transform) => ({\n                type: 'JsdocTypeObject',\n                meta: {\n                    separator: 'comma'\n                },\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeNumber: result => result,\n            JsdocTypeNull: result => result,\n            JsdocTypeNotNullable: (result, transform) => ({\n                type: 'JsdocTypeNotNullable',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeSpecialNamePath: result => result,\n            JsdocTypeObjectField: (result, transform) => ({\n                type: 'JsdocTypeObjectField',\n                key: result.key,\n                right: result.right === undefined ? undefined : transform(result.right),\n                optional: result.optional,\n                readonly: result.readonly,\n                meta: result.meta\n            }),\n            JsdocTypeJsdocObjectField: (result, transform) => ({\n                type: 'JsdocTypeJsdocObjectField',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeKeyValue: (result, transform) => {\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: result.key,\n                    right: result.right === undefined ? undefined : transform(result.right),\n                    optional: result.optional,\n                    variadic: result.variadic\n                };\n            },\n            JsdocTypeImport: (result, transform) => ({\n                type: 'JsdocTypeImport',\n                element: transform(result.element)\n            }),\n            JsdocTypeAny: result => result,\n            JsdocTypeStringValue: result => result,\n            JsdocTypeNamePath: result => result,\n            JsdocTypeVariadic: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeVariadic',\n                    meta: {\n                        position: result.meta.position,\n                        squareBrackets: result.meta.squareBrackets\n                    }\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeTuple: (result, transform) => ({\n                type: 'JsdocTypeTuple',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeName: result => result,\n            JsdocTypeFunction: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeFunction',\n                    arrow: result.arrow,\n                    parameters: result.parameters.map(transform),\n                    constructor: result.constructor,\n                    parenthesis: result.parenthesis\n                };\n                if (result.returnType !== undefined) {\n                    transformed.returnType = transform(result.returnType);\n                }\n                return transformed;\n            },\n            JsdocTypeKeyof: (result, transform) => ({\n                type: 'JsdocTypeKeyof',\n                element: transform(result.element)\n            }),\n            JsdocTypeParenthesis: (result, transform) => ({\n                type: 'JsdocTypeParenthesis',\n                element: transform(result.element)\n            }),\n            JsdocTypeProperty: result => result,\n            JsdocTypePredicate: (result, transform) => ({\n                type: 'JsdocTypePredicate',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeIndexSignature: (result, transform) => ({\n                type: 'JsdocTypeIndexSignature',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeMappedType: (result, transform) => ({\n                type: 'JsdocTypeMappedType',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeAsserts: (result, transform) => ({\n                type: 'JsdocTypeAsserts',\n                left: transform(result.left),\n                right: transform(result.right)\n            })\n        };\n    }\n\n    const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: ['parameters', 'returnType'],\n        JsdocTypeGeneric: ['left', 'elements'],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: ['right'],\n        JsdocTypeIntersection: ['elements'],\n        JsdocTypeKeyof: ['element'],\n        JsdocTypeKeyValue: ['right'],\n        JsdocTypeMappedType: ['right'],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: ['left', 'right'],\n        JsdocTypeNotNullable: ['element'],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: ['element'],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: ['elements'],\n        JsdocTypeObjectField: ['right'],\n        JsdocTypeJsdocObjectField: ['left', 'right'],\n        JsdocTypeOptional: ['element'],\n        JsdocTypeParenthesis: ['element'],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: ['element'],\n        JsdocTypeTuple: ['elements'],\n        JsdocTypeTypeof: ['element'],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: ['elements'],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: ['element'],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: ['left', 'right'],\n        JsdocTypeAsserts: ['left', 'right']\n    };\n\n    function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n            const value = node[key];\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    for (const element of value) {\n                        _traverse(element, node, key, onEnter, onLeave);\n                    }\n                }\n                else {\n                    _traverse(value, node, key, onEnter, onLeave);\n                }\n            }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n    }\n    /**\n     * A function to traverse an AST. It traverses it depth first.\n     * @param node the node to start traversing at.\n     * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n     * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n     */\n    function traverse(node, onEnter, onLeave) {\n        _traverse(node, undefined, undefined, onEnter, onLeave);\n    }\n\n    exports.catharsisTransform = catharsisTransform;\n    exports.identityTransformRules = identityTransformRules;\n    exports.jtpTransform = jtpTransform;\n    exports.parse = parse;\n    exports.stringify = stringify;\n    exports.stringifyRules = stringifyRules;\n    exports.transform = transform;\n    exports.traverse = traverse;\n    exports.tryParse = tryParse;\n    exports.visitorKeys = visitorKeys;\n\n}));\n"],"mappings":"AAAA,CAAC,UAAUA,MAAM,EAAEC,OAAO,EAAE;EACxB,OAAOC,OAAO,KAAK,QAAQ,IAAI,OAAOC,MAAM,KAAK,WAAW,GAAGF,OAAO,CAACC,OAAO,CAAC,GAC/E,OAAOE,MAAM,KAAK,UAAU,IAAIA,MAAM,CAACC,GAAG,GAAGD,MAAM,CAAC,CAAC,SAAS,CAAC,EAAEH,OAAO,CAAC,IACxED,MAAM,GAAG,OAAOM,UAAU,KAAK,WAAW,GAAGA,UAAU,GAAGN,MAAM,IAAIO,IAAI,EAAEN,OAAO,CAACD,MAAM,CAACQ,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC;AACzG,CAAC,EAAE,IAAI,EAAG,UAAUN,OAAO,EAAE;EAAE,YAAY;;EAEvC,SAASO,aAAaA,CAACC,KAAK,EAAE;IAC1B,IAAIA,KAAK,CAACC,IAAI,KAAKC,SAAS,IAAIF,KAAK,CAACC,IAAI,KAAK,EAAE,EAAE;MAC/C,OAAO,IAAID,KAAK,CAACG,IAAI,iBAAiBH,KAAK,CAACC,IAAI,GAAG;IACvD,CAAC,MACI;MACD,OAAO,IAAID,KAAK,CAACG,IAAI,GAAG;IAC5B;EACJ;EACA,MAAMC,mBAAmB,SAASC,KAAK,CAAC;IACpCC,WAAWA,CAACN,KAAK,EAAE;MACf,KAAK,CAAC,+BAA+BD,aAAa,CAACC,KAAK,CAAC,EAAE,CAAC;MAC5D,IAAI,CAACA,KAAK,GAAGA,KAAK;MAClBO,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEJ,mBAAmB,CAACK,SAAS,CAAC;IAC9D;IACAC,QAAQA,CAAA,EAAG;MACP,OAAO,IAAI,CAACV,KAAK;IACrB;EACJ;EACA,MAAMW,oBAAoB,SAASN,KAAK,CAAC;IACrCC,WAAWA,CAACN,KAAK,EAAE;MACf,KAAK,CAAC,gDAAgDD,aAAa,CAACC,KAAK,CAAC,EAAE,CAAC;MAC7E,IAAI,CAACA,KAAK,GAAGA,KAAK;MAClBO,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEG,oBAAoB,CAACF,SAAS,CAAC;IAC/D;IACAC,QAAQA,CAAA,EAAG;MACP,OAAO,IAAI,CAACV,KAAK;IACrB;EACJ;EACA,MAAMY,mBAAmB,SAASP,KAAK,CAAC;IACpCC,WAAWA,CAACO,MAAM,EAAEC,OAAO,EAAE;MACzB,IAAIC,KAAK,GAAG,qBAAqBF,MAAM,CAACV,IAAI,IAAI;MAChD,IAAIW,OAAO,KAAKZ,SAAS,EAAE;QACvBa,KAAK,IAAI,aAAaD,OAAO,EAAE;MACnC;MACA,KAAK,CAACC,KAAK,CAAC;MACZR,MAAM,CAACC,cAAc,CAAC,IAAI,EAAEI,mBAAmB,CAACH,SAAS,CAAC;IAC9D;EACJ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,SAASO,mBAAmBA,CAACb,IAAI,EAAE;IAC/B,OAAOF,IAAI,IAAI;MACX,IAAIA,IAAI,CAACgB,UAAU,CAACd,IAAI,CAAC,EAAE;QACvB,OAAO;UAAEA,IAAI;UAAEF,IAAI,EAAEE;QAAK,CAAC;MAC/B,CAAC,MACI;QACD,OAAO,IAAI;MACf;IACJ,CAAC;EACL;EACA,SAASe,SAASA,CAACjB,IAAI,EAAE;IACrB,IAAIkB,QAAQ,GAAG,CAAC;IAChB,IAAIC,IAAI;IACR,MAAMC,IAAI,GAAGpB,IAAI,CAAC,CAAC,CAAC;IACpB,IAAIqB,OAAO,GAAG,KAAK;IACnB,IAAID,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAK,GAAG,EAAE;MAC/B,OAAO,IAAI;IACf;IACA,OAAOF,QAAQ,GAAGlB,IAAI,CAACsB,MAAM,EAAE;MAC3BJ,QAAQ,EAAE;MACVC,IAAI,GAAGnB,IAAI,CAACkB,QAAQ,CAAC;MACrB,IAAI,CAACG,OAAO,IAAIF,IAAI,KAAKC,IAAI,EAAE;QAC3BF,QAAQ,EAAE;QACV;MACJ;MACAG,OAAO,GAAG,CAACA,OAAO,IAAIF,IAAI,KAAK,IAAI;IACvC;IACA,IAAIA,IAAI,KAAKC,IAAI,EAAE;MACf,MAAM,IAAIhB,KAAK,CAAC,qBAAqB,CAAC;IAC1C;IACA,OAAOJ,IAAI,CAACuB,KAAK,CAAC,CAAC,EAAEL,QAAQ,CAAC;EAClC;EACA,MAAMM,oBAAoB,GAAG,0FAA0F;EACvH;EACA;EACA,MAAMC,uBAAuB,GAAG,0GAA0G;EAC1I,SAASC,aAAaA,CAAC1B,IAAI,EAAE;IACzB,IAAImB,IAAI,GAAGnB,IAAI,CAAC,CAAC,CAAC;IAClB,IAAI,CAACwB,oBAAoB,CAACG,IAAI,CAACR,IAAI,CAAC,EAAE;MAClC,OAAO,IAAI;IACf;IACA,IAAID,QAAQ,GAAG,CAAC;IAChB,GAAG;MACCC,IAAI,GAAGnB,IAAI,CAACkB,QAAQ,CAAC;MACrB,IAAI,CAACO,uBAAuB,CAACE,IAAI,CAACR,IAAI,CAAC,EAAE;QACrC;MACJ;MACAD,QAAQ,EAAE;IACd,CAAC,QAAQA,QAAQ,GAAGlB,IAAI,CAACsB,MAAM;IAC/B,OAAOtB,IAAI,CAACuB,KAAK,CAAC,CAAC,EAAEL,QAAQ,CAAC;EAClC;EACA;EACA,MAAMU,WAAW,GAAG,mDAAmD;EACvE,SAASC,SAASA,CAAC7B,IAAI,EAAE;IACrB,IAAI8B,EAAE,EAAEC,EAAE;IACV,OAAO,CAACA,EAAE,GAAG,CAACD,EAAE,GAAGF,WAAW,CAACI,IAAI,CAAChC,IAAI,CAAC,MAAM,IAAI,IAAI8B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,IAAI;EAChI;EACA,MAAME,cAAc,GAAGjC,IAAI,IAAI;IAC3B,MAAMkC,KAAK,GAAGR,aAAa,CAAC1B,IAAI,CAAC;IACjC,IAAIkC,KAAK,IAAI,IAAI,EAAE;MACf,OAAO,IAAI;IACf;IACA,OAAO;MACHhC,IAAI,EAAE,YAAY;MAClBF,IAAI,EAAEkC;IACV,CAAC;EACL,CAAC;EACD,SAASC,eAAeA,CAACjC,IAAI,EAAE;IAC3B,OAAOF,IAAI,IAAI;MACX,IAAI,CAACA,IAAI,CAACgB,UAAU,CAACd,IAAI,CAAC,EAAE;QACxB,OAAO,IAAI;MACf;MACA,MAAMkC,QAAQ,GAAGpC,IAAI,CAACE,IAAI,CAACoB,MAAM,CAAC;MAClC,IAAIc,QAAQ,KAAKnC,SAAS,IAAIwB,uBAAuB,CAACE,IAAI,CAACS,QAAQ,CAAC,EAAE;QAClE,OAAO,IAAI;MACf;MACA,OAAO;QACHlC,IAAI;QACJF,IAAI,EAAEE;MACV,CAAC;IACL,CAAC;EACL;EACA,MAAMmC,eAAe,GAAGrC,IAAI,IAAI;IAC5B,MAAMkC,KAAK,GAAGjB,SAAS,CAACjB,IAAI,CAAC;IAC7B,IAAIkC,KAAK,IAAI,IAAI,EAAE;MACf,OAAO,IAAI;IACf;IACA,OAAO;MACHhC,IAAI,EAAE,aAAa;MACnBF,IAAI,EAAEkC;IACV,CAAC;EACL,CAAC;EACD,MAAMI,OAAO,GAAGtC,IAAI,IAAI;IACpB,IAAIA,IAAI,CAACsB,MAAM,GAAG,CAAC,EAAE;MACjB,OAAO,IAAI;IACf;IACA,OAAO;MACHpB,IAAI,EAAE,KAAK;MACXF,IAAI,EAAE;IACV,CAAC;EACL,CAAC;EACD,MAAMuC,UAAU,GAAGvC,IAAI,IAAI;IACvB,MAAMkC,KAAK,GAAGL,SAAS,CAAC7B,IAAI,CAAC;IAC7B,IAAIkC,KAAK,KAAK,IAAI,EAAE;MAChB,OAAO,IAAI;IACf;IACA,OAAO;MACHhC,IAAI,EAAE,QAAQ;MACdF,IAAI,EAAEkC;IACV,CAAC;EACL,CAAC;EACD,MAAMM,KAAK,GAAG,CACVF,OAAO,EACPvB,mBAAmB,CAAC,IAAI,CAAC,EACzBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,KAAK,CAAC,EAC1BA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBA,mBAAmB,CAAC,GAAG,CAAC,EACxBoB,eAAe,CAAC,WAAW,CAAC,EAC5BA,eAAe,CAAC,MAAM,CAAC,EACvBA,eAAe,CAAC,UAAU,CAAC,EAC3BA,eAAe,CAAC,MAAM,CAAC,EACvBA,eAAe,CAAC,KAAK,CAAC,EACtBA,eAAe,CAAC,QAAQ,CAAC,EACzBA,eAAe,CAAC,OAAO,CAAC,EACxBA,eAAe,CAAC,UAAU,CAAC,EAC3BA,eAAe,CAAC,QAAQ,CAAC,EACzBA,eAAe,CAAC,OAAO,CAAC,EACxBA,eAAe,CAAC,UAAU,CAAC,EAC3BA,eAAe,CAAC,QAAQ,CAAC,EACzBA,eAAe,CAAC,IAAI,CAAC,EACrBA,eAAe,CAAC,IAAI,CAAC,EACrBA,eAAe,CAAC,SAAS,CAAC,EAC1BI,UAAU,EACVN,cAAc,EACdI,eAAe,CAClB;EACD,MAAMI,uBAAuB,GAAG,WAAW;EAC3C,MAAMC,KAAK,CAAC;IACR,OAAOC,MAAMA,CAAC3C,IAAI,EAAE;MAChB,MAAM4C,OAAO,GAAG,IAAI,CAACC,IAAI,CAAC7C,IAAI,CAAC;MAC/BA,IAAI,GAAG4C,OAAO,CAAC5C,IAAI;MACnB,MAAM8C,IAAI,GAAG,IAAI,CAACD,IAAI,CAAC7C,IAAI,CAAC;MAC5BA,IAAI,GAAG8C,IAAI,CAAC9C,IAAI;MAChB,OAAO,IAAI0C,KAAK,CAAC1C,IAAI,EAAEC,SAAS,EAAE2C,OAAO,CAAC7C,KAAK,EAAE+C,IAAI,CAAC/C,KAAK,CAAC;IAChE;IACAM,WAAWA,CAACL,IAAI,EAAE+C,QAAQ,EAAEH,OAAO,EAAEE,IAAI,EAAE;MACvC,IAAI,CAAC9C,IAAI,GAAG,EAAE;MACd,IAAI,CAACA,IAAI,GAAGA,IAAI;MAChB,IAAI,CAAC+C,QAAQ,GAAGA,QAAQ;MACxB,IAAI,CAACH,OAAO,GAAGA,OAAO;MACtB,IAAI,CAACE,IAAI,GAAGA,IAAI;IACpB;IACA,OAAOD,IAAIA,CAAC7C,IAAI,EAAEgD,WAAW,GAAG,KAAK,EAAE;MACnCA,WAAW,GAAGA,WAAW,IAAIP,uBAAuB,CAACd,IAAI,CAAC3B,IAAI,CAAC;MAC/DA,IAAI,GAAGA,IAAI,CAACiD,IAAI,CAAC,CAAC;MAClB,KAAK,MAAMC,IAAI,IAAIV,KAAK,EAAE;QACtB,MAAMW,OAAO,GAAGD,IAAI,CAAClD,IAAI,CAAC;QAC1B,IAAImD,OAAO,KAAK,IAAI,EAAE;UAClB,MAAMpD,KAAK,GAAGO,MAAM,CAAC8C,MAAM,CAAC9C,MAAM,CAAC8C,MAAM,CAAC,CAAC,CAAC,EAAED,OAAO,CAAC,EAAE;YAAEH;UAAY,CAAC,CAAC;UACxEhD,IAAI,GAAGA,IAAI,CAACuB,KAAK,CAACxB,KAAK,CAACC,IAAI,CAACsB,MAAM,CAAC;UACpC,OAAO;YAAEtB,IAAI;YAAED;UAAM,CAAC;QAC1B;MACJ;MACA,MAAM,IAAIK,KAAK,CAAC,mBAAmB,GAAGJ,IAAI,CAAC;IAC/C;IACAqD,OAAOA,CAAA,EAAG;MACN,MAAMP,IAAI,GAAGJ,KAAK,CAACG,IAAI,CAAC,IAAI,CAAC7C,IAAI,CAAC;MAClC,OAAO,IAAI0C,KAAK,CAACI,IAAI,CAAC9C,IAAI,EAAE,IAAI,CAAC4C,OAAO,EAAE,IAAI,CAACE,IAAI,EAAEA,IAAI,CAAC/C,KAAK,CAAC;IACpE;EACJ;;EAEA;AACJ;AACA;EACI,SAASuD,gBAAgBA,CAAC1C,MAAM,EAAE;IAC9B,IAAIA,MAAM,KAAKX,SAAS,EAAE;MACtB,MAAM,IAAIG,KAAK,CAAC,sBAAsB,CAAC;IAC3C;IACA,IAAIQ,MAAM,CAACV,IAAI,KAAK,mBAAmB,IAAIU,MAAM,CAACV,IAAI,KAAK,wBAAwB,IAC/EU,MAAM,CAACV,IAAI,KAAK,mBAAmB,IAAIU,MAAM,CAACV,IAAI,KAAK,2BAA2B,IAClFU,MAAM,CAACV,IAAI,KAAK,sBAAsB,IAAIU,MAAM,CAACV,IAAI,KAAK,2BAA2B,IACrFU,MAAM,CAACV,IAAI,KAAK,yBAAyB,IAAIU,MAAM,CAACV,IAAI,KAAK,qBAAqB,EAAE;MACpF,MAAM,IAAIS,mBAAmB,CAACC,MAAM,CAAC;IACzC;IACA,OAAOA,MAAM;EACjB;EACA,SAAS2C,+BAA+BA,CAAC3C,MAAM,EAAE;IAC7C,IAAIA,MAAM,CAACV,IAAI,KAAK,mBAAmB,EAAE;MACrC,OAAOsD,yBAAyB,CAAC5C,MAAM,CAAC;IAC5C;IACA,OAAO0C,gBAAgB,CAAC1C,MAAM,CAAC;EACnC;EACA,SAAS6C,+BAA+BA,CAAC7C,MAAM,EAAE;IAC7C,IAAIA,MAAM,CAACV,IAAI,KAAK,eAAe,EAAE;MACjC,OAAOU,MAAM;IACjB;IACA,OAAO4C,yBAAyB,CAAC5C,MAAM,CAAC;EAC5C;EACA,SAAS4C,yBAAyBA,CAAC5C,MAAM,EAAE;IACvC,IAAIA,MAAM,CAACV,IAAI,KAAK,mBAAmB,EAAE;MACrC,MAAM,IAAIS,mBAAmB,CAACC,MAAM,CAAC;IACzC;IACA,OAAOA,MAAM;EACjB;EACA,SAAS8C,gCAAgCA,CAAC9C,MAAM,EAAE;IAC9C,IAAIkB,EAAE;IACN,IAAIlB,MAAM,CAACV,IAAI,KAAK,mBAAmB,EAAE;MACrC,IAAI,CAAC,CAAC4B,EAAE,GAAGlB,MAAM,CAAC+C,OAAO,MAAM,IAAI,IAAI7B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC5B,IAAI,MAAM,eAAe,EAAE;QAC1F,OAAOU,MAAM;MACjB;MACA,MAAM,IAAID,mBAAmB,CAACC,MAAM,CAAC;IACzC;IACA,IAAIA,MAAM,CAACV,IAAI,KAAK,iBAAiB,IAAIU,MAAM,CAACV,IAAI,KAAK,eAAe,EAAE;MACtE,MAAM,IAAIS,mBAAmB,CAACC,MAAM,CAAC;IACzC;IACA,OAAOA,MAAM;EACjB;EACA,SAASgD,iBAAiBA,CAAChD,MAAM,EAAE;IAC/B,OAAOA,MAAM,CAACV,IAAI,KAAK,yBAAyB,IAAIU,MAAM,CAACV,IAAI,KAAK,qBAAqB;EAC7F;;EAEA;EACA,IAAI2D,UAAU;EACd,CAAC,UAAUA,UAAU,EAAE;IACnBA,UAAU,CAACA,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK;IACzCA,UAAU,CAACA,UAAU,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;IAC/DA,UAAU,CAACA,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;IAC/CA,UAAU,CAACA,UAAU,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,GAAG,WAAW;IACrDA,UAAU,CAACA,UAAU,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC,GAAG,gBAAgB;IAC/DA,UAAU,CAACA,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;IAC7CA,UAAU,CAACA,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,GAAG,cAAc;IAC3DA,UAAU,CAACA,UAAU,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,GAAG,QAAQ;IAC/CA,UAAU,CAACA,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;IAC7CA,UAAU,CAACA,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;IAC7CA,UAAU,CAACA,UAAU,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC,GAAG,QAAQ;IAChDA,UAAU,CAACA,UAAU,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;IACpDA,UAAU,CAACA,UAAU,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;IACpDA,UAAU,CAACA,UAAU,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;IAChEA,UAAU,CAACA,UAAU,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,GAAG,UAAU;IACpDA,UAAU,CAACA,UAAU,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,GAAG,OAAO;IAC9CA,UAAU,CAACA,UAAU,CAAC,gBAAgB,CAAC,GAAG,EAAE,CAAC,GAAG,gBAAgB;IAChEA,UAAU,CAACA,UAAU,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,GAAG,SAAS;IAClDA,UAAU,CAACA,UAAU,CAAC,WAAW,CAAC,GAAG,EAAE,CAAC,GAAG,WAAW;IACtDA,UAAU,CAACA,UAAU,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,GAAG,aAAa;IAC1DA,UAAU,CAACA,UAAU,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC,GAAG,eAAe;EAClE,CAAC,EAAEA,UAAU,KAAKA,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;EAEnC,MAAMC,MAAM,CAAC;IACTzD,WAAWA,CAAC0D,OAAO,EAAEC,WAAW,EAAEC,UAAU,EAAE;MAC1C,IAAI,CAACF,OAAO,GAAGA,OAAO;MACtB,IAAI,OAAOC,WAAW,KAAK,QAAQ,EAAE;QACjC,IAAI,CAACE,MAAM,GAAGxB,KAAK,CAACC,MAAM,CAACqB,WAAW,CAAC;MAC3C,CAAC,MACI;QACD,IAAI,CAACE,MAAM,GAAGF,WAAW;MAC7B;MACA,IAAI,CAACC,UAAU,GAAGA,UAAU;IAChC;IACA,IAAIE,KAAKA,CAAA,EAAG;MACR,OAAO,IAAI,CAACD,MAAM;IACtB;IACA;AACR;AACA;IACQE,KAAKA,CAAA,EAAG;MACJ,MAAMxD,MAAM,GAAG,IAAI,CAACyD,SAAS,CAACR,UAAU,CAACS,GAAG,CAAC;MAC7C,IAAI,IAAI,CAACH,KAAK,CAACvB,OAAO,CAAC1C,IAAI,KAAK,KAAK,EAAE;QACnC,MAAM,IAAIQ,oBAAoB,CAAC,IAAI,CAACyD,KAAK,CAACvB,OAAO,CAAC;MACtD;MACA,OAAOhC,MAAM;IACjB;IACA;AACR;AACA;IACQyD,SAASA,CAACE,UAAU,EAAE;MAClB,OAAOjB,gBAAgB,CAAC,IAAI,CAACkB,qBAAqB,CAACD,UAAU,CAAC,CAAC;IACnE;IACA;AACR;AACA;AACA;IACQC,qBAAqBA,CAACD,UAAU,EAAE;MAC9B,MAAM3D,MAAM,GAAG,IAAI,CAAC6D,WAAW,CAAC,IAAI,EAAEF,UAAU,CAAC;MACjD,IAAI3D,MAAM,KAAK,IAAI,EAAE;QACjB,MAAM,IAAIT,mBAAmB,CAAC,IAAI,CAACgE,KAAK,CAACvB,OAAO,CAAC;MACrD;MACA,OAAO,IAAI,CAAC8B,0BAA0B,CAAC9D,MAAM,EAAE2D,UAAU,CAAC;IAC9D;IACA;AACR;AACA;AACA;IACQG,0BAA0BA,CAACC,IAAI,EAAEJ,UAAU,EAAE;MACzC,IAAI3D,MAAM,GAAG,IAAI,CAAC6D,WAAW,CAACE,IAAI,EAAEJ,UAAU,CAAC;MAC/C,OAAO3D,MAAM,KAAK,IAAI,EAAE;QACpB+D,IAAI,GAAG/D,MAAM;QACbA,MAAM,GAAG,IAAI,CAAC6D,WAAW,CAACE,IAAI,EAAEJ,UAAU,CAAC;MAC/C;MACA,OAAOI,IAAI;IACf;IACA;AACR;AACA;IACQF,WAAWA,CAACE,IAAI,EAAEJ,UAAU,EAAE;MAC1B,KAAK,MAAMK,OAAO,IAAI,IAAI,CAACb,OAAO,EAAE;QAChC,MAAMnD,MAAM,GAAGgE,OAAO,CAAC,IAAI,EAAEL,UAAU,EAAEI,IAAI,CAAC;QAC9C,IAAI/D,MAAM,KAAK,IAAI,EAAE;UACjB,OAAOA,MAAM;QACjB;MACJ;MACA,OAAO,IAAI;IACf;IACA;AACR;AACA;AACA;IACQiE,OAAOA,CAACC,KAAK,EAAE;MACX,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;QACvBA,KAAK,GAAG,CAACA,KAAK,CAAC;MACnB;MACA,IAAIA,KAAK,CAACG,QAAQ,CAAC,IAAI,CAACd,KAAK,CAACvB,OAAO,CAAC1C,IAAI,CAAC,EAAE;QACzC,IAAI,CAACgE,MAAM,GAAG,IAAI,CAACC,KAAK,CAACd,OAAO,CAAC,CAAC;QAClC,OAAO,IAAI;MACf,CAAC,MACI;QACD,OAAO,KAAK;MAChB;IACJ;IACA6B,gBAAgBA,CAACC,MAAM,EAAE;MACrB,IAAI,CAACjB,MAAM,GAAGiB,MAAM,CAAChB,KAAK;IAC9B;EACJ;EAEA,SAASiB,yBAAyBA,CAACtC,IAAI,EAAE;IACrC,OAAOA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG;EACzF;EAEA,MAAMuC,eAAe,GAAGA,CAACF,MAAM,EAAEZ,UAAU,EAAEI,IAAI,KAAK;IAClD,MAAMzE,IAAI,GAAGiF,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC1C,IAAI;IACtC,MAAM4C,IAAI,GAAGqC,MAAM,CAAChB,KAAK,CAACrB,IAAI,CAAC5C,IAAI;IACnC,MAAMoF,MAAM,GAAKX,IAAI,IAAI,IAAI,IAAKzE,IAAI,KAAK,GAAG,IAAI,CAACkF,yBAAyB,CAACtC,IAAI,CAAC,IAC5E6B,IAAI,IAAI,IAAI,IAAKzE,IAAI,KAAK,GAAI;IACpC,IAAI,CAACoF,MAAM,EAAE;MACT,OAAO,IAAI;IACf;IACAH,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;IACnB,IAAIF,IAAI,IAAI,IAAI,EAAE;MACd,OAAO;QACHzE,IAAI,EAAE,mBAAmB;QACzByD,OAAO,EAAEwB,MAAM,CAACd,SAAS,CAACR,UAAU,CAAC0B,QAAQ,CAAC;QAC9CC,IAAI,EAAE;UACFtE,QAAQ,EAAE;QACd;MACJ,CAAC;IACL,CAAC,MACI;MACD,OAAO;QACHhB,IAAI,EAAE,mBAAmB;QACzByD,OAAO,EAAEL,gBAAgB,CAACqB,IAAI,CAAC;QAC/Ba,IAAI,EAAE;UACFtE,QAAQ,EAAE;QACd;MACJ,CAAC;IACL;EACJ,CAAC;EAED,SAASuE,cAAcA,CAACC,OAAO,EAAE;IAC7B,MAAMd,OAAO,GAAGA,CAACO,MAAM,EAAEQ,aAAa,EAAEhB,IAAI,KAAK;MAC7C,MAAMzE,IAAI,GAAGiF,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC1C,IAAI;MACtC,MAAM4C,IAAI,GAAGqC,MAAM,CAAChB,KAAK,CAACrB,IAAI,CAAC5C,IAAI;MACnC,IAAIyE,IAAI,KAAK,IAAI,EAAE;QACf,IAAI,aAAa,IAAIe,OAAO,EAAE;UAC1B,IAAIA,OAAO,CAACJ,MAAM,CAACpF,IAAI,EAAE4C,IAAI,CAAC,EAAE;YAC5B,OAAO4C,OAAO,CAACE,WAAW,CAACT,MAAM,CAAC;UACtC;QACJ;MACJ,CAAC,MACI;QACD,IAAI,YAAY,IAAIO,OAAO,EAAE;UACzB,IAAIA,OAAO,CAACnB,UAAU,GAAGoB,aAAa,IAAID,OAAO,CAACJ,MAAM,CAACpF,IAAI,EAAE4C,IAAI,CAAC,EAAE;YAClE,OAAO4C,OAAO,CAACG,UAAU,CAACV,MAAM,EAAER,IAAI,CAAC;UAC3C;QACJ;MACJ;MACA,OAAO,IAAI;IACf,CAAC;IACD;IACArE,MAAM,CAACwF,cAAc,CAAClB,OAAO,EAAE,MAAM,EAAE;MACnC1C,KAAK,EAAEwD,OAAO,CAACK;IACnB,CAAC,CAAC;IACF,OAAOnB,OAAO;EAClB;EAEA,MAAMoB,eAAe,GAAGP,cAAc,CAAC;IACnCM,IAAI,EAAE,iBAAiB;IACvBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;IAC5BqE,UAAU,EAAEV,UAAU,CAACoC,QAAQ;IAC/BL,WAAW,EAAET,MAAM,IAAI;MACnBA,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,OAAO;QACH3E,IAAI,EAAE,mBAAmB;QACzByD,OAAO,EAAEwB,MAAM,CAACd,SAAS,CAACR,UAAU,CAACoC,QAAQ,CAAC;QAC9CT,IAAI,EAAE;UACFtE,QAAQ,EAAE;QACd;MACJ,CAAC;IACL,CAAC;IACD2E,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1BQ,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,OAAO;QACH3E,IAAI,EAAE,mBAAmB;QACzByD,OAAO,EAAEL,gBAAgB,CAACqB,IAAI,CAAC;QAC/Ba,IAAI,EAAE;UACFtE,QAAQ,EAAE;QACd;MACJ,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMgF,aAAa,GAAGT,cAAc,CAAC;IACjCM,IAAI,EAAE,eAAe;IACrBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,QAAQ;IACjC0F,WAAW,EAAET,MAAM,IAAI;MACnB,MAAMjD,KAAK,GAAGiE,UAAU,CAAChB,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC5C,IAAI,CAAC;MACnDmF,MAAM,CAACN,OAAO,CAAC,QAAQ,CAAC;MACxB,OAAO;QACH3E,IAAI,EAAE,iBAAiB;QACvBgC;MACJ,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMkE,kBAAkB,GAAGX,cAAc,CAAC;IACtCM,IAAI,EAAE,oBAAoB;IAC1BT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;IAC5B0F,WAAW,EAAET,MAAM,IAAI;MACnBA,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,IAAIM,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACrB,OAAO;UACH3E,IAAI,EAAE,wBAAwB;UAC9BmG,QAAQ,EAAE;QACd,CAAC;MACL;MACA,MAAMzF,MAAM,GAAGuE,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAACS,GAAG,CAAC;MAC3D,IAAI,CAACa,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIzE,KAAK,CAAC,0BAA0B,CAAC;MAC/C;MACA,IAAIQ,MAAM,CAACV,IAAI,KAAK,wBAAwB,EAAE;QAC1C,OAAOU,MAAM;MACjB,CAAC,MACI,IAAIA,MAAM,CAACV,IAAI,KAAK,mBAAmB,EAAE;QAC1C,OAAO;UACHA,IAAI,EAAE,wBAAwB;UAC9BmG,QAAQ,EAAE,CAACzF,MAAM;QACrB,CAAC;MACL;MACA,OAAO;QACHV,IAAI,EAAE,sBAAsB;QAC5ByD,OAAO,EAAEL,gBAAgB,CAAC1C,MAAM;MACpC,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAM0F,mBAAmB,GAAGb,cAAc,CAAC;IACvCM,IAAI,EAAE,qBAAqB;IAC3BT,MAAM,EAAEA,CAACpF,IAAI,EAAE4C,IAAI,KAAM5C,IAAI,KAAK,GAAG,IAAIkF,yBAAyB,CAACtC,IAAI,CAAC,IACpE5C,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,WAAW,IAAIA,IAAI,KAAK,GAAG;IAC3D0F,WAAW,EAAET,MAAM,IAAI;MACnB,IAAIA,MAAM,CAACN,OAAO,CAAC,MAAM,CAAC,EAAE;QACxB,OAAO;UACH3E,IAAI,EAAE;QACV,CAAC;MACL;MACA,IAAIiF,MAAM,CAACN,OAAO,CAAC,WAAW,CAAC,EAAE;QAC7B,OAAO;UACH3E,IAAI,EAAE;QACV,CAAC;MACL;MACA,IAAIiF,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACrB,OAAO;UACH3E,IAAI,EAAE;QACV,CAAC;MACL;MACA,IAAIiF,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACrB,OAAO;UACH3E,IAAI,EAAE;QACV,CAAC;MACL;MACA,MAAM,IAAIE,KAAK,CAAC,sBAAsB,GAAG+E,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC5C,IAAI,CAAC;IACvE;EACJ,CAAC,CAAC;EAEF,MAAMuG,kBAAkB,GAAGd,cAAc,CAAC;IACtCM,IAAI,EAAE,oBAAoB;IAC1BT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;IAC5BqE,UAAU,EAAEV,UAAU,CAAC0B,QAAQ;IAC/BK,WAAW,EAAET,MAAM,IAAI;MACnBA,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,OAAO;QACH3E,IAAI,EAAE,sBAAsB;QAC5ByD,OAAO,EAAEwB,MAAM,CAACd,SAAS,CAACR,UAAU,CAAC0B,QAAQ,CAAC;QAC9CC,IAAI,EAAE;UACFtE,QAAQ,EAAE;QACd;MACJ,CAAC;IACL,CAAC;IACD2E,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1BQ,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,OAAO;QACH3E,IAAI,EAAE,sBAAsB;QAC5ByD,OAAO,EAAEL,gBAAgB,CAACqB,IAAI,CAAC;QAC/Ba,IAAI,EAAE;UACFtE,QAAQ,EAAE;QACd;MACJ,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,SAASsF,0BAA0BA,CAAC;IAAEC;EAAmB,CAAC,EAAE;IACxD,OAAOhB,cAAc,CAAC;MAClBM,IAAI,EAAE,sBAAsB;MAC5BT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;MAC5BqE,UAAU,EAAEV,UAAU,CAAC6C,cAAc;MACrCb,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;QAC1B,MAAM0B,QAAQ,GAAG,CACb9C,+BAA+B,CAACoB,IAAI,CAAC,CACxC;QACDQ,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;QACnB,GAAG;UACC,IAAI;YACA,MAAM/B,IAAI,GAAGqC,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAAC6C,cAAc,CAAC;YACpEL,QAAQ,CAACM,IAAI,CAACpD,+BAA+B,CAACT,IAAI,CAAC,CAAC;UACxD,CAAC,CACD,OAAO8D,CAAC,EAAE;YACN,IAAIH,kBAAkB,IAAIG,CAAC,YAAYzG,mBAAmB,EAAE;cACxD;YACJ,CAAC,MACI;cACD,MAAMyG,CAAC;YACX;UACJ;QACJ,CAAC,QAAQzB,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;QAC5B,IAAIwB,QAAQ,CAAC/E,MAAM,GAAG,CAAC,IAAI+E,QAAQ,CAAC9E,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACsF,IAAI,CAACD,CAAC,IAAIA,CAAC,CAAC1G,IAAI,KAAK,mBAAmB,CAAC,EAAE;UACxF,MAAM,IAAIE,KAAK,CAAC,iDAAiD,CAAC;QACtE;QACA,OAAO;UACHF,IAAI,EAAE,wBAAwB;UAC9BmG;QACJ,CAAC;MACL;IACJ,CAAC,CAAC;EACN;EAEA,MAAMS,cAAc,GAAGrB,cAAc,CAAC;IAClCM,IAAI,EAAE,gBAAgB;IACtBT,MAAM,EAAEA,CAACpF,IAAI,EAAE4C,IAAI,KAAK5C,IAAI,KAAK,GAAG,IAAKA,IAAI,KAAK,GAAG,IAAI4C,IAAI,KAAK,GAAI;IACtEyB,UAAU,EAAEV,UAAU,CAACkD,OAAO;IAC9BlB,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1B,MAAMqC,GAAG,GAAG7B,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MAC/BM,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,MAAMoC,OAAO,GAAG,EAAE;MAClB,GAAG;QACCA,OAAO,CAACN,IAAI,CAACxB,MAAM,CAACd,SAAS,CAACR,UAAU,CAAC6C,cAAc,CAAC,CAAC;MAC7D,CAAC,QAAQvB,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MAC5B,IAAI,CAACM,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIzE,KAAK,CAAC,qCAAqC,CAAC;MAC1D;MACA,OAAO;QACHF,IAAI,EAAE,kBAAkB;QACxByE,IAAI,EAAErB,gBAAgB,CAACqB,IAAI,CAAC;QAC5B0B,QAAQ,EAAEY,OAAO;QACjBzB,IAAI,EAAE;UACF0B,QAAQ,EAAE,OAAO;UACjBF;QACJ;MACJ,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMG,YAAY,GAAG1B,cAAc,CAAC;IAChCM,IAAI,EAAE,cAAc;IACpBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;IAC5BqE,UAAU,EAAEV,UAAU,CAACuD,KAAK;IAC5BvB,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1BQ,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,MAAMwB,QAAQ,GAAG,EAAE;MACnB,GAAG;QACCA,QAAQ,CAACM,IAAI,CAACxB,MAAM,CAACd,SAAS,CAACR,UAAU,CAACuD,KAAK,CAAC,CAAC;MACrD,CAAC,QAAQjC,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MAC5B,OAAO;QACH3E,IAAI,EAAE,gBAAgB;QACtBmG,QAAQ,EAAE,CAAC/C,gBAAgB,CAACqB,IAAI,CAAC,EAAE,GAAG0B,QAAQ;MAClD,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMgB,WAAW,GAAG,CAChBhC,eAAe,EACfW,eAAe,EACfE,aAAa,EACbE,kBAAkB,EAClBE,mBAAmB,EACnBC,kBAAkB,EAClBC,0BAA0B,CAAC;IACvBC,kBAAkB,EAAE;EACxB,CAAC,CAAC,EACFK,cAAc,EACdK,YAAY,EACZnB,eAAe,CAClB;EAED,SAASsB,qBAAqBA,CAAC;IAAEC,4BAA4B;IAAEC,mBAAmB;IAAEC;EAAY,CAAC,EAAE;IAC/F,OAAO,SAASC,eAAeA,CAACvC,MAAM,EAAEZ,UAAU,EAAEI,IAAI,EAAE;MACtD,IAAKA,IAAI,IAAI,IAAI,IAAKJ,UAAU,IAAIV,UAAU,CAAC8D,SAAS,EAAE;QACtD,OAAO,IAAI;MACf;MACA,MAAMzH,IAAI,GAAGiF,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC1C,IAAI;MACtC,MAAM4C,IAAI,GAAGqC,MAAM,CAAChB,KAAK,CAACrB,IAAI,CAAC5C,IAAI;MACnC,MAAMoF,MAAM,GAAIpF,IAAI,KAAK,GAAG,IAAI4C,IAAI,KAAK,GAAG,IACvC5C,IAAI,KAAK,GAAG,KAAKqH,4BAA4B,IAAI5C,IAAI,CAACzE,IAAI,KAAK,eAAe,CAAE,IAChFsH,mBAAmB,KAAKtH,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,CAAE;MAC3D,IAAI,CAACoF,MAAM,EAAE;QACT,OAAO,IAAI;MACf;MACA,IAAIsC,QAAQ;MACZ,IAAIV,QAAQ,GAAG,KAAK;MACpB,IAAI/B,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACrB+C,QAAQ,GAAG,UAAU;MACzB,CAAC,MACI,IAAIzC,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QAC1B+C,QAAQ,GAAG,mBAAmB;QAC9BV,QAAQ,GAAG,IAAI;MACnB,CAAC,MACI,IAAI/B,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QAC1B+C,QAAQ,GAAG,OAAO;MACtB,CAAC,MACI;QACDzC,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;QACnB+C,QAAQ,GAAG,UAAU;MACzB;MACA,MAAMC,UAAU,GAAGJ,WAAW,KAAK,IAAI,GACjC,IAAI3D,MAAM,CAAC2D,WAAW,EAAEtC,MAAM,CAAChB,KAAK,EAAEgB,MAAM,CAAC,GAC7CA,MAAM;MACZ,MAAM2C,MAAM,GAAGD,UAAU,CAACrD,qBAAqB,CAACX,UAAU,CAAC8D,SAAS,CAAC;MACrExC,MAAM,CAACD,gBAAgB,CAAC2C,UAAU,CAAC;MACnC,IAAIE,KAAK;MACT,QAAQD,MAAM,CAAC5H,IAAI;QACf,KAAK,eAAe;UAChB6H,KAAK,GAAG;YACJ7H,IAAI,EAAE,mBAAmB;YACzBgC,KAAK,EAAE4F,MAAM,CAAC5F,KAAK;YACnBsD,IAAI,EAAE;cACFwC,KAAK,EAAE/H;YACX;UACJ,CAAC;UACD;QACJ,KAAK,iBAAiB;UAClB8H,KAAK,GAAG;YACJ7H,IAAI,EAAE,mBAAmB;YACzBgC,KAAK,EAAE4F,MAAM,CAAC5F,KAAK,CAAC+F,QAAQ,CAAC,EAAE,CAAC;YAChCzC,IAAI,EAAE;cACFwC,KAAK,EAAE/H;YACX;UACJ,CAAC;UACD;QACJ,KAAK,sBAAsB;UACvB8H,KAAK,GAAG;YACJ7H,IAAI,EAAE,mBAAmB;YACzBgC,KAAK,EAAE4F,MAAM,CAAC5F,KAAK;YACnBsD,IAAI,EAAE;cACFwC,KAAK,EAAEF,MAAM,CAACtC,IAAI,CAACwC;YACvB;UACJ,CAAC;UACD;QACJ,KAAK,0BAA0B;UAC3B,IAAIF,MAAM,CAACI,WAAW,KAAK,OAAO,EAAE;YAChCH,KAAK,GAAGD,MAAM;UAClB,CAAC,MACI;YACD,MAAM,IAAInH,mBAAmB,CAACmH,MAAM,EAAE,8EAA8E,CAAC;UACzH;UACA;QACJ;UACI,MAAM,IAAInH,mBAAmB,CAACmH,MAAM,EAAE,wGAAwG,CAAC;MACvJ;MACA,IAAIZ,QAAQ,IAAI,CAAC/B,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QAClC,MAAM9E,KAAK,GAAGoF,MAAM,CAAChB,KAAK,CAACvB,OAAO;QAClC,MAAM,IAAIxC,KAAK,CAAC,gDAAgDL,KAAK,CAACG,IAAI,IAAI,GAC1E,cAAcH,KAAK,CAACC,IAAI,GAAG,CAAC;MACpC;MACA,OAAO;QACHE,IAAI,EAAE,mBAAmB;QACzByE,IAAI,EAAErB,gBAAgB,CAACqB,IAAI,CAAC;QAC5BoD,KAAK;QACLH;MACJ,CAAC;IACL,CAAC;EACL;EAEA,SAASO,iBAAiBA,CAAC;IAAEC;EAAwB,CAAC,EAAE;IACpD,OAAO3C,cAAc,CAAC;MAClBM,IAAI,EAAE,aAAa;MACnBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,YAAY,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,KAAK,IAAIkI,uBAAuB,CAACnD,QAAQ,CAAC/E,IAAI,CAAC;MACpH0F,WAAW,EAAET,MAAM,IAAI;QACnB,MAAM;UAAEjF,IAAI;UAAEF;QAAK,CAAC,GAAGmF,MAAM,CAAChB,KAAK,CAACvB,OAAO;QAC3CuC,MAAM,CAACN,OAAO,CAAC3E,IAAI,CAAC;QACpB,OAAO;UACHA,IAAI,EAAE,eAAe;UACrBgC,KAAK,EAAElC;QACX,CAAC;MACL;IACJ,CAAC,CAAC;EACN;EAEA,MAAMqI,kBAAkB,GAAG5C,cAAc,CAAC;IACtCM,IAAI,EAAE,oBAAoB;IAC1BT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,aAAa;IACtC0F,WAAW,EAAET,MAAM,IAAI;MACnB,MAAMnF,IAAI,GAAGmF,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC5C,IAAI;MACtCmF,MAAM,CAACN,OAAO,CAAC,aAAa,CAAC;MAC7B,OAAO;QACH3E,IAAI,EAAE,sBAAsB;QAC5BgC,KAAK,EAAElC,IAAI,CAACuB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACxBiE,IAAI,EAAE;UACFwC,KAAK,EAAEhI,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,GAAG,QAAQ,GAAG;QACzC;MACJ,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,SAASsI,4BAA4BA,CAAC;IAAEb,WAAW;IAAEc;EAAa,CAAC,EAAE;IACjE,OAAO9C,cAAc,CAAC;MAClBM,IAAI,EAAE,wBAAwB;MAC9BT,MAAM,EAAEpF,IAAI,IAAIqI,YAAY,CAACtD,QAAQ,CAAC/E,IAAI,CAAC;MAC3C0F,WAAW,EAAET,MAAM,IAAI;QACnB,MAAMjF,IAAI,GAAGiF,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC1C,IAAI;QACtCiF,MAAM,CAACN,OAAO,CAAC3E,IAAI,CAAC;QACpB,IAAI,CAACiF,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;UACtB,OAAO;YACH3E,IAAI,EAAE,eAAe;YACrBgC,KAAK,EAAEhC;UACX,CAAC;QACL;QACA,IAAIU,MAAM;QACV,IAAIb,KAAK,GAAGoF,MAAM,CAAChB,KAAK,CAACvB,OAAO;QAChC,IAAIuC,MAAM,CAACN,OAAO,CAAC,aAAa,CAAC,EAAE;UAC/BjE,MAAM,GAAG;YACLV,IAAI,EAAE,0BAA0B;YAChCgC,KAAK,EAAEnC,KAAK,CAACC,IAAI,CAACuB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9B2G,WAAW,EAAEhI,IAAI;YACjBsF,IAAI,EAAE;cACFwC,KAAK,EAAEjI,KAAK,CAACC,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,GAAG,QAAQ,GAAG;YAC/C;UACJ,CAAC;QACL,CAAC,MACI;UACD,IAAIkC,KAAK,GAAG,EAAE;UACd,MAAMsG,OAAO,GAAG,CAAC,YAAY,EAAE,GAAG,EAAE,GAAG,CAAC;UACxC,OAAOA,OAAO,CAAC3B,IAAI,CAAC3G,IAAI,IAAIiF,MAAM,CAACN,OAAO,CAAC3E,IAAI,CAAC,CAAC,EAAE;YAC/CgC,KAAK,IAAInC,KAAK,CAACC,IAAI;YACnBD,KAAK,GAAGoF,MAAM,CAAChB,KAAK,CAACvB,OAAO;UAChC;UACAhC,MAAM,GAAG;YACLV,IAAI,EAAE,0BAA0B;YAChCgC,KAAK;YACLgG,WAAW,EAAEhI,IAAI;YACjBsF,IAAI,EAAE;cACFwC,KAAK,EAAE/H;YACX;UACJ,CAAC;QACL;QACA,MAAMwI,YAAY,GAAG,IAAI3E,MAAM,CAAC2D,WAAW,EAAEtC,MAAM,CAAChB,KAAK,EAAEgB,MAAM,CAAC;QAClE,MAAMuD,YAAY,GAAGD,YAAY,CAAC/D,0BAA0B,CAAC9D,MAAM,EAAEiD,UAAU,CAACS,GAAG,CAAC;QACpFa,MAAM,CAACD,gBAAgB,CAACuD,YAAY,CAAC;QACrC,OAAOnF,gBAAgB,CAACoF,YAAY,CAAC;MACzC;IACJ,CAAC,CAAC;EACN;EAEA,MAAMC,eAAe,GAAG,CACpBR,iBAAiB,CAAC;IACdC,uBAAuB,EAAE,CAAC,UAAU,EAAE,QAAQ;EAClD,CAAC,CAAC,EACFC,kBAAkB,EAClBnC,aAAa,EACboB,qBAAqB,CAAC;IAClBC,4BAA4B,EAAE,KAAK;IACnCC,mBAAmB,EAAE,IAAI;IACzBC,WAAW,EAAE;EACjB,CAAC,CAAC,CACL;EACD,MAAMA,WAAW,GAAG,CAChB,GAAGkB,eAAe,EAClBL,4BAA4B,CAAC;IACzBC,YAAY,EAAE,CAAC,OAAO,CAAC;IACvBd,WAAW,EAAEkB;EACjB,CAAC,CAAC,CACL;EAED,SAASC,aAAaA,CAAC1G,KAAK,EAAE;IAC1B,IAAI2G,UAAU;IACd,IAAI3G,KAAK,CAAChC,IAAI,KAAK,wBAAwB,EAAE;MACzC2I,UAAU,GAAG3G,KAAK,CAACmE,QAAQ;IAC/B,CAAC,MACI,IAAInE,KAAK,CAAChC,IAAI,KAAK,sBAAsB,EAAE;MAC5C2I,UAAU,GAAG,CAAC3G,KAAK,CAACyB,OAAO,CAAC;IAChC,CAAC,MACI;MACD,MAAM,IAAIhD,mBAAmB,CAACuB,KAAK,CAAC;IACxC;IACA,OAAO2G,UAAU,CAACC,GAAG,CAACC,CAAC,IAAIxF,+BAA+B,CAACwF,CAAC,CAAC,CAAC;EAClE;EACA,SAASC,oBAAoBA,CAAC9G,KAAK,EAAE;IACjC,MAAM2G,UAAU,GAAGD,aAAa,CAAC1G,KAAK,CAAC;IACvC,IAAI2G,UAAU,CAAChC,IAAI,CAACkC,CAAC,IAAIA,CAAC,CAAC7I,IAAI,KAAK,mBAAmB,CAAC,EAAE;MACtD,MAAM,IAAIE,KAAK,CAAC,8BAA8B,CAAC;IACnD;IACA,OAAOyI,UAAU;EACrB;EACA,SAASI,qBAAqBA,CAAC;IAAEC,oBAAoB;IAAEC,iBAAiB;IAAEC,uBAAuB;IAAEC;EAA0B,CAAC,EAAE;IAC5H,OAAO5D,cAAc,CAAC;MAClBM,IAAI,EAAE,iBAAiB;MACvBT,MAAM,EAAEA,CAACpF,IAAI,EAAE4C,IAAI,KAAK5C,IAAI,KAAK,UAAU,IAAKmJ,yBAAyB,IAAInJ,IAAI,KAAK,KAAK,IAAI4C,IAAI,KAAK,GAAI;MAC5G8C,WAAW,EAAET,MAAM,IAAI;QACnB,MAAMmE,UAAU,GAAGnE,MAAM,CAACN,OAAO,CAAC,KAAK,CAAC;QACxCM,MAAM,CAACN,OAAO,CAAC,UAAU,CAAC;QAC1B,MAAM0E,cAAc,GAAGpE,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC1C,IAAI,KAAK,GAAG;QACxD,IAAI,CAACqJ,cAAc,EAAE;UACjB,IAAI,CAACH,uBAAuB,EAAE;YAC1B,MAAM,IAAIhJ,KAAK,CAAC,oCAAoC,CAAC;UACzD;UACA,OAAO;YACHF,IAAI,EAAE,eAAe;YACrBgC,KAAK,EAAE;UACX,CAAC;QACL;QACA,IAAItB,MAAM,GAAG;UACTV,IAAI,EAAE,mBAAmB;UACzB2I,UAAU,EAAE,EAAE;UACdW,KAAK,EAAE,KAAK;UACZnJ,WAAW,EAAEiJ,UAAU;UACvBG,WAAW,EAAEF;QACjB,CAAC;QACD,MAAMrH,KAAK,GAAGiD,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAAC6F,QAAQ,CAAC;QAC/D,IAAIR,oBAAoB,KAAKjJ,SAAS,EAAE;UACpCW,MAAM,CAACiI,UAAU,GAAGG,oBAAoB,CAAC9G,KAAK,CAAC;QACnD,CAAC,MACI,IAAIoH,UAAU,IAAIpH,KAAK,CAAChC,IAAI,KAAK,mBAAmB,IAAIgC,KAAK,CAACsH,KAAK,EAAE;UACtE5I,MAAM,GAAGsB,KAAK;UACdtB,MAAM,CAACP,WAAW,GAAG,IAAI;UACzB,OAAOO,MAAM;QACjB,CAAC,MACI;UACDA,MAAM,CAACiI,UAAU,GAAGD,aAAa,CAAC1G,KAAK,CAAC;UACxC,KAAK,MAAM6G,CAAC,IAAInI,MAAM,CAACiI,UAAU,EAAE;YAC/B,IAAIE,CAAC,CAAC7I,IAAI,KAAK,mBAAmB,IAAK,CAACgJ,oBAAoB,CAACjE,QAAQ,CAAC8D,CAAC,CAACY,GAAG,CAAE,EAAE;cAC3E,MAAM,IAAIvJ,KAAK,CAAC,qCAAqC8I,oBAAoB,CAACU,IAAI,CAAC,IAAI,CAAC,YAAYb,CAAC,CAAC7I,IAAI,EAAE,CAAC;YAC7G;UACJ;QACJ;QACA,IAAIiF,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;UACrBjE,MAAM,CAACiJ,UAAU,GAAG1E,MAAM,CAACd,SAAS,CAACR,UAAU,CAACiG,MAAM,CAAC;QAC3D,CAAC,MACI;UACD,IAAI,CAACX,iBAAiB,EAAE;YACpB,MAAM,IAAI/I,KAAK,CAAC,iCAAiC,CAAC;UACtD;QACJ;QACA,OAAOQ,MAAM;MACjB;IACJ,CAAC,CAAC;EACN;EAEA,SAASmJ,qBAAqBA,CAAC;IAAEC,YAAY;IAAEC;EAAuB,CAAC,EAAE;IACrE,OAAOxE,cAAc,CAAC;MAClBM,IAAI,EAAE,iBAAiB;MACvBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,KAAK;MAC9BqE,UAAU,EAAEV,UAAU,CAACiG,MAAM;MAC7BlE,WAAW,EAAET,MAAM,IAAI;QACnBA,MAAM,CAACN,OAAO,CAAC,KAAK,CAAC;QACrB,MAAMqC,QAAQ,GAAG+C,sBAAsB,IAAI9E,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;QAC9D,IAAI;UACA,MAAMlB,OAAO,GAAGwB,MAAM,CAACd,SAAS,CAACR,UAAU,CAACiG,MAAM,CAAC;UACnD,IAAI5C,QAAQ,IAAI,CAAC/B,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;YAClC,MAAM,IAAIzE,KAAK,CAAC,2CAA2C,CAAC;UAChE;UACA,OAAO;YACHF,IAAI,EAAE,mBAAmB;YACzByD,OAAO,EAAEL,gBAAgB,CAACK,OAAO,CAAC;YAClC6B,IAAI,EAAE;cACFtE,QAAQ,EAAE,QAAQ;cAClBgJ,cAAc,EAAEhD;YACpB;UACJ,CAAC;QACL,CAAC,CACD,OAAON,CAAC,EAAE;UACN,IAAIA,CAAC,YAAYzG,mBAAmB,EAAE;YAClC,IAAI+G,QAAQ,EAAE;cACV,MAAM,IAAI9G,KAAK,CAAC,qDAAqD,CAAC;YAC1E;YACA,OAAO;cACHF,IAAI,EAAE,mBAAmB;cACzBsF,IAAI,EAAE;gBACFtE,QAAQ,EAAEjB,SAAS;gBACnBiK,cAAc,EAAE;cACpB;YACJ,CAAC;UACL,CAAC,MACI;YACD,MAAMtD,CAAC;UACX;QACJ;MACJ,CAAC;MACDf,UAAU,EAAEmE,YAAY,GAClB,CAAC7E,MAAM,EAAER,IAAI,KAAK;QAChBQ,MAAM,CAACN,OAAO,CAAC,KAAK,CAAC;QACrB,OAAO;UACH3E,IAAI,EAAE,mBAAmB;UACzByD,OAAO,EAAEL,gBAAgB,CAACqB,IAAI,CAAC;UAC/Ba,IAAI,EAAE;YACFtE,QAAQ,EAAE,QAAQ;YAClBgJ,cAAc,EAAE;UACpB;QACJ,CAAC;MACL,CAAC,GACCjK;IACV,CAAC,CAAC;EACN;EAEA,MAAMkK,aAAa,GAAG1E,cAAc,CAAC;IACjCM,IAAI,EAAE,eAAe;IACrBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;IAC5BqE,UAAU,EAAEV,UAAU,CAACuG,MAAM;IAC7BvE,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1B,IAAIA,IAAI,CAACzE,IAAI,KAAK,eAAe,EAAE;QAC/B,MAAM,IAAIE,KAAK,CAAC,6DAA6D,CAAC;MAClF;MACA+E,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,MAAMjE,MAAM,GAAG;QACXV,IAAI,EAAE,iBAAiB;QACvBgC,KAAK,EAAEyC,IAAI,CAACzC;MAChB,CAAC;MACD,IAAI,CAACiD,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM/B,IAAI,GAAGqC,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAACuG,MAAM,CAAC;QAC5DxJ,MAAM,CAAC+C,OAAO,GAAGD,gCAAgC,CAACZ,IAAI,CAAC;QACvD,IAAI,CAACqC,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;UACtB,MAAM,IAAIzE,KAAK,CAAC,iCAAiC,CAAC;QACtD;MACJ;MACA,OAAOQ,MAAM;IACjB;EACJ,CAAC,CAAC;EAEF,MAAMyJ,oBAAoB,GAAG5E,cAAc,CAAC;IACxCM,IAAI,EAAE,sBAAsB;IAC5BxB,UAAU,EAAEV,UAAU,CAACyG,cAAc;IACrChF,MAAM,EAAEA,CAACpF,IAAI,EAAE4C,IAAI,KAAK5C,IAAI,KAAK,GAAG,IAAI4C,IAAI,KAAK,GAAG;IACpD+C,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1BQ,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnBM,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,OAAO;QACH3E,IAAI,EAAE,kBAAkB;QACxByE,IAAI,EAAE;UACFzE,IAAI,EAAE,eAAe;UACrBgC,KAAK,EAAE;QACX,CAAC;QACDmE,QAAQ,EAAE,CACN/C,gBAAgB,CAACqB,IAAI,CAAC,CACzB;QACDa,IAAI,EAAE;UACF0B,QAAQ,EAAE,QAAQ;UAClBF,GAAG,EAAE;QACT;MACJ,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,SAASuD,mBAAmBA,CAAC;IAAEC,kBAAkB;IAAEC;EAAc,CAAC,EAAE;IAChE,OAAOhF,cAAc,CAAC;MAClBM,IAAI,EAAE,eAAe;MACrBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;MAC5B0F,WAAW,EAAET,MAAM,IAAI;QACnBA,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;QACnB,MAAMjE,MAAM,GAAG;UACXV,IAAI,EAAE,iBAAiB;UACvBsF,IAAI,EAAE;YACFkF,SAAS,EAAE;UACf,CAAC;UACDrE,QAAQ,EAAE;QACd,CAAC;QACD,IAAI,CAAClB,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;UACtB,IAAI6F,SAAS;UACb,MAAMC,WAAW,GAAG,IAAI7G,MAAM,CAAC0G,kBAAkB,EAAErF,MAAM,CAAChB,KAAK,EAAEgB,MAAM,CAAC;UACxE,OAAO,IAAI,EAAE;YACTwF,WAAW,CAACzF,gBAAgB,CAACC,MAAM,CAAC;YACpC,IAAIyF,KAAK,GAAGD,WAAW,CAACnG,qBAAqB,CAACX,UAAU,CAACgH,MAAM,CAAC;YAChE1F,MAAM,CAACD,gBAAgB,CAACyF,WAAW,CAAC;YACpC,IAAIC,KAAK,KAAK3K,SAAS,IAAIwK,aAAa,EAAE;cACtCG,KAAK,GAAGzF,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAACgH,MAAM,CAAC;YAC3D;YACA,IAAIC,QAAQ,GAAG,KAAK;YACpB,IAAIF,KAAK,CAAC1K,IAAI,KAAK,mBAAmB,EAAE;cACpC4K,QAAQ,GAAG,IAAI;cACfF,KAAK,GAAGA,KAAK,CAACjH,OAAO;YACzB;YACA,IAAIiH,KAAK,CAAC1K,IAAI,KAAK,iBAAiB,IAAI0K,KAAK,CAAC1K,IAAI,KAAK,eAAe,IAAI0K,KAAK,CAAC1K,IAAI,KAAK,sBAAsB,EAAE;cAC7G,IAAI8H,KAAK;cACT,IAAI4C,KAAK,CAAC1K,IAAI,KAAK,sBAAsB,EAAE;gBACvC8H,KAAK,GAAG4C,KAAK,CAACpF,IAAI,CAACwC,KAAK;cAC5B;cACApH,MAAM,CAACyF,QAAQ,CAACM,IAAI,CAAC;gBACjBzG,IAAI,EAAE,sBAAsB;gBAC5ByJ,GAAG,EAAEiB,KAAK,CAAC1I,KAAK,CAAC+F,QAAQ,CAAC,CAAC;gBAC3BF,KAAK,EAAE9H,SAAS;gBAChB6K,QAAQ;gBACRC,QAAQ,EAAE,KAAK;gBACfvF,IAAI,EAAE;kBACFwC;gBACJ;cACJ,CAAC,CAAC;YACN,CAAC,MACI,IAAI4C,KAAK,CAAC1K,IAAI,KAAK,sBAAsB,IAAI0K,KAAK,CAAC1K,IAAI,KAAK,2BAA2B,EAAE;cAC1FU,MAAM,CAACyF,QAAQ,CAACM,IAAI,CAACiE,KAAK,CAAC;YAC/B,CAAC,MACI;cACD,MAAM,IAAIjK,mBAAmB,CAACiK,KAAK,CAAC;YACxC;YACA,IAAIzF,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAACI,WAAW,EAAE;cAClC0H,SAAS,GAAG,WAAW;YAC3B,CAAC,MACI,IAAIvF,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;cAC1B6F,SAAS,GAAG,OAAO;YACvB,CAAC,MACI,IAAIvF,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;cAC1B6F,SAAS,GAAG,WAAW;YAC3B,CAAC,MACI;cACD;YACJ;YACA,MAAMxK,IAAI,GAAGiF,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC1C,IAAI;YACtC,IAAIA,IAAI,KAAK,GAAG,EAAE;cACd;YACJ;UACJ;UACAU,MAAM,CAAC4E,IAAI,CAACkF,SAAS,GAAGA,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAK,KAAK,CAAC,GAAGA,SAAS,GAAG,OAAO,CAAC,CAAC;UAC1F,IAAI,CAACvF,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;YACtB,MAAM,IAAIzE,KAAK,CAAC,yCAAyC,CAAC;UAC9D;QACJ;QACA,OAAOQ,MAAM;MACjB;IACJ,CAAC,CAAC;EACN;EAEA,SAASoK,wBAAwBA,CAAC;IAAEC,sBAAsB;IAAER,aAAa;IAAES,aAAa;IAAEC;EAAc,CAAC,EAAE;IACvG,OAAO1F,cAAc,CAAC;MAClBM,IAAI,EAAE,oBAAoB;MAC1BxB,UAAU,EAAEV,UAAU,CAACuH,SAAS;MAChC9F,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;MAC5B2F,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;QAC1B,IAAI7C,EAAE;QACN,IAAIgJ,QAAQ,GAAG,KAAK;QACpB,IAAIO,gBAAgB,GAAG,KAAK;QAC5B,IAAIF,aAAa,IAAIxG,IAAI,CAACzE,IAAI,KAAK,mBAAmB,EAAE;UACpD4K,QAAQ,GAAG,IAAI;UACfnG,IAAI,GAAGA,IAAI,CAAChB,OAAO;QACvB;QACA,IAAIuH,aAAa,IAAIvG,IAAI,CAACzE,IAAI,KAAK,2BAA2B,EAAE;UAC5DmL,gBAAgB,GAAG,IAAI;UACvB1G,IAAI,GAAGA,IAAI,CAAChB,OAAO;QACvB;QACA;QACA,MAAM2H,YAAY,GAAG,CAACxJ,EAAE,GAAGqD,MAAM,CAAClB,UAAU,MAAM,IAAI,IAAInC,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGqD,MAAM;QACrFmG,YAAY,CAACpG,gBAAgB,CAACC,MAAM,CAAC;QACrC,IAAIR,IAAI,CAACzE,IAAI,KAAK,iBAAiB,IAAIyE,IAAI,CAACzE,IAAI,KAAK,eAAe,IAAIyE,IAAI,CAACzE,IAAI,KAAK,sBAAsB,IACxG0D,iBAAiB,CAACe,IAAI,CAAC,EAAE;UACzB,IAAIf,iBAAiB,CAACe,IAAI,CAAC,IAAI,CAACsG,sBAAsB,EAAE;YACpD,MAAM,IAAItK,mBAAmB,CAACgE,IAAI,CAAC;UACvC;UACA2G,YAAY,CAACzG,OAAO,CAAC,GAAG,CAAC;UACzB,IAAImD,KAAK;UACT,IAAIrD,IAAI,CAACzE,IAAI,KAAK,sBAAsB,EAAE;YACtC8H,KAAK,GAAGrD,IAAI,CAACa,IAAI,CAACwC,KAAK;UAC3B;UACA,MAAMD,KAAK,GAAGuD,YAAY,CAACjH,SAAS,CAACR,UAAU,CAACuH,SAAS,CAAC;UAC1DjG,MAAM,CAACD,gBAAgB,CAACoG,YAAY,CAAC;UACrC,OAAO;YACHpL,IAAI,EAAE,sBAAsB;YAC5ByJ,GAAG,EAAE/F,iBAAiB,CAACe,IAAI,CAAC,GAAGA,IAAI,GAAGA,IAAI,CAACzC,KAAK,CAAC+F,QAAQ,CAAC,CAAC;YAC3DF,KAAK;YACL+C,QAAQ;YACRC,QAAQ,EAAEM,gBAAgB;YAC1B7F,IAAI,EAAE;cACFwC;YACJ;UACJ,CAAC;QACL,CAAC,MACI;UACD,IAAI,CAACyC,aAAa,EAAE;YAChB,MAAM,IAAI9J,mBAAmB,CAACgE,IAAI,CAAC;UACvC;UACA2G,YAAY,CAACzG,OAAO,CAAC,GAAG,CAAC;UACzB,MAAMkD,KAAK,GAAGuD,YAAY,CAACjH,SAAS,CAACR,UAAU,CAACuH,SAAS,CAAC;UAC1DjG,MAAM,CAACD,gBAAgB,CAACoG,YAAY,CAAC;UACrC,OAAO;YACHpL,IAAI,EAAE,2BAA2B;YACjCyE,IAAI,EAAErB,gBAAgB,CAACqB,IAAI,CAAC;YAC5BoD;UACJ,CAAC;QACL;MACJ;IACJ,CAAC,CAAC;EACN;EAEA,SAASwD,qBAAqBA,CAAC;IAAEJ,aAAa;IAAEK;EAAc,CAAC,EAAE;IAC7D,OAAO/F,cAAc,CAAC;MAClBM,IAAI,EAAE,iBAAiB;MACvBxB,UAAU,EAAEV,UAAU,CAACuH,SAAS;MAChC9F,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;MAC5B2F,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;QAC1B,IAAImG,QAAQ,GAAG,KAAK;QACpB,IAAIW,QAAQ,GAAG,KAAK;QACpB,IAAIN,aAAa,IAAIxG,IAAI,CAACzE,IAAI,KAAK,mBAAmB,EAAE;UACpD4K,QAAQ,GAAG,IAAI;UACfnG,IAAI,GAAGA,IAAI,CAAChB,OAAO;QACvB;QACA,IAAI6H,aAAa,IAAI7G,IAAI,CAACzE,IAAI,KAAK,mBAAmB,IAAIyE,IAAI,CAAChB,OAAO,KAAK1D,SAAS,EAAE;UAClFwL,QAAQ,GAAG,IAAI;UACf9G,IAAI,GAAGA,IAAI,CAAChB,OAAO;QACvB;QACA,IAAIgB,IAAI,CAACzE,IAAI,KAAK,eAAe,EAAE;UAC/B,MAAM,IAAIS,mBAAmB,CAACgE,IAAI,CAAC;QACvC;QACAQ,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;QACnB,MAAMkD,KAAK,GAAG5C,MAAM,CAACd,SAAS,CAACR,UAAU,CAACuH,SAAS,CAAC;QACpD,OAAO;UACHlL,IAAI,EAAE,mBAAmB;UACzByJ,GAAG,EAAEhF,IAAI,CAACzC,KAAK;UACf6F,KAAK;UACL+C,QAAQ;UACRW;QACJ,CAAC;MACL;IACJ,CAAC,CAAC;EACN;EAEA,MAAMC,gBAAgB,GAAG,CACrB,GAAGrE,WAAW,EACd4B,qBAAqB,CAAC;IAClBG,uBAAuB,EAAE,IAAI;IAC7BF,oBAAoB,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC;IACrCC,iBAAiB,EAAE,IAAI;IACvBE,yBAAyB,EAAE;EAC/B,CAAC,CAAC,EACFhB,kBAAkB,EAClBC,4BAA4B,CAAC;IACzBC,YAAY,EAAE,CAAC,QAAQ,EAAE,UAAU,EAAE,OAAO,CAAC;IAC7Cd;EACJ,CAAC,CAAC,EACFsC,qBAAqB,CAAC;IAClBE,sBAAsB,EAAE,IAAI;IAC5BD,YAAY,EAAE;EAClB,CAAC,CAAC,EACF7B,iBAAiB,CAAC;IACdC,uBAAuB,EAAE,CAAC,OAAO;EACrC,CAAC,CAAC,EACF+B,aAAa,EACbE,oBAAoB,EACpB/C,qBAAqB,CAAC;IAClBC,4BAA4B,EAAE,KAAK;IACnCC,mBAAmB,EAAE,IAAI;IACzBC;EACJ,CAAC,CAAC,CACL;EACD,MAAMkE,YAAY,GAAG,CACjB,GAAGD,gBAAgB,EACnBnB,mBAAmB,CAAC;IAChB;IACA;IACAC,kBAAkB,EAAE,CAChBrC,iBAAiB,CAAC;MACdC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,IAAI;IAC5C,CAAC,CAAC,EACF4C,wBAAwB,CAAC;MACrBC,sBAAsB,EAAE,KAAK;MAC7BR,aAAa,EAAE,IAAI;MACnBU,aAAa,EAAE,KAAK;MACpBD,aAAa,EAAE;IACnB,CAAC,CAAC,EACF,GAAGQ,gBAAgB,CACtB;IACDjB,aAAa,EAAE;EACnB,CAAC,CAAC,EACFc,qBAAqB,CAAC;IAClBJ,aAAa,EAAE,IAAI;IACnBK,aAAa,EAAE;EACnB,CAAC,CAAC,CACL;EAED,MAAMI,aAAa,GAAGnG,cAAc,CAAC;IACjCM,IAAI,EAAE,eAAe;IACrBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,QAAQ;IACjC0F,WAAW,EAAET,MAAM,IAAI;MACnBA,MAAM,CAACN,OAAO,CAAC,QAAQ,CAAC;MACxB,OAAO;QACH3E,IAAI,EAAE,iBAAiB;QACvByD,OAAO,EAAEL,gBAAgB,CAAC6B,MAAM,CAACd,SAAS,CAACR,UAAU,CAACgI,cAAc,CAAC;MACzE,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMC,oBAAoB,GAAG,CACzB3D,iBAAiB,CAAC;IACdC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,IAAI;EAC1E,CAAC,CAAC,EACF/C,eAAe,EACfW,eAAe,EACfqC,kBAAkB,EAClBnC,aAAa,EACb8E,wBAAwB,CAAC;IACrBC,sBAAsB,EAAE,KAAK;IAC7BR,aAAa,EAAE,KAAK;IACpBU,aAAa,EAAE,KAAK;IACpBD,aAAa,EAAE;EACnB,CAAC,CAAC,CACL;EACD,MAAMa,cAAc,GAAG,CACnB,GAAG1E,WAAW,EACdkD,mBAAmB,CAAC;IAChBE,aAAa,EAAE,KAAK;IACpBD,kBAAkB,EAAEsB;EACxB,CAAC,CAAC,EACF3D,iBAAiB,CAAC;IACdC,uBAAuB,EAAE,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI;EACvD,CAAC,CAAC,EACFwD,aAAa,EACb3C,qBAAqB,CAAC;IAClBG,uBAAuB,EAAE,KAAK;IAC9BF,oBAAoB,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC;IACrCC,iBAAiB,EAAE,IAAI;IACvBE,yBAAyB,EAAE;EAC/B,CAAC,CAAC,EACFU,qBAAqB,CAAC;IAClBE,sBAAsB,EAAE,KAAK;IAC7BD,YAAY,EAAE;EAClB,CAAC,CAAC;EACF;EACA7B,iBAAiB,CAAC;IACdC,uBAAuB,EAAE,CAAC,OAAO;EACrC,CAAC,CAAC,EACFE,4BAA4B,CAAC;IACzBC,YAAY,EAAE,CAAC,QAAQ,CAAC;IACxBd;EACJ,CAAC,CAAC,EACFH,qBAAqB,CAAC;IAClBC,4BAA4B,EAAE,KAAK;IACnCC,mBAAmB,EAAE,IAAI;IACzBC;EACJ,CAAC,CAAC,EACF8D,qBAAqB,CAAC;IAClBJ,aAAa,EAAE,KAAK;IACpBK,aAAa,EAAE;EACnB,CAAC,CAAC,EACFrB,aAAa,CAChB;EAED,MAAM6B,cAAc,GAAGvG,cAAc,CAAC;IAClCM,IAAI,EAAE,gBAAgB;IACtBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,SAAS;IAClC0F,WAAW,EAAGT,MAAM,IAAK;MACrBA,MAAM,CAACN,OAAO,CAAC,SAAS,CAAC;MACzB,MAAMF,IAAI,GAAGQ,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAACuG,MAAM,CAAC;MAC5D,IAAIzF,IAAI,CAACzE,IAAI,KAAK,eAAe,EAAE;QAC/B,MAAM,IAAIS,mBAAmB,CAACgE,IAAI,EAAE,kEAAkE,CAAC;MAC3G;MACAQ,MAAM,CAACN,OAAO,CAAC,IAAI,CAAC;MACpB,OAAO;QACH3E,IAAI,EAAE,kBAAkB;QACxByE,IAAI;QACJoD,KAAK,EAAEzE,gBAAgB,CAAC6B,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAACoI,KAAK,CAAC;MAC1E,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,SAASC,kBAAkBA,CAAC;IAAEC;EAAkB,CAAC,EAAE;IAC/C,OAAO1G,cAAc,CAAC;MAClBM,IAAI,EAAE,cAAc;MACpBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;MAC5B0F,WAAW,EAAET,MAAM,IAAI;QACnBA,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;QACnB,MAAMjE,MAAM,GAAG;UACXV,IAAI,EAAE,gBAAgB;UACtBmG,QAAQ,EAAE;QACd,CAAC;QACD,IAAIlB,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;UACrB,OAAOjE,MAAM;QACjB;QACA,MAAMwL,QAAQ,GAAGjH,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAACS,GAAG,CAAC;QAC7D,IAAI8H,QAAQ,CAAClM,IAAI,KAAK,wBAAwB,EAAE;UAC5C,IAAIkM,QAAQ,CAAC/F,QAAQ,CAAC,CAAC,CAAC,CAACnG,IAAI,KAAK,mBAAmB,EAAE;YACnDU,MAAM,CAACyF,QAAQ,GAAG+F,QAAQ,CAAC/F,QAAQ,CAACyC,GAAG,CAACtF,yBAAyB,CAAC;UACtE,CAAC,MACI;YACD5C,MAAM,CAACyF,QAAQ,GAAG+F,QAAQ,CAAC/F,QAAQ,CAACyC,GAAG,CAACxF,gBAAgB,CAAC;UAC7D;QACJ,CAAC,MACI;UACD,IAAI8I,QAAQ,CAAClM,IAAI,KAAK,mBAAmB,EAAE;YACvCU,MAAM,CAACyF,QAAQ,GAAG,CAAC7C,yBAAyB,CAAC4I,QAAQ,CAAC,CAAC;UAC3D,CAAC,MACI;YACDxL,MAAM,CAACyF,QAAQ,GAAG,CAAC/C,gBAAgB,CAAC8I,QAAQ,CAAC,CAAC;UAClD;QACJ;QACA,IAAI,CAACjH,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;UACtB,MAAM,IAAIzE,KAAK,CAAC,oBAAoB,CAAC;QACzC;QACA,IAAI,CAAC+L,iBAAiB,IAAIvL,MAAM,CAACyF,QAAQ,CAACQ,IAAI,CAAED,CAAC,IAAKA,CAAC,CAAC1G,IAAI,KAAK,kBAAkB,CAAC,EAAE;UAClF,MAAM,IAAIE,KAAK,CAAC,oCAAoC,CAAC;QACzD;QACA,OAAOQ,MAAM;MACjB;IACJ,CAAC,CAAC;EACN;EAEA,MAAMyL,YAAY,GAAG5G,cAAc,CAAC;IAChCM,IAAI,EAAE,cAAc;IACpBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,OAAO;IAChC0F,WAAW,EAAET,MAAM,IAAI;MACnBA,MAAM,CAACN,OAAO,CAAC,OAAO,CAAC;MACvB,OAAO;QACH3E,IAAI,EAAE,gBAAgB;QACtByD,OAAO,EAAEL,gBAAgB,CAAC6B,MAAM,CAACd,SAAS,CAACR,UAAU,CAACgI,cAAc,CAAC;MACzE,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMS,aAAa,GAAG7G,cAAc,CAAC;IACjCM,IAAI,EAAE,eAAe;IACrBT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,QAAQ;IACjC0F,WAAW,EAAET,MAAM,IAAI;MACnBA,MAAM,CAACN,OAAO,CAAC,QAAQ,CAAC;MACxB,IAAI,CAACM,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIzE,KAAK,CAAC,0CAA0C,CAAC;MAC/D;MACA,MAAMmM,IAAI,GAAGpH,MAAM,CAACd,SAAS,CAACR,UAAU,CAACiG,MAAM,CAAC;MAChD,IAAIyC,IAAI,CAACrM,IAAI,KAAK,sBAAsB,EAAE;QACtC,MAAM,IAAIE,KAAK,CAAC,qDAAqD,CAAC;MAC1E;MACA,IAAI,CAAC+E,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIzE,KAAK,CAAC,kDAAkD,CAAC;MACvE;MACA,OAAO;QACHF,IAAI,EAAE,iBAAiB;QACvByD,OAAO,EAAE4I;MACb,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMC,uBAAuB,GAAG/G,cAAc,CAAC;IAC3CM,IAAI,EAAE,yBAAyB;IAC/BT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,UAAU;IACnC0F,WAAW,EAAET,MAAM,IAAI;MACnBA,MAAM,CAACN,OAAO,CAAC,UAAU,CAAC;MAC1B,OAAO;QACH3E,IAAI,EAAE,2BAA2B;QACjCyD,OAAO,EAAEwB,MAAM,CAACd,SAAS,CAACR,UAAU,CAACuH,SAAS;MAClD,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMqB,oBAAoB,GAAGhH,cAAc,CAAC;IACxCM,IAAI,EAAE,sBAAsB;IAC5BxB,UAAU,EAAEV,UAAU,CAAC6I,KAAK;IAC5BpH,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,IAAI;IAC7B2F,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1BQ,MAAM,CAACN,OAAO,CAAC,IAAI,CAAC;MACpB,OAAO;QACH3E,IAAI,EAAE,mBAAmB;QACzB2I,UAAU,EAAED,aAAa,CAACjE,IAAI,CAAC,CAACmE,GAAG,CAACrF,+BAA+B,CAAC;QACpE+F,KAAK,EAAE,IAAI;QACXnJ,WAAW,EAAE,KAAK;QAClBoJ,WAAW,EAAE,IAAI;QACjBI,UAAU,EAAE1E,MAAM,CAACd,SAAS,CAACR,UAAU,CAACgH,MAAM;MAClD,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAM8B,mBAAmB,GAAGlH,cAAc,CAAC;IACvCM,IAAI,EAAE,qBAAqB;IAC3BT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;IAC5BqE,UAAU,EAAEV,UAAU,CAAC+I,YAAY;IACnC/G,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1BQ,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,MAAMwB,QAAQ,GAAG,EAAE;MACnB,GAAG;QACCA,QAAQ,CAACM,IAAI,CAACxB,MAAM,CAACd,SAAS,CAACR,UAAU,CAAC+I,YAAY,CAAC,CAAC;MAC5D,CAAC,QAAQzH,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MAC5B,OAAO;QACH3E,IAAI,EAAE,uBAAuB;QAC7BmG,QAAQ,EAAE,CAAC/C,gBAAgB,CAACqB,IAAI,CAAC,EAAE,GAAG0B,QAAQ;MAClD,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMwG,gBAAgB,GAAGpH,cAAc,CAAC;IACpCM,IAAI,EAAE,kBAAkB;IACxBxB,UAAU,EAAEV,UAAU,CAACoI,KAAK;IAC5B3G,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,IAAI;IAC7B2F,UAAU,EAAEA,CAACV,MAAM,EAAER,IAAI,KAAK;MAC1B,IAAIA,IAAI,CAACzE,IAAI,KAAK,eAAe,EAAE;QAC/B,MAAM,IAAIS,mBAAmB,CAACgE,IAAI,EAAE,oEAAoE,CAAC;MAC7G;MACAQ,MAAM,CAACN,OAAO,CAAC,IAAI,CAAC;MACpB,OAAO;QACH3E,IAAI,EAAE,oBAAoB;QAC1ByE,IAAI;QACJoD,KAAK,EAAEzE,gBAAgB,CAAC6B,MAAM,CAACX,qBAAqB,CAACX,UAAU,CAACoI,KAAK,CAAC;MAC1E,CAAC;IACL;EACJ,CAAC,CAAC;EAEF,MAAMa,4BAA4B,GAAGrH,cAAc,CAAC;IAChDM,IAAI,EAAE,oCAAoC;IAC1CT,MAAM,EAAEpF,IAAI,IAAIA,IAAI,KAAK,GAAG;IAC5B0F,WAAW,EAAET,MAAM,IAAI;MACnB,IAAIA,MAAM,CAAClB,UAAU,KAAKhE,SAAS,EAAE;QACjC,MAAM,IAAIG,KAAK,CAAC,oCAAoC,CAAC;MACzD;MACA+E,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC;MACnB,MAAM8E,GAAG,GAAGxE,MAAM,CAAChB,KAAK,CAACvB,OAAO,CAAC5C,IAAI;MACrCmF,MAAM,CAACN,OAAO,CAAC,YAAY,CAAC;MAC5B,IAAIjE,MAAM;MACV,IAAIuE,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACrB,MAAMyG,YAAY,GAAGnG,MAAM,CAAClB,UAAU;QACtCqH,YAAY,CAACpG,gBAAgB,CAACC,MAAM,CAAC;QACrCvE,MAAM,GAAG;UACLV,IAAI,EAAE,yBAAyB;UAC/ByJ,GAAG;UACH5B,KAAK,EAAEuD,YAAY,CAACjH,SAAS,CAACR,UAAU,CAACkJ,cAAc;QAC3D,CAAC;QACD5H,MAAM,CAACD,gBAAgB,CAACoG,YAAY,CAAC;MACzC,CAAC,MACI,IAAInG,MAAM,CAACN,OAAO,CAAC,IAAI,CAAC,EAAE;QAC3B,MAAMyG,YAAY,GAAGnG,MAAM,CAAClB,UAAU;QACtCqH,YAAY,CAACpG,gBAAgB,CAACC,MAAM,CAAC;QACrCvE,MAAM,GAAG;UACLV,IAAI,EAAE,qBAAqB;UAC3ByJ,GAAG;UACH5B,KAAK,EAAEuD,YAAY,CAACjH,SAAS,CAACR,UAAU,CAACyG,cAAc;QAC3D,CAAC;QACDnF,MAAM,CAACD,gBAAgB,CAACoG,YAAY,CAAC;MACzC,CAAC,MACI;QACD,MAAM,IAAIlL,KAAK,CAAC,2DAA2D,CAAC;MAChF;MACA,IAAI,CAAC+E,MAAM,CAACN,OAAO,CAAC,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIzE,KAAK,CAAC,8BAA8B,CAAC;MACnD;MACA,OAAOQ,MAAM;IACjB;EACJ,CAAC,CAAC;EAEF,MAAM4J,kBAAkB,GAAG,CACvBgC,uBAAuB,EACvBrE,iBAAiB,CAAC;IACdC,uBAAuB,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,IAAI;EACnF,CAAC,CAAC,EACF/C,eAAe,EACfW,eAAe,EACfqC,kBAAkB,EAClBnC,aAAa,EACb8E,wBAAwB,CAAC;IACrBC,sBAAsB,EAAE,IAAI;IAC5BR,aAAa,EAAE,KAAK;IACpBU,aAAa,EAAE,IAAI;IACnBD,aAAa,EAAE;EACnB,CAAC,CAAC,EACF4B,4BAA4B,CAC/B;EACD,MAAME,iBAAiB,GAAG,CACtB,GAAG3F,WAAW,EACdkD,mBAAmB,CAAC;IAChBE,aAAa,EAAE,KAAK;IACpBD;EACJ,CAAC,CAAC,EACFoB,aAAa,EACbS,YAAY,EACZC,aAAa,EACbjE,kBAAkB,EAClBY,qBAAqB,CAAC;IAClBG,uBAAuB,EAAE,IAAI;IAC7BD,iBAAiB,EAAE,KAAK;IACxBD,oBAAoB,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC;IAC7CG,yBAAyB,EAAE;EAC/B,CAAC,CAAC,EACF6C,kBAAkB,CAAC;IACfC,iBAAiB,EAAE;EACvB,CAAC,CAAC,EACFpC,qBAAqB,CAAC;IAClBE,sBAAsB,EAAE,KAAK;IAC7BD,YAAY,EAAE;EAClB,CAAC,CAAC,EACFgC,cAAc,EACd7D,iBAAiB,CAAC;IACdC,uBAAuB,EAAE,CAAC,OAAO,EAAE,UAAU,EAAE,IAAI;EACvD,CAAC,CAAC,EACFE,4BAA4B,CAAC;IACzBC,YAAY,EAAE,CAAC,QAAQ,CAAC;IACxBd;EACJ,CAAC,CAAC,EACF4C,oBAAoB,EACpBoC,oBAAoB,EACpBnF,qBAAqB,CAAC;IAClBC,4BAA4B,EAAE,IAAI;IAClCC,mBAAmB,EAAE,KAAK;IAC1BC;EACJ,CAAC,CAAC,EACFkF,mBAAmB,EACnBE,gBAAgB,EAChBtB,qBAAqB,CAAC;IAClBC,aAAa,EAAE,IAAI;IACnBL,aAAa,EAAE;EACnB,CAAC,CAAC,CACL;;EAED;AACJ;AACA;AACA;AACA;EACI,SAAS/G,KAAKA,CAAC6I,UAAU,EAAEC,IAAI,EAAE;IAC7B,QAAQA,IAAI;MACR,KAAK,SAAS;QACV,OAAQ,IAAIpJ,MAAM,CAACiI,cAAc,EAAEkB,UAAU,CAAC,CAAE7I,KAAK,CAAC,CAAC;MAC3D,KAAK,OAAO;QACR,OAAQ,IAAIN,MAAM,CAAC6H,YAAY,EAAEsB,UAAU,CAAC,CAAE7I,KAAK,CAAC,CAAC;MACzD,KAAK,YAAY;QACb,OAAQ,IAAIN,MAAM,CAACkJ,iBAAiB,EAAEC,UAAU,CAAC,CAAE7I,KAAK,CAAC,CAAC;IAClE;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,SAAS+I,QAAQA,CAACF,UAAU,EAAEG,KAAK,GAAG,CAAC,YAAY,EAAE,SAAS,EAAE,OAAO,CAAC,EAAE;IACtE,IAAItM,KAAK;IACT,KAAK,MAAMoM,IAAI,IAAIE,KAAK,EAAE;MACtB,IAAI;QACA,OAAOhJ,KAAK,CAAC6I,UAAU,EAAEC,IAAI,CAAC;MAClC,CAAC,CACD,OAAOtG,CAAC,EAAE;QACN9F,KAAK,GAAG8F,CAAC;MACb;IACJ;IACA,MAAM9F,KAAK;EACf;EAEA,SAASuM,SAASA,CAAC7K,KAAK,EAAE8K,WAAW,EAAE;IACnC,MAAMpK,IAAI,GAAGV,KAAK,CAAC8K,WAAW,CAACpN,IAAI,CAAC;IACpC,IAAIgD,IAAI,KAAKjD,SAAS,EAAE;MACpB,MAAM,IAAIG,KAAK,CAAC,0DAA0DkN,WAAW,CAACpN,IAAI,GAAG,CAAC;IAClG;IACA,OAAOgD,IAAI,CAACoK,WAAW,EAAEC,YAAY,IAAIF,SAAS,CAAC7K,KAAK,EAAE+K,YAAY,CAAC,CAAC;EAC5E;EACA,SAASC,qBAAqBA,CAACF,WAAW,EAAE;IACxC,MAAM,IAAIlN,KAAK,CAAC,2EAA2E,CAAC;EAChG;EACA,SAASqN,oBAAoBA,CAACC,MAAM,EAAE;IAClC,MAAM9M,MAAM,GAAG;MACX+M,MAAM,EAAE;IACZ,CAAC;IACD,KAAK,MAAMC,KAAK,IAAIF,MAAM,CAAC7E,UAAU,EAAE;MACnC,IAAI+E,KAAK,CAAC1N,IAAI,KAAK,mBAAmB,EAAE;QACpC,IAAI0N,KAAK,CAACjE,GAAG,KAAK,MAAM,EAAE;UACtB/I,MAAM,CAACiN,IAAI,GAAGD,KAAK,CAAC7F,KAAK;QAC7B,CAAC,MACI,IAAI6F,KAAK,CAACjE,GAAG,KAAK,KAAK,EAAE;UAC1B/I,MAAM,CAACkN,GAAG,GAAGF,KAAK,CAAC7F,KAAK;QAC5B,CAAC,MACI;UACDnH,MAAM,CAAC+M,MAAM,CAAChH,IAAI,CAACiH,KAAK,CAAC;QAC7B;MACJ,CAAC,MACI;QACDhN,MAAM,CAAC+M,MAAM,CAAChH,IAAI,CAACiH,KAAK,CAAC;MAC7B;IACJ;IACA,OAAOhN,MAAM;EACjB;EAEA,SAASmN,aAAaA,CAAC7M,QAAQ,EAAE8M,MAAM,EAAE9L,KAAK,EAAE;IAC5C,OAAOhB,QAAQ,KAAK,QAAQ,GAAGgB,KAAK,GAAG8L,MAAM,GAAGA,MAAM,GAAG9L,KAAK;EAClE;EACA,SAAS8F,KAAKA,CAAC9F,KAAK,EAAE8F,KAAK,EAAE;IACzB,QAAQA,KAAK;MACT,KAAK,QAAQ;QACT,OAAO,IAAI9F,KAAK,GAAG;MACvB,KAAK,QAAQ;QACT,OAAO,IAAIA,KAAK,GAAG;MACvB,KAAKjC,SAAS;QACV,OAAOiC,KAAK;IACpB;EACJ;EACA,SAAS+L,cAAcA,CAAA,EAAG;IACtB,OAAO;MACHC,oBAAoB,EAAEA,CAACtN,MAAM,EAAEyM,SAAS,KAAK,IAAIzM,MAAM,CAAC+C,OAAO,KAAK1D,SAAS,GAAGoN,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,GAAG,EAAE,GAAG;MACjHwK,cAAc,EAAEA,CAACvN,MAAM,EAAEyM,SAAS,KAAK,SAASA,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,EAAE;MAC3EyK,iBAAiB,EAAEA,CAACxN,MAAM,EAAEyM,SAAS,KAAK;QACtC,IAAI,CAACzM,MAAM,CAAC4I,KAAK,EAAE;UACf,IAAI6E,WAAW,GAAGzN,MAAM,CAACP,WAAW,GAAG,KAAK,GAAG,UAAU;UACzD,IAAI,CAACO,MAAM,CAAC6I,WAAW,EAAE;YACrB,OAAO4E,WAAW;UACtB;UACAA,WAAW,IAAI,IAAIzN,MAAM,CAACiI,UAAU,CAACC,GAAG,CAACuE,SAAS,CAAC,CAACzD,IAAI,CAAC,IAAI,CAAC,GAAG;UACjE,IAAIhJ,MAAM,CAACiJ,UAAU,KAAK5J,SAAS,EAAE;YACjCoO,WAAW,IAAI,KAAKhB,SAAS,CAACzM,MAAM,CAACiJ,UAAU,CAAC,EAAE;UACtD;UACA,OAAOwE,WAAW;QACtB,CAAC,MACI;UACD,IAAIzN,MAAM,CAACiJ,UAAU,KAAK5J,SAAS,EAAE;YACjC,MAAM,IAAIG,KAAK,CAAC,qCAAqC,CAAC;UAC1D;UACA,IAAIiO,WAAW,GAAG,IAAIzN,MAAM,CAACiI,UAAU,CAACC,GAAG,CAACuE,SAAS,CAAC,CAACzD,IAAI,CAAC,IAAI,CAAC,QAAQyD,SAAS,CAACzM,MAAM,CAACiJ,UAAU,CAAC,EAAE;UACvG,IAAIjJ,MAAM,CAACP,WAAW,EAAE;YACpBgO,WAAW,GAAG,MAAM,GAAGA,WAAW;UACtC;UACA,OAAOA,WAAW;QACtB;MACJ,CAAC;MACDC,aAAa,EAAE1N,MAAM,IAAIA,MAAM,CAACsB,KAAK;MACrCqM,cAAc,EAAEA,CAAC3N,MAAM,EAAEyM,SAAS,KAAK,IAAIzM,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC,CAACzD,IAAI,CAAC,IAAI,CAAC,GAAG;MACvF4E,iBAAiB,EAAEA,CAAC5N,MAAM,EAAEyM,SAAS,KAAKzM,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,KAAKjB,SAAS,GACtE,KAAK,GACL8N,aAAa,CAACnN,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,EAAEmM,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,EAAE,KAAK,CAAC;MAC3E8K,iBAAiB,EAAEA,CAAC7N,MAAM,EAAEyM,SAAS,KAAK;QACtC,MAAM1I,IAAI,GAAG0I,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;QACnC,MAAMoD,KAAK,GAAGsF,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC;QACrC,QAAQnH,MAAM,CAACgH,QAAQ;UACnB,KAAK,OAAO;YACR,OAAO,GAAGjD,IAAI,IAAIoD,KAAK,EAAE;UAC7B,KAAK,UAAU;YACX,OAAO,GAAGpD,IAAI,IAAIoD,KAAK,EAAE;UAC7B,KAAK,UAAU;YACX,OAAO,GAAGpD,IAAI,IAAIoD,KAAK,EAAE;UAC7B,KAAK,mBAAmB;YACpB,OAAO,GAAGpD,IAAI,IAAIoD,KAAK,GAAG;QAClC;MACJ,CAAC;MACD2G,oBAAoB,EAAE9N,MAAM,IAAIoH,KAAK,CAACpH,MAAM,CAACsB,KAAK,EAAEtB,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC;MACtE2G,YAAY,EAAEA,CAAA,KAAM,GAAG;MACvBC,gBAAgB,EAAEA,CAAChO,MAAM,EAAEyM,SAAS,KAAK;QACrC,IAAIzM,MAAM,CAAC4E,IAAI,CAAC0B,QAAQ,KAAK,QAAQ,EAAE;UACnC,MAAMvD,OAAO,GAAG/C,MAAM,CAACyF,QAAQ,CAAC,CAAC,CAAC;UAClC,MAAMwI,WAAW,GAAGxB,SAAS,CAAC1J,OAAO,CAAC;UACtC,IAAIA,OAAO,CAACzD,IAAI,KAAK,gBAAgB,IAAIyD,OAAO,CAACzD,IAAI,KAAK,uBAAuB,EAAE;YAC/E,OAAO,IAAI2O,WAAW,KAAK;UAC/B,CAAC,MACI;YACD,OAAO,GAAGA,WAAW,IAAI;UAC7B;QACJ,CAAC,MACI;UACD,OAAO,GAAGxB,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC,GAAG/D,MAAM,CAAC4E,IAAI,CAACwB,GAAG,GAAG,GAAG,GAAG,EAAE,IAAIpG,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC,CAACzD,IAAI,CAAC,IAAI,CAAC,GAAG;QACjH;MACJ,CAAC;MACDkF,eAAe,EAAEA,CAAClO,MAAM,EAAEyM,SAAS,KAAK,UAAUA,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,GAAG;MAC9EoL,oBAAoB,EAAEA,CAACnO,MAAM,EAAEyM,SAAS,KAAK;QACzC,IAAIrN,IAAI,GAAG,EAAE;QACb,IAAIY,MAAM,CAACmK,QAAQ,EAAE;UACjB/K,IAAI,IAAI,WAAW;QACvB;QACA,IAAI,OAAOY,MAAM,CAAC+I,GAAG,KAAK,QAAQ,EAAE;UAChC3J,IAAI,IAAIgI,KAAK,CAACpH,MAAM,CAAC+I,GAAG,EAAE/I,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC;QAChD,CAAC,MACI;UACDhI,IAAI,IAAIqN,SAAS,CAACzM,MAAM,CAAC+I,GAAG,CAAC;QACjC;QACA,IAAI/I,MAAM,CAACkK,QAAQ,EAAE;UACjB9K,IAAI,IAAI,GAAG;QACf;QACA,IAAIY,MAAM,CAACmH,KAAK,KAAK9H,SAAS,EAAE;UAC5B,OAAOD,IAAI;QACf,CAAC,MACI;UACD,OAAOA,IAAI,GAAG,KAAKqN,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC,EAAE;QAChD;MACJ,CAAC;MACDiH,yBAAyB,EAAEA,CAACpO,MAAM,EAAEyM,SAAS,KAAK;QAC9C,OAAO,GAAGA,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC,KAAK0I,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC,EAAE;MAClE,CAAC;MACDkH,iBAAiB,EAAEA,CAACrO,MAAM,EAAEyM,SAAS,KAAK;QACtC,IAAIrN,IAAI,GAAGY,MAAM,CAAC+I,GAAG;QACrB,IAAI/I,MAAM,CAACkK,QAAQ,EAAE;UACjB9K,IAAI,IAAI,GAAG;QACf;QACA,IAAIY,MAAM,CAAC6K,QAAQ,EAAE;UACjBzL,IAAI,GAAG,KAAK,GAAGA,IAAI;QACvB;QACA,IAAIY,MAAM,CAACmH,KAAK,KAAK9H,SAAS,EAAE;UAC5B,OAAOD,IAAI;QACf,CAAC,MACI;UACD,OAAOA,IAAI,GAAG,KAAKqN,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC,EAAE;QAChD;MACJ,CAAC;MACDmH,wBAAwB,EAAEtO,MAAM,IAAI,GAAGA,MAAM,CAACsH,WAAW,IAAIF,KAAK,CAACpH,MAAM,CAACsB,KAAK,EAAEtB,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC,EAAE;MACrGmH,oBAAoB,EAAEA,CAACvO,MAAM,EAAEyM,SAAS,KAAKU,aAAa,CAACnN,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,EAAEmM,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,EAAE,GAAG,CAAC;MAChHyL,aAAa,EAAEA,CAAA,KAAM,MAAM;MAC3BC,iBAAiB,EAAEA,CAACzO,MAAM,EAAEyM,SAAS,KAAKU,aAAa,CAACnN,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,EAAEmM,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,EAAE,GAAG,CAAC;MAC7G2L,eAAe,EAAE1O,MAAM,IAAIA,MAAM,CAACsB,KAAK,CAAC+F,QAAQ,CAAC,CAAC;MAClDsH,eAAe,EAAEA,CAAC3O,MAAM,EAAEyM,SAAS,KAAK,IAAIzM,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC,CAACzD,IAAI,CAAC,CAAChJ,MAAM,CAAC4E,IAAI,CAACkF,SAAS,KAAK,OAAO,GAAG,GAAG,GAAG,GAAG,IAAI,GAAG,CAAC,GAAG;MACzI8E,iBAAiB,EAAEA,CAAC5O,MAAM,EAAEyM,SAAS,KAAKU,aAAa,CAACnN,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,EAAEmM,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,EAAE,GAAG,CAAC;MAC7G8L,eAAe,EAAEA,CAAC7O,MAAM,EAAEyM,SAAS,KAAK,GAAGzM,MAAM,CAACsB,KAAK,IAAItB,MAAM,CAAC+C,OAAO,KAAK1D,SAAS,GAAGoN,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,GAAG,EAAE,GAAG;MAC3H+L,eAAe,EAAEA,CAAC9O,MAAM,EAAEyM,SAAS,KAAK,UAAUA,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC,EAAE;MAC7EgM,kBAAkB,EAAEA,CAAA,KAAM,WAAW;MACrCC,cAAc,EAAEA,CAAChP,MAAM,EAAEyM,SAAS,KAAKzM,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC,CAACzD,IAAI,CAAC,KAAK,CAAC;MACjFiG,gBAAgB,EAAEA,CAAA,KAAM,GAAG;MAC3BC,qBAAqB,EAAEA,CAAClP,MAAM,EAAEyM,SAAS,KAAKzM,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC,CAACzD,IAAI,CAAC,KAAK,CAAC;MACxFmG,iBAAiB,EAAEnP,MAAM,IAAIoH,KAAK,CAACpH,MAAM,CAACsB,KAAK,EAAEtB,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC;MACnEgI,kBAAkB,EAAEA,CAACpP,MAAM,EAAEyM,SAAS,KAAK,GAAGA,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC,OAAO0I,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC,EAAE;MACpGkI,uBAAuB,EAAEA,CAACrP,MAAM,EAAEyM,SAAS,KAAK,IAAIzM,MAAM,CAAC+I,GAAG,KAAK0D,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC,GAAG;MAC7FmI,mBAAmB,EAAEA,CAACtP,MAAM,EAAEyM,SAAS,KAAK,IAAIzM,MAAM,CAAC+I,GAAG,OAAO0D,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC,GAAG;MAC3FoI,gBAAgB,EAAEA,CAACvP,MAAM,EAAEyM,SAAS,KAAK,WAAWA,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC,OAAO0I,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC;IAC5G,CAAC;EACL;EACA,MAAMqI,oBAAoB,GAAGnC,cAAc,CAAC,CAAC;EAC7C,SAASoC,SAASA,CAACzP,MAAM,EAAE;IACvB,OAAOyM,SAAS,CAAC+C,oBAAoB,EAAExP,MAAM,CAAC;EAClD;EAEA,MAAM0P,aAAa,GAAG,CAClB,MAAM,EACN,MAAM,EACN,OAAO,EACP,OAAO,EACP,MAAM,EACN,OAAO,EACP,OAAO,EACP,OAAO,EACP,UAAU,EACV,UAAU,EACV,SAAS,EACT,QAAQ,EACR,IAAI,EACJ,MAAM,EACN,QAAQ,EACR,SAAS,EACT,SAAS,EACT,KAAK,EACL,UAAU,EACV,IAAI,EACJ,QAAQ,EACR,IAAI,EACJ,YAAY,EACZ,KAAK,EACL,QAAQ,EACR,OAAO,EACP,QAAQ,EACR,MAAM,EACN,OAAO,EACP,KAAK,EACL,QAAQ,EACR,KAAK,EACL,MAAM,EACN,OAAO,EACP,MAAM,EACN,OAAO,CACV;EACD,SAASC,QAAQA,CAACrO,KAAK,EAAE;IACrB,MAAMtB,MAAM,GAAG;MACXV,IAAI,EAAE,gBAAgB;MACtB6F,IAAI,EAAE7D;IACV,CAAC;IACD,IAAIoO,aAAa,CAACrL,QAAQ,CAAC/C,KAAK,CAAC,EAAE;MAC/BtB,MAAM,CAAC4P,YAAY,GAAG,IAAI;IAC9B;IACA,OAAO5P,MAAM;EACjB;EACA,MAAM6P,uBAAuB,GAAG;IAC5BjB,iBAAiB,EAAEA,CAAC5O,MAAM,EAAEyM,SAAS,KAAK;MACtC,MAAMwB,WAAW,GAAGxB,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MAC7CkL,WAAW,CAAC/D,QAAQ,GAAG,IAAI;MAC3B,OAAO+D,WAAW;IACtB,CAAC;IACDQ,iBAAiB,EAAEA,CAACzO,MAAM,EAAEyM,SAAS,KAAK;MACtC,MAAMwB,WAAW,GAAGxB,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MAC7CkL,WAAW,CAAC6B,QAAQ,GAAG,IAAI;MAC3B,OAAO7B,WAAW;IACtB,CAAC;IACDM,oBAAoB,EAAEA,CAACvO,MAAM,EAAEyM,SAAS,KAAK;MACzC,MAAMwB,WAAW,GAAGxB,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MAC7CkL,WAAW,CAAC6B,QAAQ,GAAG,KAAK;MAC5B,OAAO7B,WAAW;IACtB,CAAC;IACDL,iBAAiB,EAAEA,CAAC5N,MAAM,EAAEyM,SAAS,KAAK;MACtC,IAAIzM,MAAM,CAAC+C,OAAO,KAAK1D,SAAS,EAAE;QAC9B,MAAM,IAAIG,KAAK,CAAC,sDAAsD,CAAC;MAC3E;MACA,MAAMyO,WAAW,GAAGxB,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MAC7CkL,WAAW,CAAC8B,UAAU,GAAG,IAAI;MAC7B,OAAO9B,WAAW;IACtB,CAAC;IACDF,YAAY,EAAEA,CAAA,MAAO;MACjBzO,IAAI,EAAE;IACV,CAAC,CAAC;IACFkP,aAAa,EAAEA,CAAA,MAAO;MAClBlP,IAAI,EAAE;IACV,CAAC,CAAC;IACFwO,oBAAoB,EAAE9N,MAAM,IAAI2P,QAAQ,CAACvI,KAAK,CAACpH,MAAM,CAACsB,KAAK,EAAEtB,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC,CAAC;IAChF2H,kBAAkB,EAAEA,CAAA,MAAO;MACvBzP,IAAI,EAAE;IACV,CAAC,CAAC;IACF2P,gBAAgB,EAAEA,CAAA,MAAO;MACrB3P,IAAI,EAAE;IACV,CAAC,CAAC;IACFkO,iBAAiB,EAAEA,CAACxN,MAAM,EAAEyM,SAAS,KAAK;MACtC,MAAMM,MAAM,GAAGF,oBAAoB,CAAC7M,MAAM,CAAC;MAC3C,MAAMiO,WAAW,GAAG;QAChB3O,IAAI,EAAE,cAAc;QACpByN,MAAM,EAAEA,MAAM,CAACA,MAAM,CAAC7E,GAAG,CAACuE,SAAS;MACvC,CAAC;MACD,IAAIM,MAAM,CAACE,IAAI,KAAK5N,SAAS,EAAE;QAC3B4O,WAAW,CAAChB,IAAI,GAAGR,SAAS,CAACM,MAAM,CAACE,IAAI,CAAC;MAC7C;MACA,IAAIF,MAAM,CAACG,GAAG,KAAK7N,SAAS,EAAE;QAC1B4O,WAAW,CAACf,GAAG,GAAGT,SAAS,CAACM,MAAM,CAACG,GAAG,CAAC;MAC3C;MACA,IAAIlN,MAAM,CAACiJ,UAAU,KAAK5J,SAAS,EAAE;QACjC4O,WAAW,CAACjO,MAAM,GAAGyM,SAAS,CAACzM,MAAM,CAACiJ,UAAU,CAAC;MACrD;MACA,OAAOgF,WAAW;IACtB,CAAC;IACDD,gBAAgB,EAAEA,CAAChO,MAAM,EAAEyM,SAAS,MAAM;MACtCnN,IAAI,EAAE,iBAAiB;MACvB0Q,YAAY,EAAEhQ,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAAC+H,CAAC,IAAIxD,SAAS,CAACwD,CAAC,CAAC,CAAC;MACpD5D,UAAU,EAAEI,SAAS,CAACzM,MAAM,CAAC+D,IAAI;IACrC,CAAC,CAAC;IACFuK,wBAAwB,EAAEtO,MAAM,IAAI2P,QAAQ,CAAC3P,MAAM,CAACsH,WAAW,GAAG,GAAG,GAAGF,KAAK,CAACpH,MAAM,CAACsB,KAAK,EAAEtB,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC,CAAC;IAC/GsG,aAAa,EAAE1N,MAAM,IAAI;MACrB,IAAIA,MAAM,CAACsB,KAAK,KAAK,UAAU,EAAE;QAC7B,OAAOqO,QAAQ,CAAC3P,MAAM,CAACsB,KAAK,CAAC;MACjC,CAAC,MACI;QACD,OAAO;UACHhC,IAAI,EAAE,cAAc;UACpByN,MAAM,EAAE;QACZ,CAAC;MACL;IACJ,CAAC;IACD2B,eAAe,EAAE1O,MAAM,IAAI2P,QAAQ,CAAC3P,MAAM,CAACsB,KAAK,CAAC+F,QAAQ,CAAC,CAAC,CAAC;IAC5DsH,eAAe,EAAEA,CAAC3O,MAAM,EAAEyM,SAAS,KAAK;MACpC,MAAMwB,WAAW,GAAG;QAChB3O,IAAI,EAAE,YAAY;QAClB4Q,MAAM,EAAE;MACZ,CAAC;MACD,KAAK,MAAMlG,KAAK,IAAIhK,MAAM,CAACyF,QAAQ,EAAE;QACjC,IAAIuE,KAAK,CAAC1K,IAAI,KAAK,sBAAsB,IAAI0K,KAAK,CAAC1K,IAAI,KAAK,2BAA2B,EAAE;UACrF2O,WAAW,CAACiC,MAAM,CAACnK,IAAI,CAAC;YACpBzG,IAAI,EAAE,WAAW;YACjByJ,GAAG,EAAE0D,SAAS,CAACzC,KAAK,CAAC;YACrB1I,KAAK,EAAEjC;UACX,CAAC,CAAC;QACN,CAAC,MACI;UACD4O,WAAW,CAACiC,MAAM,CAACnK,IAAI,CAAC0G,SAAS,CAACzC,KAAK,CAAC,CAAC;QAC7C;MACJ;MACA,OAAOiE,WAAW;IACtB,CAAC;IACDE,oBAAoB,EAAEA,CAACnO,MAAM,EAAEyM,SAAS,KAAK;MACzC,IAAI,OAAOzM,MAAM,CAAC+I,GAAG,KAAK,QAAQ,EAAE;QAChC,MAAM,IAAIvJ,KAAK,CAAC,qDAAqD,CAAC;MAC1E;MACA,OAAO;QACHF,IAAI,EAAE,WAAW;QACjByJ,GAAG,EAAE4G,QAAQ,CAACvI,KAAK,CAACpH,MAAM,CAAC+I,GAAG,EAAE/I,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC,CAAC;QACnD9F,KAAK,EAAEtB,MAAM,CAACmH,KAAK,KAAK9H,SAAS,GAAGA,SAAS,GAAGoN,SAAS,CAACzM,MAAM,CAACmH,KAAK;MAC1E,CAAC;IACL,CAAC;IACDiH,yBAAyB,EAAEA,CAACpO,MAAM,EAAEyM,SAAS,MAAM;MAC/CnN,IAAI,EAAE,WAAW;MACjByJ,GAAG,EAAE0D,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;MAC3BzC,KAAK,EAAEmL,SAAS,CAACzM,MAAM,CAACmH,KAAK;IACjC,CAAC,CAAC;IACF6H,cAAc,EAAEA,CAAChP,MAAM,EAAEyM,SAAS,MAAM;MACpCnN,IAAI,EAAE,WAAW;MACjBmG,QAAQ,EAAEzF,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAAClC,CAAC,IAAIyG,SAAS,CAACzG,CAAC,CAAC;IACnD,CAAC,CAAC;IACFqI,iBAAiB,EAAEA,CAACrO,MAAM,EAAEyM,SAAS,KAAK;MACtC,OAAO;QACHnN,IAAI,EAAE,WAAW;QACjByJ,GAAG,EAAE4G,QAAQ,CAAC3P,MAAM,CAAC+I,GAAG,CAAC;QACzBzH,KAAK,EAAEtB,MAAM,CAACmH,KAAK,KAAK9H,SAAS,GAAGA,SAAS,GAAGoN,SAAS,CAACzM,MAAM,CAACmH,KAAK;MAC1E,CAAC;IACL,CAAC;IACD0G,iBAAiB,EAAEA,CAAC7N,MAAM,EAAEyM,SAAS,KAAK;MACtC,MAAM0D,UAAU,GAAG1D,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;MACzC,IAAIqM,UAAU;MACd,IAAIpQ,MAAM,CAACmH,KAAK,CAAC7H,IAAI,KAAK,0BAA0B,EAAE;QAClD8Q,UAAU,GAAG3D,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC,CAAChC,IAAI;MAC7C,CAAC,MACI;QACDiL,UAAU,GAAGhJ,KAAK,CAACpH,MAAM,CAACmH,KAAK,CAAC7F,KAAK,EAAEtB,MAAM,CAACmH,KAAK,CAACvC,IAAI,CAACwC,KAAK,CAAC;MACnE;MACA,MAAMiJ,MAAM,GAAGrQ,MAAM,CAACgH,QAAQ,KAAK,OAAO,GAAG,GAAG,GAAGhH,MAAM,CAACgH,QAAQ,KAAK,UAAU,GAAG,GAAG,GAAG,GAAG;MAC7F,OAAO2I,QAAQ,CAAC,GAAGQ,UAAU,CAAChL,IAAI,GAAGkL,MAAM,GAAGD,UAAU,EAAE,CAAC;IAC/D,CAAC;IACDvB,eAAe,EAAE7O,MAAM,IAAI;MACvB,IAAIsB,KAAK,GAAG,EAAE;MACd,IAAIyB,OAAO,GAAG/C,MAAM,CAAC+C,OAAO;MAC5B,IAAIuN,YAAY,GAAG,KAAK;MACxB,IAAI,CAACvN,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACzD,IAAI,MAAM,mBAAmB,EAAE;QAC1F,IAAIyD,OAAO,CAAC6B,IAAI,CAACtE,QAAQ,KAAK,QAAQ,EAAE;UACpCgB,KAAK,GAAG,KAAK;QACjB,CAAC,MACI;UACDgP,YAAY,GAAG,IAAI;QACvB;QACAvN,OAAO,GAAGA,OAAO,CAACA,OAAO;MAC7B;MACA,IAAI,CAACA,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACzD,IAAI,MAAM,eAAe,EAAE;QACtFgC,KAAK,IAAIyB,OAAO,CAACzB,KAAK;MAC1B,CAAC,MACI,IAAI,CAACyB,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACzD,IAAI,MAAM,iBAAiB,EAAE;QAC7FgC,KAAK,IAAIyB,OAAO,CAACzB,KAAK,CAAC+F,QAAQ,CAAC,CAAC;MACrC;MACA,IAAIiJ,YAAY,EAAE;QACdhP,KAAK,IAAI,KAAK;MAClB;MACA,OAAOqO,QAAQ,CAAC,GAAG3P,MAAM,CAACsB,KAAK,IAAIA,KAAK,GAAG,CAAC;IAChD,CAAC;IACDgM,oBAAoB,EAAEA,CAACtN,MAAM,EAAEyM,SAAS,KAAKA,SAAS,CAAC/J,gBAAgB,CAAC1C,MAAM,CAAC+C,OAAO,CAAC,CAAC;IACxFuM,mBAAmB,EAAE1C,qBAAqB;IAC1CyC,uBAAuB,EAAEzC,qBAAqB;IAC9CsB,eAAe,EAAEtB,qBAAqB;IACtCW,cAAc,EAAEX,qBAAqB;IACrCe,cAAc,EAAEf,qBAAqB;IACrCkC,eAAe,EAAElC,qBAAqB;IACtCsC,qBAAqB,EAAEtC,qBAAqB;IAC5CuC,iBAAiB,EAAEvC,qBAAqB;IACxCwC,kBAAkB,EAAExC,qBAAqB;IACzC2C,gBAAgB,EAAE3C;EACtB,CAAC;EACD,SAAS2D,kBAAkBA,CAACvQ,MAAM,EAAE;IAChC,OAAOyM,SAAS,CAACoD,uBAAuB,EAAE7P,MAAM,CAAC;EACrD;EAEA,SAASwQ,aAAaA,CAACpJ,KAAK,EAAE;IAC1B,QAAQA,KAAK;MACT,KAAK/H,SAAS;QACV,OAAO,MAAM;MACjB,KAAK,QAAQ;QACT,OAAO,QAAQ;MACnB,KAAK,QAAQ;QACT,OAAO,QAAQ;IACvB;EACJ;EACA,SAASoR,aAAaA,CAACnR,IAAI,EAAE;IACzB,QAAQA,IAAI;MACR,KAAK,OAAO;QACR,OAAO,cAAc;MACzB,KAAK,UAAU;QACX,OAAO,iBAAiB;MAC5B,KAAK,UAAU;QACX,OAAO,QAAQ;MACnB,KAAK,mBAAmB;QACpB,OAAO,QAAQ;IACvB;EACJ;EACA,SAASoR,WAAWA,CAACpR,IAAI,EAAEqR,OAAO,EAAE;IAChC,IAAIA,OAAO,CAACjQ,MAAM,KAAK,CAAC,EAAE;MACtB,OAAO;QACHpB,IAAI;QACJyE,IAAI,EAAE4M,OAAO,CAAC,CAAC,CAAC;QAChBxJ,KAAK,EAAEwJ,OAAO,CAAC,CAAC;MACpB,CAAC;IACL,CAAC,MACI;MACD,OAAO;QACHrR,IAAI;QACJyE,IAAI,EAAE4M,OAAO,CAAC,CAAC,CAAC;QAChBxJ,KAAK,EAAEuJ,WAAW,CAACpR,IAAI,EAAEqR,OAAO,CAAChQ,KAAK,CAAC,CAAC,CAAC;MAC7C,CAAC;IACL;EACJ;EACA,MAAMiQ,QAAQ,GAAG;IACbhC,iBAAiB,EAAEA,CAAC5O,MAAM,EAAEyM,SAAS,MAAM;MACvCnN,IAAI,EAAE,UAAU;MAChBgC,KAAK,EAAEmL,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MAChC6B,IAAI,EAAE;QACFiM,MAAM,EAAE7Q,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,KAAK,QAAQ,GAAG,mBAAmB,GAAG;MACtE;IACJ,CAAC,CAAC;IACFmO,iBAAiB,EAAEA,CAACzO,MAAM,EAAEyM,SAAS,MAAM;MACvCnN,IAAI,EAAE,UAAU;MAChBgC,KAAK,EAAEmL,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MAChC6B,IAAI,EAAE;QACFiM,MAAM,EAAE7Q,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,KAAK,QAAQ,GAAG,sBAAsB,GAAG;MACzE;IACJ,CAAC,CAAC;IACFiO,oBAAoB,EAAEA,CAACvO,MAAM,EAAEyM,SAAS,MAAM;MAC1CnN,IAAI,EAAE,cAAc;MACpBgC,KAAK,EAAEmL,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MAChC6B,IAAI,EAAE;QACFiM,MAAM,EAAE7Q,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,KAAK,QAAQ,GAAG,aAAa,GAAG;MAChE;IACJ,CAAC,CAAC;IACFsN,iBAAiB,EAAEA,CAAC5N,MAAM,EAAEyM,SAAS,KAAK;MACtC,MAAMwB,WAAW,GAAG;QAChB3O,IAAI,EAAE,UAAU;QAChBsF,IAAI,EAAE;UACFiM,MAAM,EAAE7Q,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,KAAK,QAAQ,GACnC,aAAa,GACbN,MAAM,CAAC4E,IAAI,CAACtE,QAAQ,KAAK,QAAQ,GAAG,aAAa,GAAG;QAC9D;MACJ,CAAC;MACD,IAAIN,MAAM,CAAC+C,OAAO,KAAK1D,SAAS,EAAE;QAC9B4O,WAAW,CAAC3M,KAAK,GAAGmL,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;MACjD;MACA,OAAOkL,WAAW;IACtB,CAAC;IACDP,aAAa,EAAE1N,MAAM,KAAK;MACtBV,IAAI,EAAE,MAAM;MACZ6F,IAAI,EAAEnF,MAAM,CAACsB;IACjB,CAAC,CAAC;IACFwN,eAAe,EAAEA,CAAC9O,MAAM,EAAEyM,SAAS,MAAM;MACrCnN,IAAI,EAAE,YAAY;MAClB6F,IAAI,EAAEsH,SAAS,CAACzM,MAAM,CAAC+C,OAAO;IAClC,CAAC,CAAC;IACF4K,cAAc,EAAEA,CAAC3N,MAAM,EAAEyM,SAAS,MAAM;MACpCnN,IAAI,EAAE,OAAO;MACbwR,OAAO,EAAE9Q,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS;IAC1C,CAAC,CAAC;IACFc,cAAc,EAAEA,CAACvN,MAAM,EAAEyM,SAAS,MAAM;MACpCnN,IAAI,EAAE,WAAW;MACjBgC,KAAK,EAAEmL,SAAS,CAACzM,MAAM,CAAC+C,OAAO;IACnC,CAAC,CAAC;IACFmL,eAAe,EAAElO,MAAM,KAAK;MACxBV,IAAI,EAAE,QAAQ;MACdqM,IAAI,EAAE;QACFrM,IAAI,EAAE,cAAc;QACpByR,UAAU,EAAEP,aAAa,CAACxQ,MAAM,CAAC+C,OAAO,CAAC6B,IAAI,CAACwC,KAAK,CAAC;QACpD4J,MAAM,EAAEhR,MAAM,CAAC+C,OAAO,CAACzB;MAC3B;IACJ,CAAC,CAAC;IACFyN,kBAAkB,EAAEA,CAAA,MAAO;MACvBzP,IAAI,EAAE,MAAM;MACZ6F,IAAI,EAAE;IACV,CAAC,CAAC;IACF4I,YAAY,EAAEA,CAAA,MAAO;MACjBzO,IAAI,EAAE;IACV,CAAC,CAAC;IACFkO,iBAAiB,EAAEA,CAACxN,MAAM,EAAEyM,SAAS,KAAK;MACtC,MAAMwE,aAAa,GAAGpE,oBAAoB,CAAC7M,MAAM,CAAC;MAClD,MAAMiO,WAAW,GAAG;QAChB3O,IAAI,EAAEU,MAAM,CAAC4I,KAAK,GAAG,OAAO,GAAG,UAAU;QACzCmE,MAAM,EAAEkE,aAAa,CAAClE,MAAM,CAAC7E,GAAG,CAAC8E,KAAK,IAAI;UACtC,IAAIA,KAAK,CAAC1N,IAAI,KAAK,mBAAmB,EAAE;YACpC,IAAI0N,KAAK,CAAC7F,KAAK,KAAK9H,SAAS,EAAE;cAC3B,MAAM,IAAIG,KAAK,CAAC,sEAAsE,CAAC;YAC3F;YACA,OAAO;cACHF,IAAI,EAAE,iBAAiB;cACvB6F,IAAI,EAAE6H,KAAK,CAACjE,GAAG;cACfmI,QAAQ,EAAEzE,SAAS,CAACO,KAAK,CAAC7F,KAAK;YACnC,CAAC;UACL,CAAC,MACI;YACD,OAAOsF,SAAS,CAACO,KAAK,CAAC;UAC3B;QACJ,CAAC,CAAC;QACFE,GAAG,EAAE,IAAI;QACTiE,OAAO,EAAE;MACb,CAAC;MACD,IAAIF,aAAa,CAAChE,IAAI,KAAK5N,SAAS,EAAE;QAClC4O,WAAW,CAAChB,IAAI,GAAGR,SAAS,CAACwE,aAAa,CAAChE,IAAI,CAAC;MACpD,CAAC,MACI,IAAI,CAACjN,MAAM,CAAC4I,KAAK,EAAE;QACpBqF,WAAW,CAAChB,IAAI,GAAG,IAAI;MAC3B;MACA,IAAIgE,aAAa,CAAC/D,GAAG,KAAK7N,SAAS,EAAE;QACjC4O,WAAW,CAACf,GAAG,GAAGT,SAAS,CAACwE,aAAa,CAAC/D,GAAG,CAAC;MAClD;MACA,IAAIlN,MAAM,CAACiJ,UAAU,KAAK5J,SAAS,EAAE;QACjC4O,WAAW,CAACkD,OAAO,GAAG1E,SAAS,CAACzM,MAAM,CAACiJ,UAAU,CAAC;MACtD;MACA,OAAOgF,WAAW;IACtB,CAAC;IACDD,gBAAgB,EAAEA,CAAChO,MAAM,EAAEyM,SAAS,KAAK;MACrC,MAAMwB,WAAW,GAAG;QAChB3O,IAAI,EAAE,SAAS;QACf8R,OAAO,EAAE3E,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;QAC/BsC,OAAO,EAAErG,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC;QACvC7H,IAAI,EAAE;UACFiM,MAAM,EAAE7Q,MAAM,CAAC4E,IAAI,CAAC0B,QAAQ,KAAK,QAAQ,GAAG,gBAAgB,GAAGtG,MAAM,CAAC4E,IAAI,CAACwB,GAAG,GAAG,wBAAwB,GAAG;QAChH;MACJ,CAAC;MACD,IAAIpG,MAAM,CAAC4E,IAAI,CAAC0B,QAAQ,KAAK,QAAQ,IAAItG,MAAM,CAACyF,QAAQ,CAAC,CAAC,CAAC,CAACnG,IAAI,KAAK,mBAAmB,IAAI,CAACU,MAAM,CAACyF,QAAQ,CAAC,CAAC,CAAC,CAACoD,WAAW,EAAE;QACzHoF,WAAW,CAAC5H,OAAO,CAAC,CAAC,CAAC,GAAG;UACrB/G,IAAI,EAAE,MAAM;UACZ6F,IAAI,EAAE;QACV,CAAC;MACL;MACA,OAAO8I,WAAW;IACtB,CAAC;IACDE,oBAAoB,EAAEA,CAACnO,MAAM,EAAEyM,SAAS,KAAK;MACzC,IAAI,OAAOzM,MAAM,CAAC+I,GAAG,KAAK,QAAQ,EAAE;QAChC,MAAM,IAAIvJ,KAAK,CAAC,qDAAqD,CAAC;MAC1E;MACA,IAAIQ,MAAM,CAACmH,KAAK,KAAK9H,SAAS,EAAE;QAC5B,OAAO;UACHC,IAAI,EAAE,cAAc;UACpByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG;UACfgI,UAAU,EAAEP,aAAa,CAACxQ,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC;UAC5C9F,KAAK,EAAE,IAAI;UACX6I,QAAQ,EAAE;QACd,CAAC;MACL;MACA,IAAIhD,KAAK,GAAGsF,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC;MACnC,IAAInH,MAAM,CAACkK,QAAQ,EAAE;QACjB/C,KAAK,GAAG;UACJ7H,IAAI,EAAE,UAAU;UAChBgC,KAAK,EAAE6F,KAAK;UACZvC,IAAI,EAAE;YACFiM,MAAM,EAAE;UACZ;QACJ,CAAC;MACL;MACA,OAAO;QACHvR,IAAI,EAAE,cAAc;QACpByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG,CAAC1B,QAAQ,CAAC,CAAC;QAC1B0J,UAAU,EAAEP,aAAa,CAACxQ,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC;QAC5C9F,KAAK,EAAE6F,KAAK;QACZgD,QAAQ,EAAE;MACd,CAAC;IACL,CAAC;IACDiE,yBAAyB,EAAEA,CAAA,KAAM;MAC7B,MAAM,IAAI5O,KAAK,CAAC,2CAA2C,CAAC;IAChE,CAAC;IACD6O,iBAAiB,EAAEA,CAACrO,MAAM,EAAEyM,SAAS,KAAK;MACtC,IAAIzM,MAAM,CAACmH,KAAK,KAAK9H,SAAS,EAAE;QAC5B,OAAO;UACHC,IAAI,EAAE,cAAc;UACpByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG;UACfgI,UAAU,EAAE,MAAM;UAClBzP,KAAK,EAAE,IAAI;UACX6I,QAAQ,EAAE;QACd,CAAC;MACL;MACA,IAAIhD,KAAK,GAAGsF,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC;MACnC,IAAInH,MAAM,CAACkK,QAAQ,EAAE;QACjB/C,KAAK,GAAG;UACJ7H,IAAI,EAAE,UAAU;UAChBgC,KAAK,EAAE6F,KAAK;UACZvC,IAAI,EAAE;YACFiM,MAAM,EAAE;UACZ;QACJ,CAAC;MACL;MACA,OAAO;QACHvR,IAAI,EAAE,cAAc;QACpByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG;QACfgI,UAAU,EAAE,MAAM;QAClBzP,KAAK,EAAE6F,KAAK;QACZgD,QAAQ,EAAE;MACd,CAAC;IACL,CAAC;IACDwE,eAAe,EAAEA,CAAC3O,MAAM,EAAEyM,SAAS,KAAK;MACpC,MAAMqE,OAAO,GAAG,EAAE;MAClB,KAAK,MAAM9G,KAAK,IAAIhK,MAAM,CAACyF,QAAQ,EAAE;QACjC,IAAIuE,KAAK,CAAC1K,IAAI,KAAK,sBAAsB,IAAI0K,KAAK,CAAC1K,IAAI,KAAK,2BAA2B,EAAE;UACrFwR,OAAO,CAAC/K,IAAI,CAAC0G,SAAS,CAACzC,KAAK,CAAC,CAAC;QAClC;MACJ;MACA,OAAO;QACH1K,IAAI,EAAE,QAAQ;QACdwR;MACJ,CAAC;IACL,CAAC;IACDxC,wBAAwB,EAAEtO,MAAM,IAAI;MAChC,IAAIA,MAAM,CAACsH,WAAW,KAAK,QAAQ,EAAE;QACjC,MAAM,IAAI9H,KAAK,CAAC,yCAAyCQ,MAAM,CAACsH,WAAW,iBAAiB,CAAC;MACjG;MACA,OAAO;QACHhI,IAAI,EAAE,QAAQ;QACdgC,KAAK,EAAE;UACHhC,IAAI,EAAE,WAAW;UACjByR,UAAU,EAAEP,aAAa,CAACxQ,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC;UAC5CuE,IAAI,EAAE3L,MAAM,CAACsB;QACjB;MACJ,CAAC;IACL,CAAC;IACDuM,iBAAiB,EAAEA,CAAC7N,MAAM,EAAEyM,SAAS,KAAK;MACtC,IAAI4E,cAAc,GAAG,KAAK;MAC1B,IAAIlM,IAAI;MACR,IAAI4L,UAAU;MACd,IAAI/Q,MAAM,CAACmH,KAAK,CAAC7H,IAAI,KAAK,0BAA0B,IAAIU,MAAM,CAACmH,KAAK,CAACG,WAAW,KAAK,OAAO,EAAE;QAC1F+J,cAAc,GAAG,IAAI;QACrBlM,IAAI,GAAGnF,MAAM,CAACmH,KAAK,CAAC7F,KAAK;QACzByP,UAAU,GAAGP,aAAa,CAACxQ,MAAM,CAACmH,KAAK,CAACvC,IAAI,CAACwC,KAAK,CAAC;MACvD,CAAC,MACI;QACDjC,IAAI,GAAGnF,MAAM,CAACmH,KAAK,CAAC7F,KAAK;QACzByP,UAAU,GAAGP,aAAa,CAACxQ,MAAM,CAACmH,KAAK,CAACvC,IAAI,CAACwC,KAAK,CAAC;MACvD;MACA,MAAM6G,WAAW,GAAG;QAChB3O,IAAI,EAAEmR,aAAa,CAACzQ,MAAM,CAACgH,QAAQ,CAAC;QACpCsK,KAAK,EAAE7E,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;QAC7BoB,IAAI;QACJ4L,UAAU;QACVM;MACJ,CAAC;MACD,IAAIpD,WAAW,CAACqD,KAAK,CAAChS,IAAI,KAAK,QAAQ,EAAE;QACrC,MAAMiS,OAAO,GAAGtD,WAAW,CAACqD,KAAK;QACjCrD,WAAW,CAACqD,KAAK,GAAGrD,WAAW,CAACqD,KAAK,CAAChQ,KAAK;QAC3CiQ,OAAO,CAACjQ,KAAK,GAAG2M,WAAW;QAC3B,OAAOsD,OAAO;MAClB,CAAC,MACI;QACD,OAAOtD,WAAW;MACtB;IACJ,CAAC;IACDe,cAAc,EAAEA,CAAChP,MAAM,EAAEyM,SAAS,KAAKiE,WAAW,CAAC,OAAO,EAAE1Q,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC,CAAC;IAC3Fa,oBAAoB,EAAEA,CAACtN,MAAM,EAAEyM,SAAS,MAAM;MAC1CnN,IAAI,EAAE,aAAa;MACnBgC,KAAK,EAAEmL,SAAS,CAAC/J,gBAAgB,CAAC1C,MAAM,CAAC+C,OAAO,CAAC;IACrD,CAAC,CAAC;IACFyL,aAAa,EAAEA,CAAA,MAAO;MAClBlP,IAAI,EAAE,MAAM;MACZ6F,IAAI,EAAE;IACV,CAAC,CAAC;IACF8J,gBAAgB,EAAEA,CAAA,MAAO;MACrB3P,IAAI,EAAE;IACV,CAAC,CAAC;IACFwO,oBAAoB,EAAE9N,MAAM,KAAK;MAC7BV,IAAI,EAAE,cAAc;MACpByR,UAAU,EAAEP,aAAa,CAACxQ,MAAM,CAAC4E,IAAI,CAACwC,KAAK,CAAC;MAC5C4J,MAAM,EAAEhR,MAAM,CAACsB;IACnB,CAAC,CAAC;IACF4N,qBAAqB,EAAEA,CAAClP,MAAM,EAAEyM,SAAS,KAAKiE,WAAW,CAAC,cAAc,EAAE1Q,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC,CAAC;IACzGiC,eAAe,EAAE1O,MAAM,KAAK;MACxBV,IAAI,EAAE,cAAc;MACpBkS,MAAM,EAAExR,MAAM,CAACsB,KAAK,CAAC+F,QAAQ,CAAC;IAClC,CAAC,CAAC;IACFwH,eAAe,EAAEjC,qBAAqB;IACtCuC,iBAAiB,EAAEvC,qBAAqB;IACxCwC,kBAAkB,EAAExC,qBAAqB;IACzC0C,mBAAmB,EAAE1C,qBAAqB;IAC1CyC,uBAAuB,EAAEzC,qBAAqB;IAC9C2C,gBAAgB,EAAE3C;EACtB,CAAC;EACD,SAAS6E,YAAYA,CAACzR,MAAM,EAAE;IAC1B,OAAOyM,SAAS,CAACmE,QAAQ,EAAE5Q,MAAM,CAAC;EACtC;EAEA,SAAS0R,sBAAsBA,CAAA,EAAG;IAC9B,OAAO;MACHxC,qBAAqB,EAAEA,CAAClP,MAAM,EAAEyM,SAAS,MAAM;QAC3CnN,IAAI,EAAE,uBAAuB;QAC7BmG,QAAQ,EAAEzF,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS;MAC3C,CAAC,CAAC;MACFuB,gBAAgB,EAAEA,CAAChO,MAAM,EAAEyM,SAAS,MAAM;QACtCnN,IAAI,EAAE,kBAAkB;QACxByE,IAAI,EAAE0I,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;QAC5B0B,QAAQ,EAAEzF,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS,CAAC;QACxC7H,IAAI,EAAE;UACFwB,GAAG,EAAEpG,MAAM,CAAC4E,IAAI,CAACwB,GAAG;UACpBE,QAAQ,EAAEtG,MAAM,CAAC4E,IAAI,CAAC0B;QAC1B;MACJ,CAAC,CAAC;MACFmI,iBAAiB,EAAEzO,MAAM,IAAIA,MAAM;MACnCgP,cAAc,EAAEA,CAAChP,MAAM,EAAEyM,SAAS,MAAM;QACpCnN,IAAI,EAAE,gBAAgB;QACtBmG,QAAQ,EAAEzF,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS;MAC3C,CAAC,CAAC;MACFwC,gBAAgB,EAAEjP,MAAM,IAAIA,MAAM;MAClC+O,kBAAkB,EAAE/O,MAAM,IAAIA,MAAM;MACpC8O,eAAe,EAAEA,CAAC9O,MAAM,EAAEyM,SAAS,MAAM;QACrCnN,IAAI,EAAE,iBAAiB;QACvByD,OAAO,EAAE0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO;MACrC,CAAC,CAAC;MACF8L,eAAe,EAAEA,CAAC7O,MAAM,EAAEyM,SAAS,KAAK;QACpC,MAAMwB,WAAW,GAAG;UAChB3O,IAAI,EAAE,iBAAiB;UACvBgC,KAAK,EAAEtB,MAAM,CAACsB;QAClB,CAAC;QACD,IAAItB,MAAM,CAAC+C,OAAO,KAAK1D,SAAS,EAAE;UAC9B4O,WAAW,CAAClL,OAAO,GAAG0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;QACnD;QACA,OAAOkL,WAAW;MACtB,CAAC;MACDW,iBAAiB,EAAEA,CAAC5O,MAAM,EAAEyM,SAAS,MAAM;QACvCnN,IAAI,EAAE,mBAAmB;QACzByD,OAAO,EAAE0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;QAClC6B,IAAI,EAAE;UACFtE,QAAQ,EAAEN,MAAM,CAAC4E,IAAI,CAACtE;QAC1B;MACJ,CAAC,CAAC;MACFqO,eAAe,EAAEA,CAAC3O,MAAM,EAAEyM,SAAS,MAAM;QACrCnN,IAAI,EAAE,iBAAiB;QACvBsF,IAAI,EAAE;UACFkF,SAAS,EAAE;QACf,CAAC;QACDrE,QAAQ,EAAEzF,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS;MAC3C,CAAC,CAAC;MACFiC,eAAe,EAAE1O,MAAM,IAAIA,MAAM;MACjCwO,aAAa,EAAExO,MAAM,IAAIA,MAAM;MAC/BuO,oBAAoB,EAAEA,CAACvO,MAAM,EAAEyM,SAAS,MAAM;QAC1CnN,IAAI,EAAE,sBAAsB;QAC5ByD,OAAO,EAAE0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;QAClC6B,IAAI,EAAE;UACFtE,QAAQ,EAAEN,MAAM,CAAC4E,IAAI,CAACtE;QAC1B;MACJ,CAAC,CAAC;MACFgO,wBAAwB,EAAEtO,MAAM,IAAIA,MAAM;MAC1CmO,oBAAoB,EAAEA,CAACnO,MAAM,EAAEyM,SAAS,MAAM;QAC1CnN,IAAI,EAAE,sBAAsB;QAC5ByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG;QACf5B,KAAK,EAAEnH,MAAM,CAACmH,KAAK,KAAK9H,SAAS,GAAGA,SAAS,GAAGoN,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC;QACvE+C,QAAQ,EAAElK,MAAM,CAACkK,QAAQ;QACzBC,QAAQ,EAAEnK,MAAM,CAACmK,QAAQ;QACzBvF,IAAI,EAAE5E,MAAM,CAAC4E;MACjB,CAAC,CAAC;MACFwJ,yBAAyB,EAAEA,CAACpO,MAAM,EAAEyM,SAAS,MAAM;QAC/CnN,IAAI,EAAE,2BAA2B;QACjCyE,IAAI,EAAE0I,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;QAC5BoD,KAAK,EAAEsF,SAAS,CAACzM,MAAM,CAACmH,KAAK;MACjC,CAAC,CAAC;MACFkH,iBAAiB,EAAEA,CAACrO,MAAM,EAAEyM,SAAS,KAAK;QACtC,OAAO;UACHnN,IAAI,EAAE,mBAAmB;UACzByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG;UACf5B,KAAK,EAAEnH,MAAM,CAACmH,KAAK,KAAK9H,SAAS,GAAGA,SAAS,GAAGoN,SAAS,CAACzM,MAAM,CAACmH,KAAK,CAAC;UACvE+C,QAAQ,EAAElK,MAAM,CAACkK,QAAQ;UACzBW,QAAQ,EAAE7K,MAAM,CAAC6K;QACrB,CAAC;MACL,CAAC;MACDqD,eAAe,EAAEA,CAAClO,MAAM,EAAEyM,SAAS,MAAM;QACrCnN,IAAI,EAAE,iBAAiB;QACvByD,OAAO,EAAE0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO;MACrC,CAAC,CAAC;MACFgL,YAAY,EAAE/N,MAAM,IAAIA,MAAM;MAC9B8N,oBAAoB,EAAE9N,MAAM,IAAIA,MAAM;MACtC6N,iBAAiB,EAAE7N,MAAM,IAAIA,MAAM;MACnC4N,iBAAiB,EAAEA,CAAC5N,MAAM,EAAEyM,SAAS,KAAK;QACtC,MAAMwB,WAAW,GAAG;UAChB3O,IAAI,EAAE,mBAAmB;UACzBsF,IAAI,EAAE;YACFtE,QAAQ,EAAEN,MAAM,CAAC4E,IAAI,CAACtE,QAAQ;YAC9BgJ,cAAc,EAAEtJ,MAAM,CAAC4E,IAAI,CAAC0E;UAChC;QACJ,CAAC;QACD,IAAItJ,MAAM,CAAC+C,OAAO,KAAK1D,SAAS,EAAE;UAC9B4O,WAAW,CAAClL,OAAO,GAAG0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO,CAAC;QACnD;QACA,OAAOkL,WAAW;MACtB,CAAC;MACDN,cAAc,EAAEA,CAAC3N,MAAM,EAAEyM,SAAS,MAAM;QACpCnN,IAAI,EAAE,gBAAgB;QACtBmG,QAAQ,EAAEzF,MAAM,CAACyF,QAAQ,CAACyC,GAAG,CAACuE,SAAS;MAC3C,CAAC,CAAC;MACFiB,aAAa,EAAE1N,MAAM,IAAIA,MAAM;MAC/BwN,iBAAiB,EAAEA,CAACxN,MAAM,EAAEyM,SAAS,KAAK;QACtC,MAAMwB,WAAW,GAAG;UAChB3O,IAAI,EAAE,mBAAmB;UACzBsJ,KAAK,EAAE5I,MAAM,CAAC4I,KAAK;UACnBX,UAAU,EAAEjI,MAAM,CAACiI,UAAU,CAACC,GAAG,CAACuE,SAAS,CAAC;UAC5ChN,WAAW,EAAEO,MAAM,CAACP,WAAW;UAC/BoJ,WAAW,EAAE7I,MAAM,CAAC6I;QACxB,CAAC;QACD,IAAI7I,MAAM,CAACiJ,UAAU,KAAK5J,SAAS,EAAE;UACjC4O,WAAW,CAAChF,UAAU,GAAGwD,SAAS,CAACzM,MAAM,CAACiJ,UAAU,CAAC;QACzD;QACA,OAAOgF,WAAW;MACtB,CAAC;MACDV,cAAc,EAAEA,CAACvN,MAAM,EAAEyM,SAAS,MAAM;QACpCnN,IAAI,EAAE,gBAAgB;QACtByD,OAAO,EAAE0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO;MACrC,CAAC,CAAC;MACFuK,oBAAoB,EAAEA,CAACtN,MAAM,EAAEyM,SAAS,MAAM;QAC1CnN,IAAI,EAAE,sBAAsB;QAC5ByD,OAAO,EAAE0J,SAAS,CAACzM,MAAM,CAAC+C,OAAO;MACrC,CAAC,CAAC;MACFoM,iBAAiB,EAAEnP,MAAM,IAAIA,MAAM;MACnCoP,kBAAkB,EAAEA,CAACpP,MAAM,EAAEyM,SAAS,MAAM;QACxCnN,IAAI,EAAE,oBAAoB;QAC1ByE,IAAI,EAAE0I,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;QAC5BoD,KAAK,EAAEsF,SAAS,CAACzM,MAAM,CAACmH,KAAK;MACjC,CAAC,CAAC;MACFkI,uBAAuB,EAAEA,CAACrP,MAAM,EAAEyM,SAAS,MAAM;QAC7CnN,IAAI,EAAE,yBAAyB;QAC/ByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG;QACf5B,KAAK,EAAEsF,SAAS,CAACzM,MAAM,CAACmH,KAAK;MACjC,CAAC,CAAC;MACFmI,mBAAmB,EAAEA,CAACtP,MAAM,EAAEyM,SAAS,MAAM;QACzCnN,IAAI,EAAE,qBAAqB;QAC3ByJ,GAAG,EAAE/I,MAAM,CAAC+I,GAAG;QACf5B,KAAK,EAAEsF,SAAS,CAACzM,MAAM,CAACmH,KAAK;MACjC,CAAC,CAAC;MACFoI,gBAAgB,EAAEA,CAACvP,MAAM,EAAEyM,SAAS,MAAM;QACtCnN,IAAI,EAAE,kBAAkB;QACxByE,IAAI,EAAE0I,SAAS,CAACzM,MAAM,CAAC+D,IAAI,CAAC;QAC5BoD,KAAK,EAAEsF,SAAS,CAACzM,MAAM,CAACmH,KAAK;MACjC,CAAC;IACL,CAAC;EACL;EAEA,MAAMwK,WAAW,GAAG;IAChB5D,YAAY,EAAE,EAAE;IAChBP,iBAAiB,EAAE,CAAC,YAAY,EAAE,YAAY,CAAC;IAC/CQ,gBAAgB,EAAE,CAAC,MAAM,EAAE,UAAU,CAAC;IACtCE,eAAe,EAAE,EAAE;IACnBmB,uBAAuB,EAAE,CAAC,OAAO,CAAC;IAClCH,qBAAqB,EAAE,CAAC,UAAU,CAAC;IACnC3B,cAAc,EAAE,CAAC,SAAS,CAAC;IAC3Bc,iBAAiB,EAAE,CAAC,OAAO,CAAC;IAC5BiB,mBAAmB,EAAE,CAAC,OAAO,CAAC;IAC9B5B,aAAa,EAAE,EAAE;IACjBG,iBAAiB,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;IACpCU,oBAAoB,EAAE,CAAC,SAAS,CAAC;IACjCC,aAAa,EAAE,EAAE;IACjBC,iBAAiB,EAAE,CAAC,SAAS,CAAC;IAC9BC,eAAe,EAAE,EAAE;IACnBC,eAAe,EAAE,CAAC,UAAU,CAAC;IAC7BR,oBAAoB,EAAE,CAAC,OAAO,CAAC;IAC/BC,yBAAyB,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;IAC5CQ,iBAAiB,EAAE,CAAC,SAAS,CAAC;IAC9BtB,oBAAoB,EAAE,CAAC,SAAS,CAAC;IACjCgB,wBAAwB,EAAE,EAAE;IAC5BR,oBAAoB,EAAE,EAAE;IACxBe,eAAe,EAAE,CAAC,SAAS,CAAC;IAC5BlB,cAAc,EAAE,CAAC,UAAU,CAAC;IAC5BmB,eAAe,EAAE,CAAC,SAAS,CAAC;IAC5BC,kBAAkB,EAAE,EAAE;IACtBC,cAAc,EAAE,CAAC,UAAU,CAAC;IAC5BC,gBAAgB,EAAE,EAAE;IACpBrB,iBAAiB,EAAE,CAAC,SAAS,CAAC;IAC9BuB,iBAAiB,EAAE,EAAE;IACrBC,kBAAkB,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;IACrCG,gBAAgB,EAAE,CAAC,MAAM,EAAE,OAAO;EACtC,CAAC;EAED,SAASqC,SAASA,CAACC,IAAI,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC7DD,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACH,IAAI,EAAEC,UAAU,EAAEC,QAAQ,CAAC;IACrF,MAAMG,WAAW,GAAGP,WAAW,CAACE,IAAI,CAACvS,IAAI,CAAC;IAC1C,KAAK,MAAMyJ,GAAG,IAAImJ,WAAW,EAAE;MAC3B,MAAM5Q,KAAK,GAAGuQ,IAAI,CAAC9I,GAAG,CAAC;MACvB,IAAIzH,KAAK,KAAKjC,SAAS,EAAE;QACrB,IAAI8E,KAAK,CAACC,OAAO,CAAC9C,KAAK,CAAC,EAAE;UACtB,KAAK,MAAMyB,OAAO,IAAIzB,KAAK,EAAE;YACzBsQ,SAAS,CAAC7O,OAAO,EAAE8O,IAAI,EAAE9I,GAAG,EAAEiJ,OAAO,EAAEC,OAAO,CAAC;UACnD;QACJ,CAAC,MACI;UACDL,SAAS,CAACtQ,KAAK,EAAEuQ,IAAI,EAAE9I,GAAG,EAAEiJ,OAAO,EAAEC,OAAO,CAAC;QACjD;MACJ;IACJ;IACAA,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACJ,IAAI,EAAEC,UAAU,EAAEC,QAAQ,CAAC;EACzF;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,SAASI,QAAQA,CAACN,IAAI,EAAEG,OAAO,EAAEC,OAAO,EAAE;IACtCL,SAAS,CAACC,IAAI,EAAExS,SAAS,EAAEA,SAAS,EAAE2S,OAAO,EAAEC,OAAO,CAAC;EAC3D;EAEAtT,OAAO,CAAC4R,kBAAkB,GAAGA,kBAAkB;EAC/C5R,OAAO,CAAC+S,sBAAsB,GAAGA,sBAAsB;EACvD/S,OAAO,CAAC8S,YAAY,GAAGA,YAAY;EACnC9S,OAAO,CAAC6E,KAAK,GAAGA,KAAK;EACrB7E,OAAO,CAAC8Q,SAAS,GAAGA,SAAS;EAC7B9Q,OAAO,CAAC0O,cAAc,GAAGA,cAAc;EACvC1O,OAAO,CAAC8N,SAAS,GAAGA,SAAS;EAC7B9N,OAAO,CAACwT,QAAQ,GAAGA,QAAQ;EAC3BxT,OAAO,CAAC4N,QAAQ,GAAGA,QAAQ;EAC3B5N,OAAO,CAACgT,WAAW,GAAGA,WAAW;AAErC,CAAE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}